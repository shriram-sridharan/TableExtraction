<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="19" family="Times" color="#000000"/>
	<fontspec id="1" size="16" family="Times" color="#000000"/>
	<fontspec id="2" size="16" family="Times" color="#000000"/>
	<fontspec id="3" size="13" family="Times" color="#000000"/>
	<fontspec id="4" size="13" family="Times" color="#000000"/>
	<fontspec id="5" size="8" family="Times" color="#000000"/>
	<fontspec id="6" size="7" family="Times" color="#000000"/>
	<fontspec id="7" size="10" family="Times" color="#000000"/>
	<fontspec id="8" size="7" family="Helvetica" color="#000000"/>
<text top="156" left="89" width="745" height="20" font="0"><b>Improving the Table Boundary Detection in PDFs by Fixing the Sequence Error</b></text>
<text top="183" left="372" width="178" height="20" font="0"><b>of the Sparse Lines</b></text>
<text top="243" left="284" width="354" height="17" font="1">Ying Liu, Kun Bai, Prasenjit Mitra, C. Lee Giles</text>
<text top="265" left="282" width="357" height="17" font="1">College of Information Sciences and Technology</text>
<text top="286" left="262" width="398" height="17" font="1">The Penn State University, University Park, PA, 16803</text>
<text top="303" left="320" width="282" height="24" font="1">{yliu, kbai, pmitra, giles}@ist.psu.edu</text>
<text top="371" left="230" width="68" height="16" font="2"><b>Abstract</b></text>
<text top="410" left="102" width="342" height="14" font="3"><i>As the rapid growth of PDF documents, recognizing the</i></text>
<text top="428" left="84" width="360" height="14" font="3"><i>document structure and components are useful for docu-</i></text>
<text top="446" left="84" width="360" height="14" font="3"><i>ment storage, classiﬁcation and retrieval. Table, a ubiqui-</i></text>
<text top="465" left="84" width="360" height="14" font="3"><i>tous document component, becomes an important informa-</i></text>
<text top="483" left="84" width="360" height="14" font="3"><i>tion source. Accurately detecting the table boundary plays</i></text>
<text top="501" left="84" width="360" height="14" font="3"><i>a crucial role for many applications, e.g., the increasing</i></text>
<text top="519" left="84" width="360" height="14" font="3"><i>demand on the table data search. Rather than converting</i></text>
<text top="537" left="84" width="360" height="14" font="3"><i>PDFs to image or HTML and then processing with other</i></text>
<text top="556" left="84" width="360" height="14" font="3"><i>techniques (e.g., OCR), extracting and analyzing texts from</i></text>
<text top="574" left="84" width="360" height="14" font="3"><i>PDFs directly is easy and accurate. However, text extrac-</i></text>
<text top="592" left="84" width="360" height="14" font="3"><i>tion tools face a common problem: text sequence error. In</i></text>
<text top="610" left="84" width="360" height="14" font="3"><i>this paper, we propose two algorithms to recover the se-</i></text>
<text top="629" left="84" width="360" height="14" font="3"><i>quence of extracted sparse lines, which improve the table</i></text>
<text top="647" left="84" width="360" height="14" font="3"><i>content collection. The experimental results show the com-</i></text>
<text top="665" left="84" width="360" height="14" font="3"><i>parison of the performance of both algorithms, and demon-</i></text>
<text top="683" left="84" width="360" height="14" font="3"><i>strate the effectiveness of text sequence recovering for the</i></text>
<text top="701" left="84" width="156" height="14" font="3"><i>table boundary detection.</i></text>
<text top="757" left="84" width="117" height="16" font="2"><b>1. Introduction</b></text>
<text top="774" left="102" width="342" height="14" font="4">Portable document format (PDF) is a widely used docu-</text>
<text top="793" left="84" width="360" height="14" font="4">ment format. Although many researchers analyze PDF doc-</text>
<text top="811" left="84" width="360" height="14" font="4">uments by converting them to other formats (e.g., image,</text>
<text top="829" left="84" width="360" height="14" font="4">html), automatically identifying the PDF document logical</text>
<text top="847" left="84" width="360" height="14" font="4">structures information and document components (e.g., ﬁg-</text>
<text top="866" left="84" width="360" height="14" font="4">ures, tables, etc) are still challenging problems [2] because</text>
<text top="884" left="84" width="360" height="14" font="4">of three main reasons: 1) extracted texts from PDF ﬁles are</text>
<text top="902" left="84" width="360" height="14" font="4">non-tagged; 2) wrong text sequences are generated by the</text>
<text top="920" left="84" width="360" height="14" font="4">text extraction tools; 3) new noises are caused by necessary</text>
<text top="939" left="84" width="360" height="14" font="4">tools (e.g., OCR) when converting the PDFs into other for-</text>
<text top="957" left="84" width="107" height="14" font="4">mat (e.g., image).</text>
<text top="975" left="102" width="342" height="14" font="4">Tables, as a speciﬁc document component, are ubiqui-</text>
<text top="993" left="84" width="360" height="14" font="4">tous everywhere. To thoroughly analyzing the table con-</text>
<text top="1011" left="84" width="360" height="14" font="4">tent, locating the table boundary in a document is the ﬁrst</text>
<text top="1030" left="84" width="360" height="14" font="4">and crucial step for consequent applications (e.g., the table</text>
<text top="1048" left="84" width="360" height="14" font="4">search). Because most of the tables in scientiﬁc documents</text>
<text top="1066" left="84" width="360" height="14" font="4">are text-based tables, solely analyzing the text objects in</text>
<text top="373" left="478" width="360" height="14" font="4">a PDF ﬁle can achieve good performance in terms of sav-</text>
<text top="392" left="478" width="360" height="14" font="4">ing efforts on other objects. However, existing text extrac-</text>
<text top="410" left="478" width="360" height="14" font="4">tion tools face a common problem: the extracted text pieces</text>
<text top="428" left="478" width="360" height="14" font="4">follow a different sequence from its original appearance in</text>
<text top="446" left="478" width="360" height="14" font="4">PDF ﬁles. Although the wrong sequence does not affect</text>
<text top="465" left="478" width="360" height="14" font="4">the PDF documents displaying for browsing purpose, it can</text>
<text top="483" left="478" width="360" height="14" font="4">severely interfere the document content analyzing works</text>
<text top="501" left="478" width="360" height="14" font="4">that rely on the information of the relative location and se-</text>
<text top="519" left="478" width="360" height="14" font="4">quence among the text pieces. Table boundary detection is</text>
<text top="537" left="478" width="360" height="14" font="4">a typical example. In order to improve the accuracy of the</text>
<text top="556" left="478" width="360" height="14" font="4">table boundary detection, we need to recover the extracted</text>
<text top="574" left="478" width="360" height="14" font="4">text sequences to the orders that comply with the human’s</text>
<text top="592" left="478" width="360" height="14" font="4">reading habit. The sequence errors can be classiﬁed into two</text>
<text top="610" left="478" width="360" height="14" font="4">types: <i>within-table errors </i>and <i>beyond-table errors</i>. In this</text>
<text top="629" left="478" width="360" height="14" font="4">paper, we propose two text sequence recovering algorithms</text>
<text top="647" left="478" width="360" height="14" font="4">to ﬁx them. Our algorithms start with the detected sparse</text>
<text top="665" left="478" width="360" height="14" font="4">lines in each PDF page and detect the table boundaries by</text>
<text top="683" left="478" width="360" height="14" font="4">analyzing the sparse areas and the caption information. The</text>
<text top="701" left="478" width="360" height="14" font="4">detail of the sparse line detection is out of the scope of this</text>
<text top="720" left="478" width="354" height="14" font="4">paper. If interested, the details can be found in [3] and [4].</text>
<text top="738" left="496" width="342" height="14" font="4">The rest of the paper is organized as follows. Section 2</text>
<text top="756" left="478" width="360" height="14" font="4">gives the deﬁnition for main terms used in this paper. Sec-</text>
<text top="775" left="478" width="360" height="14" font="4">tion 3 elaborates two text sequence error categories. Section</text>
<text top="793" left="478" width="360" height="14" font="4">4 introduces two text sequence recovering algorithms and</text>
<text top="811" left="478" width="360" height="14" font="4">how to detect the table boundary based on the recovered se-</text>
<text top="829" left="478" width="360" height="14" font="4">quences. Section 5 demonstrates the experimental results.</text>
<text top="848" left="478" width="326" height="14" font="4">Conclusion and future work are included in section 6.</text>
<text top="889" left="478" width="9" height="16" font="2"><b>2</b></text>
<text top="889" left="505" width="130" height="16" font="2"><b>Term Deﬁnitions</b></text>
<text top="910" left="496" width="135" height="14" font="4">Free online dictionary</text>
<text top="907" left="632" width="5" height="10" font="5">1</text>
<text top="910" left="642" width="196" height="14" font="4">deﬁnes a table as <i>an orderly ar-</i></text>
<text top="928" left="478" width="360" height="14" font="3"><i>rangement of data, especially one in which the data are ar-</i></text>
<text top="946" left="478" width="360" height="14" font="3"><i>ranged in columns and rows in an essentially rectangular</i></text>
<text top="964" left="478" width="360" height="14" font="3"><i>form</i>. In addition, we add an additional restriction on the</text>
<text top="983" left="478" width="360" height="14" font="4">deﬁnition of tables in scientiﬁc documents: each table has</text>
<text top="1001" left="478" width="360" height="14" font="4">a caption that starts with a keyword (e.g., “Table” or “TA-</text>
<text top="1019" left="478" width="360" height="14" font="4">BLE”). With this restriction, the tables can be understood</text>
<text top="1037" left="478" width="360" height="14" font="4">as genuine tables [6]. The table boundary includes all the</text>
<text top="1066" left="495" width="5" height="8" font="6">1</text>
<text top="1068" left="500" width="191" height="11" font="7">http://www.thefreedictionary.com/table</text>
<text top="68" left="230" width="457" height="14" font="4">2009 10th International Conference on Document Analysis and Recognition</text>
<text top="1112" left="75" width="213" height="11" font="7">978-0-7695-3725-2/09 $25.00 © 2009 IEEE</text>
<text top="1127" left="75" width="152" height="11" font="7">DOI 10.1109/ICDAR.2009.138</text>
<text top="1112" left="447" width="24" height="11" font="7">1006</text>
<text top="1175" left="107" width="555" height="8" font="8">Authorized licensed use limited to: Penn State University. Downloaded on February 9, 2010 at 16:37 from IEEE Xplore.  Restrictions apply. </text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="9" size="12" family="Times" color="#000000"/>
	<fontspec id="10" size="12" family="Times" color="#000000"/>
	<fontspec id="11" size="15" family="Times" color="#000000"/>
	<fontspec id="12" size="12" family="Times" color="#000000"/>
<text top="162" left="103" width="340" height="13" font="9">parts in the Wang’s model [5]. Both table caption and foot-</text>
<text top="179" left="103" width="124" height="13" font="9">note are not included.</text>
<text top="197" left="120" width="323" height="13" font="9">Different lines in the same page have different internal</text>
<text top="214" left="103" width="340" height="13" font="10"><i>space size</i>, <i>text density</i>, and <i>length</i>. A document page con-</text>
<text top="232" left="103" width="340" height="13" font="9">tains at least one column and many have two (e.g., ACM and</text>
<text top="249" left="103" width="340" height="13" font="9">IEEE conference formats), or three even four columns. The</text>
<text top="266" left="103" width="340" height="13" font="9">length of lines can be equal to, longer (e.g., cross-column</text>
<text top="283" left="103" width="340" height="13" font="9">lines), or shorter (e.g., some headings) than the width of the</text>
<text top="300" left="103" width="340" height="13" font="9">document column. Because single-column documents are</text>
<text top="318" left="103" width="340" height="13" font="9">easy to process, in this paper, we focus on the most popular</text>
<text top="335" left="103" width="340" height="13" font="9">yet challenging digital document template: double-column</text>
<text top="352" left="103" width="340" height="13" font="9">formatting. From the internal space perspective, the major-</text>
<text top="369" left="103" width="340" height="13" font="9">ity of the lines contain normal space size while some lines</text>
<text top="386" left="103" width="340" height="13" font="9">have large space size, between two adjacent words. We de-</text>
<text top="404" left="103" width="340" height="13" font="9">ﬁne a line as a <i>sparse </i>line if it satisﬁes at least one of the</text>
<text top="421" left="103" width="340" height="13" font="9">following conditions: 1) This line contains at least one large</text>
<text top="438" left="103" width="340" height="13" font="9">space gap between a pair of consecutive words within the</text>
<text top="455" left="103" width="340" height="13" font="9">line; 2) The length of this line is much shorter than a thresh-</text>
<text top="472" left="103" width="340" height="13" font="9">old <i>ll</i>; Note, different deﬁnitions of “large” and the thresh-</text>
<text top="490" left="103" width="340" height="13" font="9">old <i>ll </i>generate different results. Based on the observation</text>
<text top="507" left="103" width="340" height="13" font="9">and the statistical results on thousands of table examples, in</text>
<text top="524" left="103" width="340" height="13" font="9">this paper we set the “large” as the double of the average</text>
<text top="541" left="103" width="340" height="13" font="9">space between words in document body content lines, and</text>
<text top="558" left="103" width="284" height="13" font="10"><i>ll </i>as the two third of the document column width;</text>
<text top="576" left="120" width="323" height="13" font="10"><i>Non-sparse </i>lines, which satisfy neither of the conditions,</text>
<text top="593" left="103" width="340" height="13" font="9">usually occur in the following document components: long</text>
<text top="611" left="103" width="340" height="13" font="9">document titles, the abstracts, the body content paragraphs,</text>
<text top="628" left="103" width="340" height="13" font="9">etc. <i>Sparse </i>lines cover other speciﬁc document compo-</text>
<text top="645" left="103" width="340" height="13" font="9">nents: tables, texts in ﬁgures, mathematical formulas, doc-</text>
<text top="662" left="103" width="340" height="13" font="9">ument afﬁliations, and references, etc. Since the majority</text>
<text top="679" left="103" width="340" height="13" font="9">lines in a document are non-sparse lines, ﬁltering them out</text>
<text top="697" left="103" width="340" height="13" font="9">as early as possible is an effective preprocessing step for the</text>
<text top="714" left="103" width="340" height="13" font="9">table boundary detection because we can save a substantial</text>
<text top="731" left="103" width="340" height="13" font="9">amount of time and effort and narrow down the table bound-</text>
<text top="748" left="103" width="340" height="13" font="9">ary to the sparse lines easily. The detection and ﬁltering</text>
<text top="765" left="103" width="340" height="13" font="9">work is out the scope of this paper. If interested, the details</text>
<text top="783" left="103" width="340" height="13" font="9">can be found in [3] [4]. Our text sequence recovering algo-</text>
<text top="800" left="103" width="340" height="13" font="9">rithm starts with the detected sparse lines. Figure 1 shows</text>
<text top="817" left="103" width="340" height="13" font="9">in a document page with a wide table while Figure 2 shows</text>
<text top="834" left="103" width="340" height="13" font="9">the ﬁltered sparse lines in another document page with two</text>
<text top="851" left="103" width="84" height="13" font="9">parallel tables.</text>
<text top="891" left="103" width="9" height="16" font="11"><b>3</b></text>
<text top="891" left="128" width="197" height="16" font="11"><b>The text sequence problem</b></text>
<text top="912" left="120" width="323" height="13" font="9">Given a PDF document page, the human reading se-</text>
<text top="929" left="103" width="340" height="13" font="9">quence is usually top-down, left-to-right, and line by line,</text>
<text top="947" left="103" width="340" height="13" font="9">column by column. Particularly, some document compo-</text>
<text top="964" left="103" width="340" height="13" font="9">nents in the page may cross multiple document columns,</text>
<text top="981" left="103" width="340" height="13" font="9">such as the document title, the afﬁliation, some wide ta-</text>
<text top="998" left="103" width="340" height="13" font="9">bles and ﬁgures. Although the text extraction tools can ex-</text>
<text top="1015" left="103" width="340" height="13" font="9">tract all the text information from a PDF page, the sequence</text>
<text top="1032" left="103" width="340" height="13" font="9">of the exported texts may not reﬂect the human reading</text>
<text top="1050" left="103" width="340" height="13" font="9">ordering. The text sequence error is a common problem</text>
<text top="1067" left="103" width="340" height="13" font="9">shared by existing text extraction tools (e.g., PDF2TEXT,</text>
<text top="347" left="492" width="305" height="13" font="12"><b>Figure 1. A document page with a cross-</b></text>
<text top="365" left="492" width="305" height="13" font="12"><b>column table (left) and its sparse lines (right)</b></text>
<text top="567" left="492" width="305" height="13" font="12"><b>Figure 2. A document page with two parallel</b></text>
<text top="584" left="492" width="258" height="13" font="12"><b>tables (left) and its sparse lines (right)</b></text>
<text top="617" left="475" width="340" height="13" font="9">PDFBOX, TET, PDFTextStream). Such text sequence error</text>
<text top="634" left="475" width="340" height="13" font="9">happens frequently in the table contents, which may gener-</text>
<text top="651" left="475" width="340" height="13" font="9">ates serious wrong results during the table detection, such as</text>
<text top="668" left="475" width="340" height="13" font="9">segmenting a table into several pieces, wrong column/row</text>
<text top="686" left="475" width="340" height="13" font="9">information, and omitting cells/whole tables etc. Some of</text>
<text top="703" left="475" width="340" height="13" font="9">the errors can be ﬁxed with complex post-processing while</text>
<text top="720" left="475" width="340" height="13" font="9">others can not. According to the scope of the text sequence</text>
<text top="737" left="475" width="340" height="13" font="9">errors, we category them into two classes: <i>inside-table </i>text</text>
<text top="754" left="475" width="301" height="13" font="9">sequence error and <i>beyond-table </i>text sequence error.</text>
<text top="773" left="492" width="323" height="13" font="9">Figure <i>3a </i>provides an example of the <i>inside-table </i>text</text>
<text top="790" left="475" width="340" height="13" font="9">sequence error. The text extraction tools export 33 sparse</text>
<text top="807" left="475" width="340" height="13" font="9">lines in such a sequence: <i>“Content (% m/m)”, “Proposed</i></text>
<text top="825" left="475" width="340" height="13" font="10"><i>method”, “Peak Peak”, “Sample Element height area”,</i></text>
<text top="842" left="475" width="340" height="13" font="10"><i>“Low melt Ag 43.9 44.1”, “0.5 2.4”, “Cu 15.6 15.2”, “2.7</i></text>
<text top="859" left="475" width="340" height="13" font="10"><i>1.8”, “Sample No.318+ Ag 25.7 25.2”, “Cu 34.4 33.7”,</i></text>
<text top="876" left="475" width="340" height="13" font="10"><i>“2.3 1.3”, “2.1 2.1”, “Reference”, “Flame value”, “AAS</i></text>
<text top="893" left="475" width="263" height="13" font="10"><i>(%m/m)”, “45.1 44.46”, “15.3 14-16”, “25.7</i></text>
<text top="890" left="741" width="74" height="19" font="9">≈<i>25”, “34.8</i></text>
<text top="907" left="475" width="340" height="19" font="9">≈<i>35”, “1.1”, “2.5”, “1.4”, “2.5”. </i>The sequence is: the</text>
<text top="928" left="475" width="340" height="13" font="9">ﬁrst four columns, then the last two columns. Moreover,</text>
<text top="945" left="475" width="340" height="13" font="9">within the same column, the ordering of rows does not ex-</text>
<text top="962" left="475" width="340" height="13" font="9">actly follow the top-down manner. In this type, the errors</text>
<text top="979" left="475" width="340" height="13" font="9">happen only within the table boundary and no outside text</text>
<text top="997" left="475" width="340" height="13" font="9">interrupts them. No matter how disordered the sequence is,</text>
<text top="1014" left="475" width="296" height="13" font="9">all the contents of a table come together as a whole.</text>
<text top="1032" left="492" width="323" height="13" font="9">In <i>beyond-table </i>text sequence error, the table lines are</text>
<text top="1050" left="475" width="340" height="13" font="9">partitioned into at least two parts by non-table lines. The</text>
<text top="1067" left="475" width="340" height="13" font="9">text extraction tools usually export a part of the table con-</text>
<text top="1112" left="447" width="24" height="11" font="7">1007</text>
<text top="1175" left="107" width="555" height="8" font="8">Authorized licensed use limited to: Penn State University. Downloaded on February 9, 2010 at 16:37 from IEEE Xplore.  Restrictions apply. </text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="13" size="9" family="Times" color="#000000"/>
	<fontspec id="14" size="14" family="Times" color="#000000"/>
	<fontspec id="15" size="5" family="Times" color="#000000"/>
<text top="304" left="255" width="13" height="11" font="13">(a)</text>
<text top="513" left="255" width="14" height="11" font="13">(b)</text>
<text top="552" left="105" width="319" height="14" font="12"><b>Figure 3. Two examples of the text sequence</b></text>
<text top="570" left="105" width="43" height="14" font="12"><b>errors</b></text>
<text top="622" left="87" width="355" height="14" font="9">tent ﬁrst, jump to another document area and process it, and</text>
<text top="640" left="87" width="355" height="14" font="9">then come back to ﬁnish the rest of the table sections. Such</text>
<text top="658" left="87" width="355" height="14" font="9">alternation happens at least once. Figure 3b shows an exam-</text>
<text top="676" left="87" width="355" height="14" font="9">ple: the text extraction tools output the table caption ﬁrst on</text>
<text top="694" left="87" width="355" height="14" font="9">the second document column, then jump to the ﬁrst docu-</text>
<text top="712" left="87" width="355" height="14" font="9">ment column on the left and process some scattered texts in</text>
<text top="730" left="87" width="355" height="14" font="9">the ﬁgures. After telling the ﬁgure caption, they come back</text>
<text top="748" left="87" width="355" height="14" font="9">to the table area. Sometimes, the tools extract several table</text>
<text top="766" left="87" width="355" height="14" font="9">columns then jump to other areas (e.g., the following regu-</text>
<text top="784" left="87" width="355" height="14" font="9">lar document contents) to ﬁnish several lines or paragraphs,</text>
<text top="802" left="87" width="355" height="14" font="9">then return to the table data again. With such <i>beyond-table</i></text>
<text top="820" left="87" width="355" height="14" font="9">text sequence errors, collecting all the table cells is a chal-</text>
<text top="838" left="87" width="355" height="14" font="9">lenging task because it is difﬁcult to predict how far the</text>
<text top="856" left="87" width="246" height="14" font="9">distances are among different table parts.</text>
<text top="887" left="105" width="337" height="14" font="9">In order to accurately collect the table cells from a page</text>
<text top="905" left="87" width="355" height="14" font="9">and recover the sequence, resorting the texts in the page is</text>
<text top="922" left="87" width="355" height="14" font="9">one approach. B. Yildiz et. al mentioned the similar idea</text>
<text top="940" left="87" width="355" height="14" font="9">in [7] but without any detail about the methodology and the</text>
<text top="958" left="87" width="355" height="14" font="9">performance. Other proposed approaches [1] exploit geo-</text>
<text top="976" left="87" width="355" height="14" font="9">metric or typographic features of the page objects, and go</text>
<text top="994" left="87" width="355" height="14" font="9">further in exploiting the content of object. X-Y cut approach</text>
<text top="1012" left="87" width="355" height="14" font="9">is a representing method. However, its performance is not</text>
<text top="1030" left="87" width="355" height="14" font="9">satisfying. Moreover, these proposed works need to process</text>
<text top="1048" left="87" width="355" height="14" font="9">both sparse lines and non-sparse lines. The more non-sparse</text>
<text top="1066" left="87" width="286" height="14" font="9">lines involve, the higher possibility errors incur.</text>
<text top="119" left="476" width="9" height="16" font="11"><b>4</b></text>
<text top="119" left="502" width="280" height="16" font="11"><b>Text sequence recovering algorithms</b></text>
<text top="141" left="493" width="337" height="14" font="9">To ﬁx the text sequence error problem, we propose two</text>
<text top="159" left="476" width="355" height="14" font="9">methods to resort the detected sparse lines within a given</text>
<text top="177" left="476" width="355" height="14" font="9">area. For the inside-table text sequence errors, the area is</text>
<text top="195" left="476" width="355" height="14" font="9">the table itself. For the beyond-table text sequence errors,</text>
<text top="213" left="476" width="355" height="14" font="9">the area is the whole page. Some pages have multiple doc-</text>
<text top="231" left="476" width="355" height="14" font="9">ument columns, whether considering such information or</text>
<text top="249" left="476" width="355" height="14" font="9">not may generate different results for different cases. In</text>
<text top="267" left="476" width="355" height="14" font="9">this paper, we try both of them and analyze their advan-</text>
<text top="285" left="476" width="122" height="14" font="9">tages/disadvantages.</text>
<text top="325" left="476" width="24" height="15" font="14">4.1</text>
<text top="325" left="519" width="312" height="15" font="14">Algorithm 1: Considering the docu-</text>
<text top="343" left="519" width="211" height="15" font="14">ment column information</text>
<text top="363" left="493" width="337" height="14" font="9">The recovering procedure includes two parts: the <i>cross-</i></text>
<text top="381" left="476" width="355" height="14" font="10"><i>column resorting</i>, and the <i>within-column resorting</i>. Here</text>
<text top="399" left="476" width="355" height="14" font="9">the <i>column </i>refers to the document column instead of the</text>
<text top="417" left="476" width="355" height="14" font="9">table column. How to get the document column informa-</text>
<text top="435" left="476" width="355" height="14" font="9">tion is out of scope of this paper. We adopt an easy but</text>
<text top="453" left="476" width="355" height="14" font="9">effective method by calculating the average length of the</text>
<text top="471" left="476" width="355" height="14" font="9">non-sparse lines then comparing with the document width.</text>
<text top="489" left="476" width="355" height="14" font="9">For the <i>inside-table text sequence disordering</i>, we only im-</text>
<text top="507" left="476" width="355" height="14" font="9">plement the <i>within-column resorting</i>. For the <i>beyond-table</i></text>
<text top="525" left="476" width="355" height="14" font="10"><i>text sequence disordering</i>, we have to implement both re-</text>
<text top="543" left="476" width="51" height="14" font="9">sortings.</text>
<text top="562" left="493" width="182" height="14" font="9">In the <i>cross-column resorting</i>,</text>
<text top="558" left="680" width="150" height="19" font="9">SL denotes the set of all</text>
<text top="580" left="476" width="221" height="14" font="9">the sparse lines in a document page:</text>
<text top="576" left="703" width="37" height="19" font="9">SL =</text>
<text top="575" left="758" width="11" height="11" font="5">m</text>
<text top="587" left="758" width="19" height="11" font="5">i=1</text>
<text top="576" left="778" width="10" height="19" font="9">(l</text>
<text top="585" left="789" width="4" height="11" font="5">i</text>
<text top="576" left="794" width="37" height="19" font="9">). For</text>
<text top="598" left="476" width="119" height="14" font="9">a document column</text>
<text top="594" left="598" width="23" height="19" font="9">CO</text>
<text top="603" left="621" width="6" height="11" font="5">k</text>
<text top="598" left="629" width="202" height="14" font="9">, its beginning and ending X-axes</text>
<text top="616" left="476" width="61" height="14" font="9">values are</text>
<text top="612" left="541" width="12" height="19" font="9">X</text>
<text top="621" left="553" width="11" height="11" font="5">co</text>
<text top="623" left="565" width="6" height="10" font="15">k</text>
<text top="616" left="577" width="22" height="14" font="9">and</text>
<text top="612" left="603" width="12" height="19" font="9">X</text>
<text top="623" left="615" width="11" height="11" font="5">co</text>
<text top="624" left="626" width="6" height="10" font="15">k</text>
<text top="616" left="634" width="168" height="14" font="9">. Each column has a vector</text>
<text top="612" left="807" width="24" height="19" font="9">v to</text>
<text top="634" left="476" width="355" height="14" font="9">store its sparse lines. Initially, the vector is empty. For each</text>
<text top="652" left="476" width="355" height="14" font="9">sparse line, we compare its X-axis coordinates with doc-</text>
<text top="670" left="476" width="323" height="14" font="9">ument columns and append it in the matched vector</text>
<text top="666" left="804" width="27" height="19" font="9">v, if</text>
<text top="688" left="476" width="355" height="14" font="9">applicable. Some sparse lines may cross several document</text>
<text top="706" left="476" width="355" height="14" font="9">columns. Such lines usually are lines in cross-column ta-</text>
<text top="724" left="476" width="355" height="14" font="9">bles/ﬁgures or long document titles or afﬁliations, etc. We</text>
<text top="742" left="476" width="206" height="14" font="9">record such lines in another vector</text>
<text top="738" left="686" width="7" height="19" font="9">v</text>
<text top="747" left="693" width="11" height="11" font="5">cc</text>
<text top="742" left="704" width="4" height="14" font="9">.</text>
<text top="761" left="493" width="337" height="14" font="9">In the <i>within-column resorting </i>part, the inputs include</text>
<text top="779" left="476" width="98" height="14" font="9">the ﬁlled vector</text>
<text top="775" left="580" width="54" height="19" font="9">V and V</text>
<text top="784" left="634" width="11" height="11" font="5">cc</text>
<text top="779" left="646" width="185" height="14" font="9">. The output is a new vector</text>
<text top="793" left="476" width="9" height="19" font="9">V</text>
<text top="802" left="484" width="34" height="11" font="5">sorted</text>
<text top="797" left="519" width="312" height="14" font="9">, which stores all sorted sparse lines. For each doc-</text>
<text top="815" left="476" width="87" height="14" font="9">ument column</text>
<text top="811" left="567" width="23" height="19" font="9">CO</text>
<text top="820" left="590" width="6" height="11" font="5">k</text>
<text top="815" left="598" width="233" height="14" font="9">, we get all the Y-axis values from the</text>
<text top="833" left="476" width="130" height="14" font="9">sparse lines in vector</text>
<text top="829" left="610" width="7" height="19" font="9">v</text>
<text top="838" left="617" width="6" height="11" font="5">k</text>
<text top="833" left="625" width="206" height="14" font="9">. Among these Y-axis values, we</text>
<text top="851" left="476" width="355" height="14" font="9">identify all the non-duplicated values and sort them, and</text>
<text top="869" left="476" width="156" height="14" font="9">store them in a new vector</text>
<text top="865" left="635" width="9" height="19" font="9">V</text>
<text top="874" left="644" width="6" height="11" font="5">y</text>
<text top="869" left="651" width="180" height="14" font="9">. With these Y-axis values, we</text>
<text top="887" left="476" width="175" height="14" font="9">sort all sparse lines in vector</text>
<text top="883" left="655" width="7" height="19" font="9">v</text>
<text top="892" left="662" width="6" height="11" font="5">k</text>
<text top="887" left="674" width="157" height="14" font="9">accordingly. This method</text>
<text top="905" left="476" width="355" height="14" font="9">works well for the tables that are located within one doc-</text>
<text top="922" left="476" width="355" height="14" font="9">ument column (e.g., the table in Figure 3b). However, for</text>
<text top="940" left="476" width="355" height="14" font="9">the wide tables that cross more than one document column</text>
<text top="958" left="476" width="355" height="14" font="9">(see Figure 1a), this algorithm may generate errors because</text>
<text top="976" left="476" width="355" height="14" font="9">it is difﬁcult to know which lines should cross the docu-</text>
<text top="994" left="476" width="355" height="14" font="9">ment columns in advance. If there are overlaps between the</text>
<text top="1012" left="476" width="355" height="14" font="9">table column spaces and the document column spaces, this</text>
<text top="1030" left="476" width="355" height="14" font="9">method will segment a whole table into at least two parts.</text>
<text top="1048" left="476" width="355" height="14" font="9">Although some table lines may block the document column</text>
<text top="1066" left="476" width="327" height="14" font="9">space, it is difﬁcult to identify the last line of the table.</text>
<text top="1112" left="447" width="24" height="11" font="7">1008</text>
<text top="1175" left="107" width="555" height="8" font="8">Authorized licensed use limited to: Penn State University. Downloaded on February 9, 2010 at 16:37 from IEEE Xplore.  Restrictions apply. </text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="16" size="13" family="Times" color="#000000"/>
	<fontspec id="17" size="8" family="Times" color="#000000"/>
<text top="112" left="91" width="332" height="14" font="16"><b>Algorithm 1</b>: Sorting sparse lines across the document</text>
<text top="130" left="91" width="51" height="14" font="4">columns</text>
<text top="148" left="100" width="139" height="14" font="16"><b>Input</b>: All sparse lines</text>
<text top="144" left="242" width="51" height="20" font="4">SL = ∪</text>
<text top="146" left="293" width="11" height="11" font="5">m</text>
<text top="155" left="293" width="20" height="11" font="5">i=1</text>
<text top="144" left="314" width="12" height="20" font="4">sl</text>
<text top="154" left="325" width="4" height="11" font="5">i</text>
<text top="148" left="334" width="55" height="14" font="4">in a page</text>
<text top="167" left="100" width="278" height="14" font="16"><b>Input</b>: the information of Document columns</text>
<text top="181" left="145" width="54" height="20" font="4">CO = ∪</text>
<text top="181" left="199" width="6" height="11" font="5">p</text>
<text top="192" left="199" width="22" height="11" font="5">k=1</text>
<text top="181" left="222" width="14" height="20" font="4">co</text>
<text top="190" left="236" width="6" height="11" font="5">k</text>
<text top="185" left="244" width="155" height="14" font="4">. The sparse lines that are</text>
<text top="203" left="145" width="131" height="14" font="4">located in the column</text>
<text top="199" left="280" width="14" height="20" font="4">co</text>
<text top="208" left="294" width="6" height="11" font="5">k</text>
<text top="203" left="305" width="121" height="14" font="4">will be stored in the</text>
<text top="221" left="145" width="128" height="14" font="4">corresponding vector</text>
<text top="217" left="277" width="7" height="20" font="4">v</text>
<text top="227" left="285" width="6" height="11" font="5">k</text>
<text top="239" left="100" width="93" height="14" font="16"><b>Input</b>: a vector</text>
<text top="236" left="197" width="9" height="20" font="4">V</text>
<text top="245" left="206" width="11" height="11" font="5">cc</text>
<text top="239" left="221" width="195" height="14" font="4">to store the cross-column sparse</text>
<text top="258" left="145" width="32" height="14" font="4">lines.</text>
<text top="254" left="182" width="9" height="20" font="4">V</text>
<text top="263" left="191" width="11" height="11" font="5">cc</text>
<text top="254" left="207" width="24" height="20" font="4">= ∅</text>
<text top="276" left="100" width="35" height="14" font="16"><b>begin</b></text>
<text top="279" left="87" width="5" height="10" font="17"><b>1</b></text>
<text top="294" left="123" width="48" height="14" font="16"><b>foreach</b></text>
<text top="290" left="175" width="12" height="20" font="4">sl</text>
<text top="299" left="187" width="4" height="11" font="5">i</text>
<text top="290" left="196" width="55" height="20" font="4">∈ SL <b>do</b></text>
<text top="297" left="87" width="5" height="10" font="17"><b>2</b></text>
<text top="308" left="147" width="9" height="20" font="4">x</text>
<text top="318" left="155" width="10" height="11" font="5">sl</text>
<text top="319" left="165" width="4" height="10" font="15">i</text>
<text top="308" left="175" width="163" height="20" font="4">← the starting X-axis of sl</text>
<text top="318" left="338" width="4" height="11" font="5">i</text>
<text top="312" left="343" width="4" height="14" font="4">;</text>
<text top="315" left="87" width="5" height="10" font="17"><b>3</b></text>
<text top="330" left="147" width="9" height="20" font="4">x</text>
<text top="341" left="155" width="10" height="11" font="5">sl</text>
<text top="343" left="165" width="4" height="10" font="15">i</text>
<text top="330" left="175" width="159" height="20" font="4">← the ending X-axis of sl</text>
<text top="339" left="333" width="4" height="11" font="5">i</text>
<text top="333" left="338" width="4" height="14" font="4">;</text>
<text top="337" left="87" width="5" height="10" font="17"><b>4</b></text>
<text top="354" left="147" width="197" height="14" font="16"><b>while </b><i>the next document column</i></text>
<text top="350" left="347" width="14" height="20" font="4">co</text>
<text top="359" left="361" width="6" height="11" font="5">k</text>
<text top="354" left="373" width="53" height="14" font="3"><i>exists </i><b>do</b></text>
<text top="357" left="87" width="5" height="10" font="17"><b>5</b></text>
<text top="368" left="170" width="9" height="20" font="4">x</text>
<text top="377" left="179" width="11" height="11" font="5">co</text>
<text top="379" left="190" width="6" height="10" font="15">k</text>
<text top="368" left="202" width="165" height="20" font="4">← the starting X-axis of co</text>
<text top="377" left="367" width="6" height="11" font="5">k</text>
<text top="372" left="374" width="4" height="14" font="4">;</text>
<text top="375" left="87" width="5" height="10" font="17"><b>6</b></text>
<text top="389" left="170" width="9" height="20" font="4">x</text>
<text top="400" left="179" width="11" height="11" font="5">co</text>
<text top="402" left="190" width="6" height="10" font="15">k</text>
<text top="389" left="202" width="161" height="20" font="4">← the ending X-axis of co</text>
<text top="398" left="363" width="6" height="11" font="5">k</text>
<text top="393" left="370" width="4" height="14" font="4">;</text>
<text top="396" left="87" width="5" height="10" font="17"><b>7</b></text>
<text top="414" left="170" width="18" height="14" font="16"><b>if </b><i>(</i></text>
<text top="410" left="188" width="9" height="20" font="4">x</text>
<text top="420" left="197" width="11" height="11" font="5">co</text>
<text top="422" left="208" width="6" height="10" font="15">k</text>
<text top="410" left="236" width="9" height="20" font="4">x</text>
<text top="420" left="244" width="10" height="11" font="5">sl</text>
<text top="421" left="254" width="4" height="10" font="15">i</text>
<text top="410" left="264" width="25" height="20" font="4">&lt; x</text>
<text top="422" left="289" width="10" height="11" font="5">sl</text>
<text top="424" left="298" width="4" height="10" font="15">i</text>
<text top="410" left="324" width="9" height="20" font="4">x</text>
<text top="421" left="333" width="11" height="11" font="5">co</text>
<text top="423" left="344" width="6" height="10" font="15">k</text>
<text top="414" left="351" width="37" height="14" font="3"><i>) </i><b>then</b></text>
<text top="418" left="87" width="5" height="10" font="17"><b>8</b></text>
<text top="429" left="193" width="7" height="20" font="4">v</text>
<text top="438" left="201" width="6" height="11" font="5">k</text>
<text top="429" left="212" width="23" height="20" font="4">= v</text>
<text top="438" left="236" width="6" height="11" font="5">k</text>
<text top="429" left="247" width="27" height="20" font="4">+ sl</text>
<text top="438" left="273" width="4" height="11" font="5">i</text>
<text top="433" left="278" width="4" height="14" font="4">;</text>
<text top="436" left="87" width="5" height="10" font="17"><b>9</b></text>
<text top="451" left="193" width="38" height="14" font="4">break;</text>
<text top="454" left="82" width="11" height="10" font="17"><b>10</b></text>
<text top="481" left="147" width="9" height="14" font="16"><b>if</b></text>
<text top="477" left="160" width="12" height="20" font="4">sl</text>
<text top="486" left="171" width="4" height="11" font="5">i</text>
<text top="481" left="180" width="180" height="14" font="3"><i>ﬁts no document column </i><b>then</b></text>
<text top="484" left="82" width="11" height="10" font="17"><b>11</b></text>
<text top="495" left="170" width="7" height="20" font="4">v</text>
<text top="505" left="177" width="11" height="11" font="5">cc</text>
<text top="495" left="193" width="23" height="20" font="4">= v</text>
<text top="505" left="217" width="11" height="11" font="5">cc</text>
<text top="495" left="232" width="27" height="20" font="4">+ sl</text>
<text top="505" left="258" width="4" height="11" font="5">i</text>
<text top="499" left="263" width="4" height="14" font="4">;</text>
<text top="502" left="82" width="11" height="10" font="17"><b>12</b></text>
<text top="529" left="100" width="24" height="14" font="16"><b>end</b></text>
<text top="532" left="82" width="11" height="10" font="17"><b>13</b></text>
<text top="586" left="82" width="25" height="15" font="14">4.2</text>
<text top="586" left="125" width="316" height="15" font="14">Algorithm 2: Without considering the</text>
<text top="604" left="125" width="254" height="15" font="14">document column information</text>
<text top="620" left="100" width="342" height="14" font="4">To deal with the above special cases, we propose an-</text>
<text top="638" left="82" width="360" height="14" font="4">other text sorting algorithm without considering the docu-</text>
<text top="657" left="82" width="360" height="14" font="4">ment column information at the beginning. The algorithm</text>
<text top="675" left="82" width="360" height="14" font="4">has four steps: 1) obtaining all the non-duplicated Y-axis</text>
<text top="693" left="82" width="360" height="14" font="4">values of the sparse lines within an area; 2) sorting these</text>
<text top="711" left="82" width="360" height="14" font="4">Y-axis values from the top to the bottom; 3) ordering all the</text>
<text top="730" left="82" width="360" height="14" font="4">sparse lines in the area according to the sorted Y-axis val-</text>
<text top="748" left="82" width="360" height="14" font="4">ues; 4) exporting the sparse lines in the area orderly. For</text>
<text top="766" left="82" width="360" height="14" font="4">the <i>inside-table </i>text sequence error problem, the area is the</text>
<text top="784" left="82" width="360" height="14" font="4">table itself. For the <i>beyond-table text sequence error </i>prob-</text>
<text top="802" left="82" width="360" height="14" font="4">lem, this algorithm works better for the wide tables because</text>
<text top="821" left="82" width="360" height="14" font="4">the area refers to the whole page. All the sparse lines of</text>
<text top="839" left="82" width="360" height="14" font="4">cross-column tables will be exported out uninterruptedly.</text>
<text top="857" left="82" width="360" height="14" font="4">The high-risk case of this algorithm is the parallel tables.</text>
<text top="875" left="82" width="360" height="14" font="4">Parallel tables mean two tables that are located within two</text>
<text top="893" left="82" width="360" height="14" font="4">adjacent document columns and both tables have overlap</text>
<text top="912" left="82" width="360" height="14" font="4">Y-axis areas (see Figure 2a). Such cases happen very infre-</text>
<text top="930" left="82" width="360" height="14" font="4">quently. In addition, they can be ﬁxed easily by considering</text>
<text top="948" left="82" width="265" height="14" font="4">the width and the location of table captions.</text>
<text top="984" left="82" width="25" height="15" font="14">4.3</text>
<text top="984" left="125" width="316" height="15" font="14">Detecting the Table Boundary based</text>
<text top="1002" left="125" width="214" height="15" font="14">on the sorted sparse lines</text>
<text top="1030" left="100" width="342" height="14" font="4">With the sorted sparse lines, we detect the table boundary</text>
<text top="1048" left="82" width="360" height="14" font="4">by combining the table caption information. We deﬁne a</text>
<text top="1066" left="82" width="360" height="14" font="4">keyword list, which lists all the possible starting keywords</text>
<text top="112" left="485" width="332" height="14" font="16"><b>Algorithm 2</b>: Sorting sparse lines within a document</text>
<text top="130" left="485" width="46" height="14" font="4">column</text>
<text top="148" left="494" width="58" height="14" font="16"><b>Input</b>: V,</text>
<text top="144" left="556" width="9" height="20" font="4">V</text>
<text top="154" left="565" width="11" height="11" font="5">cc</text>
<text top="144" left="576" width="16" height="20" font="4">, V</text>
<text top="154" left="592" width="6" height="11" font="5">y</text>
<text top="144" left="599" width="16" height="20" font="4">, V</text>
<text top="154" left="615" width="34" height="11" font="5">sorted</text>
<text top="166" left="494" width="48" height="14" font="16"><b>foreach</b></text>
<text top="163" left="546" width="7" height="20" font="4">v</text>
<text top="172" left="553" width="6" height="11" font="5">k</text>
<text top="163" left="565" width="38" height="20" font="4">∈ CO</text>
<text top="172" left="603" width="6" height="11" font="5">k</text>
<text top="166" left="614" width="16" height="14" font="16"><b>do</b></text>
<text top="170" left="481" width="5" height="10" font="17"><b>1</b></text>
<text top="181" left="517" width="9" height="20" font="4">V</text>
<text top="190" left="526" width="6" height="11" font="5">y</text>
<text top="181" left="538" width="168" height="20" font="4">← all the Y-axis values in v</text>
<text top="190" left="706" width="6" height="11" font="5">k</text>
<text top="185" left="713" width="4" height="14" font="4">;</text>
<text top="188" left="481" width="5" height="10" font="17"><b>2</b></text>
<text top="199" left="517" width="9" height="20" font="4">V</text>
<text top="208" left="526" width="6" height="11" font="5">y</text>
<text top="199" left="538" width="226" height="20" font="4">← all the non-duplicated objects in V</text>
<text top="208" left="764" width="6" height="11" font="5">y</text>
<text top="203" left="771" width="4" height="14" font="4">;</text>
<text top="206" left="481" width="5" height="10" font="17"><b>3</b></text>
<text top="217" left="517" width="9" height="20" font="4">V</text>
<text top="226" left="526" width="6" height="11" font="5">y</text>
<text top="217" left="538" width="25" height="20" font="4">= V</text>
<text top="226" left="563" width="6" height="11" font="5">y</text>
<text top="217" left="573" width="24" height="20" font="4">− V</text>
<text top="226" left="597" width="11" height="11" font="5">cc</text>
<text top="221" left="609" width="4" height="14" font="4">;</text>
<text top="224" left="481" width="5" height="10" font="17"><b>4</b></text>
<text top="239" left="517" width="42" height="14" font="4">sorted(</text>
<text top="235" left="559" width="9" height="20" font="4">V</text>
<text top="245" left="568" width="6" height="11" font="5">y</text>
<text top="239" left="576" width="86" height="14" font="4">) ascendingly;</text>
<text top="242" left="481" width="5" height="10" font="17"><b>5</b></text>
<text top="257" left="517" width="48" height="14" font="16"><b>foreach</b></text>
<text top="254" left="569" width="9" height="20" font="4">Y</text>
<text top="263" left="578" width="6" height="11" font="5">q</text>
<text top="254" left="589" width="23" height="20" font="4">∈ V</text>
<text top="263" left="612" width="6" height="11" font="5">y</text>
<text top="257" left="623" width="16" height="14" font="16"><b>do</b></text>
<text top="261" left="481" width="5" height="10" font="17"><b>6</b></text>
<text top="276" left="541" width="48" height="14" font="16"><b>foreach</b></text>
<text top="272" left="593" width="12" height="20" font="4">sl</text>
<text top="281" left="604" width="4" height="11" font="5">i</text>
<text top="272" left="614" width="23" height="20" font="4">∈ V</text>
<text top="281" left="637" width="6" height="11" font="5">k</text>
<text top="276" left="648" width="16" height="14" font="16"><b>do</b></text>
<text top="279" left="481" width="5" height="10" font="17"><b>7</b></text>
<text top="294" left="564" width="9" height="14" font="16"><b>if</b></text>
<text top="290" left="577" width="9" height="20" font="4">Y</text>
<text top="299" left="586" width="10" height="11" font="5">sl</text>
<text top="301" left="596" width="4" height="10" font="15">i</text>
<text top="294" left="605" width="20" height="14" font="3"><i>==</i></text>
<text top="290" left="629" width="9" height="20" font="4">Y</text>
<text top="299" left="638" width="6" height="11" font="5">q</text>
<text top="294" left="648" width="29" height="14" font="16"><b>then</b></text>
<text top="297" left="481" width="5" height="10" font="17"><b>8</b></text>
<text top="308" left="587" width="9" height="20" font="4">V</text>
<text top="317" left="596" width="34" height="11" font="5">sorted</text>
<text top="312" left="635" width="17" height="14" font="4">+=</text>
<text top="308" left="656" width="12" height="20" font="4">sl</text>
<text top="317" left="668" width="4" height="11" font="5">i</text>
<text top="312" left="673" width="4" height="14" font="4">;</text>
<text top="315" left="481" width="5" height="10" font="17"><b>9</b></text>
<text top="326" left="587" width="9" height="20" font="4">V</text>
<text top="336" left="596" width="6" height="11" font="5">k</text>
<text top="330" left="608" width="14" height="14" font="4">-=</text>
<text top="326" left="625" width="12" height="20" font="4">sl</text>
<text top="336" left="637" width="4" height="11" font="5">i</text>
<text top="330" left="642" width="4" height="14" font="4">;</text>
<text top="333" left="476" width="11" height="10" font="17"><b>10</b></text>
<text top="372" left="494" width="71" height="14" font="4">sort lines in</text>
<text top="368" left="569" width="9" height="20" font="4">V</text>
<text top="377" left="577" width="11" height="11" font="5">cc</text>
<text top="372" left="593" width="122" height="14" font="4">according to Y-axis;</text>
<text top="375" left="476" width="11" height="10" font="17"><b>11</b></text>
<text top="390" left="494" width="34" height="14" font="4">insert</text>
<text top="386" left="531" width="9" height="20" font="4">V</text>
<text top="395" left="540" width="11" height="11" font="5">cc</text>
<text top="390" left="556" width="24" height="14" font="4">into</text>
<text top="386" left="583" width="9" height="20" font="4">V</text>
<text top="395" left="592" width="34" height="11" font="5">sorted</text>
<text top="390" left="631" width="122" height="14" font="4">according to Y-axis;</text>
<text top="393" left="476" width="11" height="10" font="17"><b>12</b></text>
<text top="457" left="476" width="360" height="14" font="4">of table captions, such as “Table, TABLE, Form, FORM,”</text>
<text top="475" left="476" width="360" height="14" font="4">etc. Each table caption starts with a keyword. If more than</text>
<text top="494" left="476" width="360" height="14" font="4">one table is displayed together, the keyword is very useful</text>
<text top="512" left="476" width="360" height="14" font="4">to separate the tables from each other. At the beginning, we</text>
<text top="530" left="476" width="360" height="14" font="4">check all the lines (not only the sparse line) in a page. Once</text>
<text top="548" left="476" width="360" height="14" font="4">we detect a line starting with a keyword, we treat it as a table</text>
<text top="566" left="476" width="360" height="14" font="4">caption candidate. Then we check the subsequent sorted</text>
<text top="585" left="476" width="360" height="14" font="4">sparse lines and merge them into a sparse area, according</text>
<text top="603" left="476" width="360" height="14" font="4">to the vertical distance between the lines. Different table</text>
<text top="621" left="476" width="360" height="14" font="4">captions provide different hints and restraints on whether</text>
<text top="639" left="476" width="292" height="14" font="4">we include the cross-column sparse lines or not.</text>
<text top="661" left="494" width="342" height="14" font="4">If a table caption starts in the second document column</text>
<text top="680" left="476" width="360" height="14" font="4">(e.g., the right table in Figure 2a), the table boundary can</text>
<text top="698" left="476" width="360" height="14" font="4">not span the ﬁrst column. If a table caption satisﬁes one of</text>
<text top="716" left="476" width="360" height="14" font="4">the following conditions, it is a cross-column table: 1) the</text>
<text top="734" left="476" width="360" height="14" font="4">width of the table caption is larger than the document col-</text>
<text top="753" left="476" width="360" height="14" font="4">umn width; 2) the starting X-axis value of the caption is on</text>
<text top="771" left="476" width="360" height="14" font="4">the right of the midpoint of the ﬁrst document column. Once</text>
<text top="789" left="476" width="360" height="14" font="4">we conﬁrm a table as a cross-column table, we treat each Y-</text>
<text top="807" left="476" width="360" height="14" font="4">axis value as a table row. Otherwise, every table row can</text>
<text top="825" left="476" width="360" height="14" font="4">only include the sparse lines within the current document</text>
<text top="844" left="476" width="360" height="14" font="4">column. Because we will zoom in and analyze the detected</text>
<text top="862" left="476" width="360" height="14" font="4">table boundary carefully in the later table structure decom-</text>
<text top="880" left="476" width="360" height="14" font="4">position phase, we treat <i>recall </i>more importantly than <i>preci-</i></text>
<text top="898" left="476" width="342" height="14" font="3"><i>sion </i>by accepting false positive table boundary contents.</text>
<text top="920" left="494" width="342" height="14" font="4">If a table caption is shorter than the document column</text>
<text top="939" left="476" width="360" height="14" font="4">width, and its beginning position aligns with that of the ﬁrst</text>
<text top="957" left="476" width="360" height="14" font="4">document column (see the table caption in Figure 1), it is</text>
<text top="975" left="476" width="360" height="14" font="4">difﬁcult to judge whether this table a cross-column table or</text>
<text top="993" left="476" width="360" height="14" font="4">not. For such a case, we assume it as a single-column table</text>
<text top="1011" left="476" width="360" height="14" font="4">initially, after ﬁgure out the document column where the</text>
<text top="1030" left="476" width="360" height="14" font="4">caption belongs to, we check the same Y-axis area in the</text>
<text top="1048" left="476" width="360" height="14" font="4">next document column. If this area is also a sparse area, we</text>
<text top="1066" left="476" width="360" height="14" font="4">merge the new area into the table boundary and treat this</text>
<text top="1112" left="447" width="24" height="11" font="7">1009</text>
<text top="1175" left="107" width="555" height="8" font="8">Authorized licensed use limited to: Penn State University. Downloaded on February 9, 2010 at 16:37 from IEEE Xplore.  Restrictions apply. </text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="18" size="11" family="Times" color="#000000"/>
	<fontspec id="19" size="11" family="Times" color="#000000"/>
<text top="108" left="83" width="358" height="14" font="4">table as a cross-column table. Once we ﬁnd a new table</text>
<text top="126" left="83" width="358" height="14" font="4">caption in the new area, it indicates the existing of parallel</text>
<text top="144" left="83" width="39" height="14" font="4">tables.</text>
<text top="185" left="83" width="9" height="16" font="2"><b>5</b></text>
<text top="185" left="110" width="193" height="16" font="2"><b>Experiments and Results</b></text>
<text top="205" left="101" width="340" height="14" font="4">Our experiments can be divided into two parts: the eval-</text>
<text top="223" left="83" width="358" height="14" font="4">uation of the text sequence recovering and the table bound-</text>
<text top="241" left="83" width="358" height="14" font="4">ary detection. A ﬁve-user study is implemented. Each user</text>
<text top="259" left="83" width="358" height="14" font="4">checked the sequence of the resorted sparse lines in 20 se-</text>
<text top="277" left="83" width="358" height="14" font="4">lected PDF pages. Half of them have within-table sequence</text>
<text top="295" left="83" width="358" height="14" font="4">errors and the other half have beyond-table sequence errors.</text>
<text top="313" left="83" width="291" height="14" font="4">The evaluation metric is <i>pairwise accuracy</i>. If</text>
<text top="310" left="380" width="13" height="20" font="4">H</text>
<text top="319" left="392" width="9" height="11" font="5">R</text>
<text top="313" left="408" width="34" height="14" font="4">is the</text>
<text top="331" left="83" width="270" height="14" font="4">sequence decided by human judgement and</text>
<text top="328" left="359" width="11" height="20" font="4">A</text>
<text top="337" left="370" width="9" height="11" font="5">R</text>
<text top="331" left="385" width="57" height="14" font="4">is the se-</text>
<text top="350" left="83" width="358" height="14" font="4">quence decided by the algorithms, the <i>pairwise accuracy</i></text>
<text top="368" left="83" width="358" height="14" font="4">can be deﬁned as the fraction of times that our algorithms</text>
<text top="386" left="83" width="358" height="14" font="4">and human judges agree on the sequence: <i>pairwise accu-</i></text>
<text top="406" left="83" width="41" height="14" font="3"><i>racy =</i></text>
<text top="399" left="131" width="13" height="14" font="5">|H</text>
<text top="403" left="144" width="8" height="10" font="15">R</text>
<text top="399" left="153" width="17" height="14" font="5">∩A</text>
<text top="403" left="170" width="8" height="10" font="15">R</text>
<text top="399" left="179" width="4" height="14" font="5">|</text>
<text top="414" left="147" width="10" height="11" font="5">H</text>
<text top="416" left="157" width="8" height="10" font="15">R</text>
<text top="406" left="184" width="257" height="14" font="4">. For algorithm 1, the correct sequence of</text>
<text top="424" left="83" width="358" height="14" font="4">human judge is column by column. For algorithm 2, hu-</text>
<text top="442" left="83" width="358" height="14" font="4">mans treat each page as a single-column page. Comparing</text>
<text top="460" left="83" width="358" height="14" font="4">such “<i>golden standard</i>”, the <i>pairwise accuracy </i>of both al-</text>
<text top="478" left="83" width="358" height="14" font="4">gorithms are 100%. Still using the Figure 3a as the example,</text>
<text top="497" left="83" width="143" height="14" font="4">with our algorithms, the</text>
<text top="493" left="230" width="212" height="20" font="4">13 non-duplicated Y-axis values af-</text>
<text top="515" left="83" width="358" height="14" font="4">ter the sorting step are: <i>625.47974, 643.07983, 651.9796,</i></text>
<text top="533" left="83" width="358" height="14" font="3"><i>660.68005, 669.5801, 681.4798, 690.27966, 699.0797,</i></text>
<text top="551" left="83" width="358" height="14" font="3"><i>707.7796, 716.3797, 725.1799, 734.0797, 744.37976</i>. Be-</text>
<text top="569" left="83" width="358" height="14" font="4">cause the text sequence error always starts with the left</text>
<text top="587" left="83" width="358" height="14" font="4">columns ﬁrst, we do not need to sort the text pieces with</text>
<text top="605" left="83" width="358" height="14" font="4">the same Y-axis values according to the X-axis coordi-</text>
<text top="624" left="83" width="358" height="14" font="4">nate. After the sorting, the new sequence of these sparse</text>
<text top="642" left="83" width="358" height="14" font="4">lines are: <i>“Content (% m/m)”, “Proposed method”, “Refer-</i></text>
<text top="660" left="83" width="358" height="14" font="3"><i>ence”, “Peak Peak Flame value”, “Sample Element height</i></text>
<text top="678" left="83" width="358" height="14" font="3"><i>area AAS (%m/m)”, “Low melt Ag 43.9 44.1 45.1 44.46”,</i></text>
<text top="696" left="83" width="358" height="14" font="3"><i>“0.5 2.4 1.1”, “Cu 15.6 15.2 15.3 14-16”, “2.7 1.8 2.5”,</i></text>
<text top="714" left="83" width="225" height="14" font="3"><i>“Sample No.318+ Ag 25.7 25.2 25.7</i></text>
<text top="710" left="312" width="129" height="20" font="4">≈<i>25”, “2.1 2.1 1.4”,</i></text>
<text top="732" left="83" width="117" height="14" font="3"><i>“Cu 34.4 33.7 34.8</i></text>
<text top="729" left="204" width="128" height="20" font="4">≈<i>35”, “2.3 1.3 2.5”.</i></text>
<text top="751" left="101" width="340" height="14" font="4">The evaluation metrics for the table boundary detection</text>
<text top="769" left="83" width="78" height="14" font="4">are precision</text>
<text top="765" left="166" width="276" height="20" font="4">P and recall R. Given the number of true ta-</text>
<text top="787" left="83" width="246" height="14" font="4">ble lines in our detected table boundary</text>
<text top="783" left="334" width="108" height="20" font="4">A, the number of</text>
<text top="805" left="83" width="217" height="14" font="4">overlooked true positive table lines</text>
<text top="801" left="305" width="136" height="20" font="4">B, and the number of</text>
<text top="823" left="83" width="254" height="14" font="4">misidentiﬁed true negative non-table lines</text>
<text top="819" left="341" width="40" height="20" font="4">C, P =</text>
<text top="820" left="392" width="9" height="11" font="5">A</text>
<text top="831" left="382" width="27" height="11" font="5">A+C</text>
<text top="823" left="412" width="29" height="14" font="4">, and</text>
<text top="840" left="83" width="20" height="20" font="4">R=</text>
<text top="841" left="115" width="9" height="11" font="5">A</text>
<text top="853" left="105" width="28" height="11" font="5">A+B</text>
<text top="844" left="135" width="307" height="14" font="4">. The performance of two algorithms are listed in</text>
<text top="862" left="83" width="146" height="14" font="4">Table 1. The reason for</text>
<text top="859" left="233" width="208" height="20" font="4">C are some non-table sparse lines</text>
<text top="881" left="83" width="358" height="14" font="4">surrounding the table boundary. They usually also belong</text>
<text top="899" left="83" width="358" height="14" font="4">to the table data.(e.g., the short lines of the table caption</text>
<text top="917" left="83" width="358" height="14" font="4">and footnote). For single-column tables, Algorithm 2 may</text>
<text top="935" left="83" width="63" height="14" font="4">have more</text>
<text top="931" left="150" width="291" height="20" font="4">C because of the possible sparse lines with sim-</text>
<text top="953" left="83" width="358" height="14" font="4">ilar Y-axis values in the next document column. Because</text>
<text top="971" left="83" width="358" height="14" font="4">the widths of cells in single-column table can not be large</text>
<text top="989" left="83" width="358" height="14" font="4">and the noise lines in table boundary can be easily removed</text>
<text top="1007" left="83" width="358" height="14" font="4">in later table structure decomposition step, we prefer high</text>
<text top="1026" left="83" width="358" height="14" font="4">recall values. For cross-column tables, algorithm 1 will cut</text>
<text top="1044" left="83" width="358" height="14" font="4">each table into at least two parts. A merge postprocessing is</text>
<text top="1062" left="83" width="358" height="14" font="4">required. Algorithm 2 achieves better performance on such</text>
<text top="108" left="476" width="358" height="14" font="4">tables. In summary, in the real application when we can</text>
<text top="126" left="476" width="358" height="14" font="4">not know the table type in advance, algorithm 2 works bet-</text>
<text top="144" left="476" width="358" height="14" font="4">ter than algorithm 1. For tables with within-table sequence</text>
<text top="162" left="476" width="358" height="14" font="4">errors, our recovering algorithms do not fulﬁll much per-</text>
<text top="180" left="476" width="197" height="14" font="4">formance improvement on both</text>
<text top="177" left="678" width="156" height="20" font="4">P and R because all the</text>
<text top="198" left="476" width="358" height="14" font="4">lines belong to the table boundary come together without</text>
<text top="217" left="476" width="358" height="14" font="4">interruption. However, for the tables with beyond-table se-</text>
<text top="235" left="476" width="358" height="14" font="4">quence errors, the performance is much worse without our</text>
<text top="253" left="476" width="252" height="14" font="4">algorithms: with the same test PDFs, the</text>
<text top="249" left="732" width="102" height="20" font="4">R is only 63.5%</text>
<text top="271" left="476" width="358" height="14" font="4">without our algorithms because a table will be segmented</text>
<text top="289" left="476" width="358" height="14" font="4">into several parts and some of them are ﬁltered out because</text>
<text top="307" left="476" width="113" height="14" font="4">of the small scope.</text>
<text top="338" left="494" width="322" height="14" font="16"><b>Table 1. The performance evaluation of two</b></text>
<text top="356" left="494" width="252" height="14" font="16"><b>text sequence resorting algorithms</b></text>
<text top="389" left="592" width="39" height="10" font="5">Algo1(P)</text>
<text top="389" left="650" width="41" height="10" font="5">Algo1(R)</text>
<text top="389" left="709" width="39" height="10" font="5">Algo2(P)</text>
<text top="389" left="766" width="41" height="10" font="5">Algo2(R)</text>
<text top="402" left="485" width="87" height="10" font="5">Cross-column tables</text>
<text top="402" left="598" width="27" height="10" font="5">95.7%</text>
<text top="402" left="657" width="27" height="10" font="5">49.8%</text>
<text top="402" left="716" width="25" height="10" font="5">100%</text>
<text top="402" left="766" width="27" height="10" font="5">99.6%</text>
<text top="414" left="485" width="90" height="10" font="5">Single-column tables</text>
<text top="414" left="602" width="19" height="10" font="5">96%</text>
<text top="414" left="657" width="27" height="10" font="5">94.8%</text>
<text top="414" left="715" width="27" height="10" font="5">94.5%</text>
<text top="414" left="766" width="27" height="10" font="5">99.8%</text>
<text top="448" left="476" width="9" height="16" font="2"><b>6</b></text>
<text top="448" left="503" width="87" height="16" font="2"><b>Conclusion</b></text>
<text top="467" left="494" width="340" height="14" font="4">In this paper, we analyze a typical problem shared by the</text>
<text top="485" left="476" width="358" height="14" font="4">PDF text extraction tools: the text sequence error. We pro-</text>
<text top="503" left="476" width="358" height="14" font="4">pose two algorithms to recover the sequence of extracted</text>
<text top="522" left="476" width="358" height="14" font="4">sparse lines, which improve the table content collection.</text>
<text top="540" left="476" width="358" height="14" font="4">The experimental results not only compare the performance</text>
<text top="558" left="476" width="358" height="14" font="4">of both algorithms, but also demonstrate the effectiveness of</text>
<text top="576" left="476" width="358" height="14" font="4">text sequence recovering for the table boundary detection.</text>
<text top="594" left="476" width="358" height="14" font="4">The results show that the second algorithm achieves better</text>
<text top="612" left="476" width="358" height="14" font="4">results for both single-column table and cross-column table.</text>
<text top="630" left="476" width="358" height="14" font="4">It is proved that the text sequence recovering work plays a</text>
<text top="648" left="476" width="294" height="14" font="4">crucial role in the table boundary detection ﬁeld.</text>
<text top="688" left="476" width="84" height="16" font="2"><b>References</b></text>
<text top="729" left="476" width="358" height="12" font="18">[1] R. Cattoni, T. Coianiz, S. Messelodi, and C. Modena. Geo-</text>
<text top="746" left="496" width="338" height="12" font="18">metric layout analyis techniques for document image under-</text>
<text top="762" left="496" width="308" height="12" font="18">standing: a review. <i>ITC-IRST Technical Report 9703-09.</i></text>
<text top="780" left="476" width="358" height="12" font="18">[2] H. Chao and J. Fan. Layout and content extraction for pdf</text>
<text top="797" left="496" width="246" height="12" font="18">documents. In <i>DAS04</i>, pages 213–224, 2004.</text>
<text top="814" left="476" width="358" height="12" font="18">[3] Y. Liu, P. Mitra, and C. L. Giles. A fast preprocessing method</text>
<text top="831" left="496" width="338" height="12" font="18">for table boundary detection: Narrowing down the sparse lines</text>
<text top="847" left="496" width="279" height="12" font="18">using solely coordinate information. In <i>DAS</i>, 2008.</text>
<text top="865" left="476" width="358" height="12" font="18">[4] Y. Liu, P. Mitra, and C. L. Giles. Identifying table boundaries</text>
<text top="882" left="496" width="338" height="12" font="18">in digital documents via sparse line detection. In <i>CIKM</i>, pages</text>
<text top="898" left="496" width="99" height="12" font="18">1311–1320, 2008.</text>
<text top="916" left="476" width="358" height="12" font="18">[5] X. Wang. Tabular abstraction, editing, and formatting. In</text>
<text top="933" left="496" width="338" height="12" font="19"><i>Ph.D. Thesis, Dept. of Computer Science, University of Water-</i></text>
<text top="949" left="496" width="55" height="12" font="19"><i>loo</i>, 1996.</text>
<text top="967" left="476" width="358" height="12" font="18">[6] Y. Wang and J. Hu. Detecting tables in html documents. In</text>
<text top="984" left="496" width="338" height="12" font="19"><i>In Proc. of the 5th IAPR Int’l Workshop on Document Analysis</i></text>
<text top="1000" left="496" width="163" height="12" font="19"><i>Systems, Princeton, NJ</i>, 2002.</text>
<text top="1018" left="476" width="358" height="12" font="18">[7] B. Yildiz, K. Kaiser, and S. Miksch. pdf2table: A method to</text>
<text top="1035" left="496" width="338" height="12" font="18">extract table information from pdf ﬁles. In <i>Proceedings of the</i></text>
<text top="1051" left="496" width="338" height="12" font="19"><i>2nd Indian International Conference on Artiﬁcial Intelligence</i></text>
<text top="1068" left="496" width="161" height="12" font="19"><i>(IICAI05), Pune, India, 2005</i>.</text>
<text top="1112" left="447" width="24" height="11" font="7">1010</text>
<text top="1175" left="107" width="555" height="8" font="8">Authorized licensed use limited to: Penn State University. Downloaded on February 9, 2010 at 16:37 from IEEE Xplore.  Restrictions apply. </text>
</page>
</pdf2xml>
