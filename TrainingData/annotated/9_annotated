=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="0" height="23" left="155" textpieces="0" top="172" width="608">Probabilistic Management of OCR Data using an RDBMS</text>
2 <text font="1" height="16" left="260" textpieces="0" top="223" width="99">Arun Kumar</text>
2 <text font="1" height="16" left="183" textpieces="0" top="244" width="253">University of Wisconsin-Madison</text>
2 <text font="1" height="16" left="243" textpieces="0" top="265" width="133">arun@cs.wisc.edu</text>
2 <text font="1" height="16" left="550" textpieces="1" top="223" width="118">Christopher R e</text>
2 <text font="1" height="16" left="482" textpieces="0" top="244" width="253">University of Wisconsin-Madison</text>
2 <text font="1" height="16" left="535" textpieces="0" top="265" width="148">chrisre@cs.wisc.edu</text>
2 <text font="1" height="16" left="398" textpieces="0" top="301" width="122">January 5, 2012</text>
2 <text font="2" height="13" left="426" textpieces="0" top="360" width="66">Abstract</text>
2 <text font="2" height="13" left="171" textpieces="0" top="384" width="598">The digitization of scanned forms and documents is changing the data sources that enterprises</text>
2 <text font="2" height="13" left="149" textpieces="0" top="402" width="620">manage. To integrate these new data sources with enterprise data, the current state-of-the-art</text>
2 <text font="2" height="13" left="149" textpieces="0" top="420" width="620">approach is to convert the images to ASCII text using optical character recognition (OCR)</text>
2 <text font="2" height="13" left="149" textpieces="0" top="438" width="620">software and then to store the resulting ASCII text in a relational database. The OCR problem</text>
2 <text font="2" height="13" left="149" textpieces="0" top="456" width="620">is challenging, and so the output of OCR often contains errors. In turn, queries on the output</text>
2 <text font="2" height="13" left="149" textpieces="0" top="474" width="620">of OCR may fail to retrieve relevant answers. State-of-the-art OCR programs, e.g., the OCR</text>
2 <text font="2" height="13" left="149" textpieces="0" top="492" width="620">powering Google Books, use a probabilistic model that captures many alternatives during the</text>
2 <text font="2" height="13" left="149" textpieces="0" top="510" width="620">OCR process. Only when the results of OCR are stored in the database, do these approaches</text>
2 <text font="2" height="13" left="149" textpieces="0" top="528" width="620">discard the uncertainty. In this work, we propose to retain the probabilistic models produced</text>
2 <text font="2" height="13" left="149" textpieces="0" top="546" width="620">by OCR process in a relational database management system. A key technical challenge is</text>
2 <text font="2" height="13" left="149" textpieces="0" top="564" width="620">that the probabilistic data produced by OCR software is very large (a single book blows up to</text>
2 <text font="2" height="13" left="149" textpieces="0" top="581" width="620">2GB from 400kB as ASCII). As a result, a baseline solution that integrates these models with</text>
2 <text font="2" height="13" left="149" textpieces="0" top="599" width="620">an RDBMS is over 1000x slower versus standard text processing for single table select-project</text>
2 <text font="2" height="13" left="149" textpieces="0" top="617" width="620">queries. However, many applications may have quality-performance needs that are in between</text>
2 <text font="2" height="13" left="149" textpieces="0" top="635" width="620">these two extremes of ASCII and the complete model output by the OCR software. Thus, we</text>
2 <text font="2" height="16" left="149" textpieces="0" top="653" width="620">propose a novel approximation scheme called Staccato that allows a user to trade recall for</text>
2 <text font="2" height="13" left="149" textpieces="0" top="671" width="620">query performance. Additionally, we provide a formal analysis of our schemes properties, and</text>
2 <text font="2" height="13" left="149" textpieces="0" top="689" width="498">describe how we integrate our scheme with standard-RDBMS text indexing.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="736" width="169">1  Introduction</text>
2 <text font="4" height="15" left="108" textpieces="0" top="776" width="702">The mass digitization of books, printed documents, and printed forms is changing the types of data</text>
2 <text font="4" height="15" left="108" textpieces="0" top="796" width="702">that companies and academics manage. For example, Google Books and their academic partner,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="816" width="702">the Hathi Trust, have the goal of digitizing all of the worlds books to allow scholars to search</text>
2 <text font="4" height="15" left="108" textpieces="0" top="837" width="702">human knowledge from the pre-Web era. The hope of this eort is that digital access to this data</text>
2 <text font="4" height="15" left="108" textpieces="1" top="857" width="702">will enable scholars to rapidly mine these vast stores of text for new discoveries.1 The potential</text>
2 <text font="4" height="15" left="108" textpieces="0" top="877" width="702">users of this new content are not limited to academics. The market for enterprise document capture</text>
2 <text font="4" height="15" left="108" textpieces="0" top="898" width="702">(scanning of forms) is already in the multibillion dollar range [3]. In many of the applications, the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="918" width="702">translated data is related to enterprise business data, and so after converting to plain text, the data</text>
2 <text font="4" height="15" left="108" textpieces="0" top="938" width="206">are stored in an RDBMS [6].</text>
2 <text font="4" height="15" left="133" textpieces="0" top="959" width="677">Translating an image of text (e.g., a jpeg) to ASCII is dicult for machines to do automatically.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="979" width="702">To cope with the huge number of variations in scanned documents, e.g., in spacing of the glyphs</text>
2 <text font="6" height="8" left="127" textpieces="0" top="1007" width="682">1Many repositories of Digging into Data Challenge (a large joint eort to bring together social scientists with data</text>
2 <text font="7" height="12" left="108" textpieces="0" top="1026" width="370">analysis) are OCR-based http://www.diggingintodata.org.</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">1</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">and font faces, state-of-the-art approaches for optical character recognition (OCR) use probabilistic</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">techniques. For example, the OCRopus tool from Google Books represents the output of the OCR</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">process as a stochastic automaton called a nite-state transducer (FST) that denes a probability</text>
2 <text font="4" height="15" left="108" textpieces="1" top="174" width="702">distribution over all possible strings that could be represented in the image.2 An example image</text>
2 <text font="4" height="15" left="108" textpieces="0" top="194" width="702">and its resulting (simplied) transducer are shown in Figure 1. Each labeled path through the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">transducer corresponds to a potential string (one multiplies the weights along the path to get the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="235" width="702">probability of the string). Only to produce the nal plain text do current OCR approaches remove</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="702">the uncertainty. Traditionally, they choose to retain only the single most likely string produced by</text>
2 <text font="4" height="15" left="108" textpieces="0" top="276" width="425">the FST (called a maximum a priori estimate or MAP [1]).</text>
2 <text font="8" height="6" left="145" textpieces="1" top="412" width="331">                                                                                                                                                                                                                             </text>
2 <text font="9" height="18" left="535" textpieces="0" top="318" width="9">3</text>
2 <text font="9" height="18" left="332" textpieces="2" top="361" width="303">0        1                                  5</text>
2 <text font="9" height="18" left="535" textpieces="0" top="394" width="9">4</text>
2 <text font="10" height="15" left="349" textpieces="0" top="332" width="35">F: 0.8</text>
2 <text font="9" height="18" left="456" textpieces="0" top="361" width="9">2</text>
2 <text font="10" height="15" left="347" textpieces="0" top="393" width="33">T: 0.2</text>
2 <text font="10" height="15" left="413" textpieces="0" top="332" width="34">0: 0.6</text>
2 <text font="10" height="15" left="409" textpieces="0" top="393" width="35">o: 0.4</text>
2 <text font="10" height="15" left="474" textpieces="0" top="329" width="37">' ': 0.6</text>
2 <text font="10" height="15" left="504" textpieces="0" top="360" width="32">r: 0.8</text>
2 <text font="10" height="15" left="474" textpieces="0" top="395" width="32">r: 0.4</text>
2 <text font="10" height="15" left="572" textpieces="0" top="327" width="38">m: 0.2</text>
2 <text font="10" height="15" left="560" textpieces="0" top="370" width="35">d: 0.9</text>
2 <text font="10" height="15" left="574" textpieces="0" top="403" width="34">3: 0.1</text>
2 <text font="10" height="17" left="663" textpieces="0" top="330" width="144">SELECT DocId, Loss</text>
2 <text font="10" height="17" left="663" textpieces="0" top="348" width="88">FROM Claims</text>
2 <text font="10" height="17" left="663" textpieces="0" top="365" width="168">WHERE Year = 2010 AND</text>
2 <text font="10" height="17" left="663" textpieces="0" top="382" width="176">DocData LIKE '%Ford%';</text>
2 <text font="11" height="13" left="303" textpieces="2" top="409" width="536">A                                                                          B                                       C</text>
2 <text font="12" height="13" left="289" textpieces="0" top="320" width="10">...</text>
2 <text font="12" height="13" left="271" textpieces="0" top="336" width="10">...</text>
2 <text font="12" height="13" left="265" textpieces="0" top="350" width="10">...</text>
2 <text font="12" height="13" left="281" textpieces="0" top="366" width="10">...</text>
2 <text font="12" height="13" left="287" textpieces="0" top="382" width="10">...</text>
2 <text font="12" height="13" left="281" textpieces="0" top="396" width="10">...</text>
2 <text font="4" height="15" left="108" textpieces="0" top="446" width="702">Figure 1: (A) An image of text. (B) A portion of a simple FST resulting from the OCR of the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="466" width="702">highlighted part of (A). The numbers on the arcs are conditional probabilities of transitioning from</text>
2 <text font="4" height="15" left="108" textpieces="0" top="486" width="702">one state to another. An emitted string corresponds to a path from states 0 to 5. The string F0 rd</text>
2 <text font="4" height="15" left="108" textpieces="0" top="507" width="702">(highlighted path) has the highest probability, 0.8  0.6  0.6  0.8  0.9  0.21. (C) An SQL query to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="527" width="702">retrieve loss information that contains Ford. Using the MAP approach, no claim is found. Using</text>
2 <text font="4" height="14" left="108" textpieces="0" top="550" width="374">Staccato, a claim is found (with probability 0.12).</text>
2 <text font="4" height="15" left="133" textpieces="0" top="571" width="677">As Google Books demonstrates, the MAP works well for browsing applications. In such appli-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="591" width="702">cations, one is sensitive to precision (i.e., are the answers I see correct), but one is insensitive to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="611" width="702">recall (i.e., what fraction of all of the answers in my corpus are returned). But this is not true of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="632" width="702">all applications: an English professor looking for the earliest dates that a word occurs in a corpus</text>
2 <text font="4" height="15" left="108" textpieces="0" top="652" width="702">is sensitive to recall [5]. As is an insurance company that wants all insurance claims that were</text>
2 <text font="4" height="15" left="108" textpieces="0" top="672" width="702">lled in 2010 that mentioned a Ford. This latter query is expressed in SQL in Figure 1(C). In this</text>
2 <text font="4" height="15" left="108" textpieces="0" top="692" width="702">work, we focus on such single table select-project queries, whose outputs are standard probabilistic</text>
2 <text font="4" height="15" left="108" textpieces="0" top="713" width="702">RDBMS tables. Using the MAP approach may miss valuable answers. In the example in Figure 1,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="733" width="702">the most likely string does not contain Ford, and so we (erroneously) miss this claim. However,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="753" width="702">the string Ford does appear (albeit with a lower probability). Empirically, we show that the recall</text>
2 <text font="4" height="15" left="108" textpieces="0" top="774" width="702">for simple queries on real-world OCR can be as low as 0.3  and so we may throw away almost</text>
2 <text font="4" height="15" left="108" textpieces="0" top="794" width="348">70% of our data if we follow the MAP approach.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="814" width="677">To remedy this recall problem, our baseline approach is to store and handle the FSTs as binary</text>
2 <text font="4" height="15" left="108" textpieces="0" top="835" width="702">large objects inside the RDBMS. As with a probabilistic relational database, the user can then</text>
2 <text font="4" height="15" left="108" textpieces="0" top="855" width="702">pose questions as if the data are deterministic and it is the job of the system to compute the</text>
2 <text font="4" height="15" left="108" textpieces="1" top="875" width="701">condence in its answer. By combining existing open-source tools for transducer composition 3</text>
2 <text font="4" height="15" left="108" textpieces="0" top="896" width="702">with an RDBMS, we can then answer queries like that in Figure 1(C). This approach achieves a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="916" width="702">high quality (empirically, the recall we measured is very close to 1.0, with up to 0.9 precision).</text>
2 <text font="4" height="15" left="108" textpieces="0" top="936" width="702">Additionally, the enterprise users can ask their existing queries directly on top of the RDBMS data</text>
2 <text font="4" height="15" left="108" textpieces="0" top="957" width="702">(the query in Figure 1(C) remains unchanged). The downside is that query processing is much</text>
2 <text font="4" height="15" left="108" textpieces="0" top="977" width="702">slower (up to 1000x slower). While the query processing time for transducers is linear in the data</text>
2 <text font="6" height="8" left="127" textpieces="0" top="1007" width="242">2http://code.google.com/p/ocropus/.</text>
2 <text font="6" height="8" left="127" textpieces="0" top="1023" width="235">3OpenFST. http://www.openfst.org/</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">2</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">size, the transducers themselves are huge, e.g., a single 200-page book blows up from 400 kB as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">text to over 2 GB when represented by transducers after OCR. This motivates our central question:</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">Can we devise an approximation scheme that is somewhere in between these two extremes of recall</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="136">and performance?</text>
2 <text font="4" height="15" left="133" textpieces="0" top="194" width="677">State-of-the-art OCR tools segment each of the images corresponding to pages in a document</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">into lines using special purpose line-breaking tools. Breaking a single line further into individual</text>
2 <text font="4" height="15" left="108" textpieces="0" top="235" width="702">words is more dicult (spacing is very dicult to accurately detect). With this in mind, a natural</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="702">idea to improve the recall of the MAP approach is to retain not only the highest probability string</text>
2 <text font="4" height="15" left="108" textpieces="0" top="276" width="702">for each line, but instead to retain the k highest probability strings that appear in each line (called</text>
2 <text font="4" height="15" left="108" textpieces="0" top="296" width="702">k-MAP [30, 56]). Indeed, this technique keeps more information around at a linear cost (in k)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="316" width="702">in space and processing time. However, we show that even storing hundreds of paths makes an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="337" width="298">insignicant jump in the recall of queries.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="357" width="677">To combat this problem, we propose a novel approximation scheme called Staccato, which</text>
2 <text font="4" height="15" left="108" textpieces="0" top="377" width="702">is our main technical contribution. The main idea is to apply k-MAP not to the whole line, but</text>
2 <text font="4" height="15" left="108" textpieces="0" top="398" width="702">to rst break the line into smaller chunks which are themselves transducers and apply k-MAP to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="418" width="702">each transducer individually. This allows us to store exponentially more alternatives than k-MAP</text>
2 <text font="4" height="15" left="108" textpieces="0" top="438" width="702">(exponential in the number of chunks), while using roughly a linear amount more space than the</text>
2 <text font="4" height="17" left="108" textpieces="0" top="459" width="702">MAP approach. If there is only a single chunk, then Staccatos output is equivalent to k-MAP.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="479" width="702">If essentially every possible character is a chunk, then we retain the full FST. Experimentally, we</text>
2 <text font="4" height="17" left="108" textpieces="0" top="499" width="702">demonstrate that the Staccato approach gracefully trades o between performance and recall. For</text>
2 <text font="4" height="15" left="108" textpieces="0" top="520" width="702">example, when looking for mentions of laws on a data set that contains scanned acts of the US</text>
2 <text font="4" height="15" left="108" textpieces="0" top="540" width="702">congress, the MAP approach achieves a recall of 0.28 executing in about 1 second, the full FST</text>
2 <text font="4" height="15" left="108" textpieces="0" top="560" width="702">approach achieves perfect recall but takes over 2 minutes. An intermediate representation from</text>
2 <text font="4" height="14" left="108" textpieces="0" top="583" width="702">Staccato takes around 10 seconds and achieves 0.76 recall. Of course, there is a fundamental</text>
2 <text font="4" height="15" left="108" textpieces="1" top="601" width="702">trade o between precision and recall.  On the same query as above, the MAP has precision</text>
2 <text font="4" height="17" left="108" textpieces="0" top="621" width="702">1.0, and the full FST has precision 0.25, while Staccato achieves 0.73. In general, Staccatos</text>
2 <text font="4" height="15" left="108" textpieces="0" top="642" width="382">precision falls in between the MAP and the full FST.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="662" width="677">To understand Staccatos approximation more deeply, we conduct a formal analysis, which</text>
2 <text font="4" height="17" left="108" textpieces="0" top="682" width="702">is our second technical contribution. When constructing Staccatos approximation, we ensure</text>
2 <text font="4" height="15" left="108" textpieces="0" top="702" width="702">two properties (1) each chunk forms a transducer (as opposed to a more general structure), and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="723" width="702">(2) that the model retains the unique path property, i.e., that every string corresponds to a unique</text>
2 <text font="4" height="15" left="108" textpieces="1" top="743" width="702">path.  While both of these properties are satised by the transducers produced by OCRopus,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="763" width="702">neither property is necessary to have a well-dened approximation scheme. Moreover, enforcing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="784" width="702">these two properties increases the complexity of our algorithm and may preclude some compact</text>
2 <text font="4" height="15" left="108" textpieces="0" top="804" width="702">approximations. Thus, it is natural to wonder if we can relax these two properties. While we</text>
2 <text font="4" height="15" left="108" textpieces="0" top="824" width="702">cannot prove that these two conditions are necessary, we show that without these two properties,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="845" width="702">basic operations become intractable. Without the unique path property, prior work has shown</text>
2 <text font="4" height="15" left="108" textpieces="0" top="865" width="702">that determining (even approximating) the k-MAP is intractable for a xed k [34]. Even with the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="885" width="702">unique path property and a xed set of chunks, we show that essentially the simplest violation of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="906" width="702">property (1) makes it intractable to construct an approximation even for k = 2 (Theorem 3.1).</text>
2 <text font="4" height="17" left="108" textpieces="0" top="926" width="702">On the positive side, for any xed partition, Staccato retains a set of strings that achieves the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="946" width="593">highest total probability among approximations that satisfy the above restrictions.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="967" width="677">Finally, we describe how to use standard text-indexing techniques to improve query performance.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="987" width="702">Directly applying an inverted index to transducer data is essentially doomed to failure: the sheer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1007" width="702">number of terms one would have to index grows exponentially with the length of the document,</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">3</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="1" top="113" width="702">e.g., an FST for a single line may represent over 10100terms. To combat this, we allow the user to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">specify a dictionary of terms. We then construct an index of those terms specied in the dictionary.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">This allows us to process keyword and some regular expressions using standard techniques [14, 55].</text>
2 <text font="4" height="15" left="108" textpieces="1" top="197" width="702">Outline  In Section 2, we illustrate our current prototype system to manage OCR data using an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="217" width="702">RDBMS with an example, and we present a brief background on the use of transducers in OCR.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="238" width="702">In Section 3, we briey describe the baseline solutions, and then discuss the main novel technical</text>
2 <text font="4" height="17" left="108" textpieces="0" top="258" width="702">contributions of this work, viz., the Staccato approximation scheme and our formal analysis of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="278" width="702">its properties. In Section 4, we describe our approach for indexing OCR transducer data, which is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="299" width="702">another technical contribution of this work. In Section 5, we empirically validate that our approach</text>
2 <text font="4" height="15" left="108" textpieces="0" top="319" width="702">is able to trade o recall for query-runtime performance on several real-world OCR data sets. We</text>
2 <text font="4" height="15" left="108" textpieces="0" top="339" width="702">validate that our approximation methods can be eciently implemented, and that our indexing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="360" width="579">technique provides the expected speedups. In Section 6, we discuss related work.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="408" width="176">2  Preliminaries</text>
2 <text font="4" height="17" left="108" textpieces="0" top="448" width="702">The key functionality that Staccato provides is to enable users to query OCR data inside an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="468" width="702">RDBMS as if it were regular text. Specically, we want to enable the LIKE predicate of SQL on</text>
2 <text font="4" height="17" left="108" textpieces="0" top="488" width="702">OCR data. We describe Staccato through an example, followed by a more detailed explanation</text>
2 <text font="4" height="15" left="108" textpieces="0" top="509" width="314">of its semantics and the formal background.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="551" width="275">2.1  Using Staccato with OCR</text>
2 <text font="4" height="15" left="108" textpieces="0" top="583" width="702">Consider an insurance company that stores loss data with scanned report forms in a table with the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="604" width="125">following schema:</text>
2 <text font="4" height="15" left="319" textpieces="0" top="624" width="279">Claims(DocID, Y ear, Loss, DocData)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="654" width="702">A document tuple contains an id, the year the form was led (Year), the amount of the loss (Loss)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="674" width="702">and the contents of the report (DocData). A simple query that an insurance company may want</text>
2 <text font="4" height="15" left="108" textpieces="0" top="695" width="702">to ask over the table - Get loss amounts of all claims in 2010 where the report mentions Ford .</text>
2 <text font="4" height="15" left="108" textpieces="0" top="715" width="570">Were DocData ASCII text, this could be expressed as an SQL query as follows:</text>
2 <text font="4" height="14" left="108" textpieces="0" top="755" width="258">SELECT DocID, Loss FROM Claims</text>
2 <text font="4" height="14" left="108" textpieces="0" top="775" width="378">WHERE Year = 2010 AND DocData LIKE %Ford%;</text>
2 <text font="4" height="15" left="133" textpieces="0" top="812" width="677">If DocData is standard text, the semantics of this query is straightforward: we examine each</text>
2 <text font="4" height="15" left="108" textpieces="0" top="832" width="702">document led in 2010, and check if it contains the string Ford. The challenge is that instead</text>
2 <text font="4" height="15" left="108" textpieces="0" top="852" width="702">of a single document, in OCR applications DocData represents many dierent documents (each</text>
2 <text font="4" height="17" left="108" textpieces="0" top="873" width="702">document is weighted by probability). In Staccato, we can express this as an SQL query that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="893" width="702">uses a simple pattern in the LIKE predicate (also in Figure 1(C)). The twist is that the underlying</text>
2 <text font="4" height="15" left="108" textpieces="0" top="913" width="527">processing must take into account the probabilities from the OCR model.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="934" width="677">Formally, Staccato allows a larger class of queries in the LIKE predicate that can be expressed</text>
2 <text font="4" height="17" left="108" textpieces="0" top="954" width="702">as deterministic nite automata (DFAs). Staccato translates the syntax above in to a DFA using</text>
2 <text font="4" height="17" left="108" textpieces="0" top="974" width="702">standard techniques [29]. As with probabilistic databases [13, 24, 32, 53] , Staccato computes</text>
2 <text font="4" height="17" left="108" textpieces="0" top="995" width="702">the probability that the document matches the regular expression. Staccato does this using</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1015" width="702">algorithms from prior work [34, 45]. The result is a probabilistic relation; after this, we can apply</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">4</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">probabilistic relational database processing techniques [24, 43, 48]. In this work, we consider only</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="659">single table select-project queries (joins are handled using the above mentioned techniques).</text>
2 <text font="4" height="17" left="133" textpieces="0" top="154" width="677">A critical challenge that Staccato must address is given a DFA nd those documents that are</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="702">relevant to the query expressed by the DFA. For a xed query, the existing algorithms are roughly</text>
2 <text font="4" height="15" left="108" textpieces="0" top="194" width="702">linear in the size of data that they must process. To improve the runtime of these algorithms, one</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">strategy (that we take) is to reduce the size of the data that must be processed using approximations.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="235" width="702">The primary contribution of Staccato is the set of mechanisms that we describe in Section 3 to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="702">achieve the trade o of quality and performance by approximating the data. We formally study</text>
2 <text font="4" height="15" left="108" textpieces="0" top="276" width="702">the properties of our algorithms and describe simple mechanisms to allow the user to set these</text>
2 <text font="4" height="15" left="108" textpieces="0" top="296" width="163">parameters in Sec. 3.2.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="316" width="677">One way to evaluate the query above in the deterministic setting is to scan the string in each</text>
2 <text font="4" height="15" left="108" textpieces="0" top="337" width="702">report and check for a match. A better strategy may be to use an inverted index to fetch only</text>
2 <text font="4" height="15" left="108" textpieces="0" top="357" width="702">those documents that contain Ford. In general, this strategy is possible for anchored regular</text>
2 <text font="4" height="15" left="108" textpieces="0" top="377" width="702">expressions [21], which are regular expressions that begin or end with words in the language, e.g.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="398" width="702">no.(2|3) is anchored while (no|num).(2|8) is not. Staccato supports a similar optimization</text>
2 <text font="4" height="15" left="108" textpieces="0" top="418" width="702">using standard text-indexing techniques. There is, however, one twist: At one extreme, any term</text>
2 <text font="4" height="15" left="108" textpieces="0" top="438" width="702">may have some small probability of occurring at every location of the document  which renders</text>
2 <text font="4" height="17" left="108" textpieces="0" top="459" width="702">the index ineective. Nevertheless, we show that Staccato is able to provide ecient indexing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="479" width="485">for anchored regular expressions using a dictionary-based approach.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="522" width="410">2.2  Background: Stochastic Finite Automata</text>
2 <text font="4" height="17" left="108" textpieces="0" top="554" width="702">We formally describe Staccatos data model that is based on Stochastic Finite Automata (SFA).</text>
2 <text font="4" height="15" left="108" textpieces="1" top="574" width="702">This model is essentially identical to the model output by Googles OCRopus [8, 41].4 An SFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="594" width="702">is a nite state machine that emits strings (e.g., the ASCII conversion of an OCR image). The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="615" width="702">model is stochastic, which captures the uncertainty in translating the glyphs and spaces to ASCII</text>
2 <text font="4" height="15" left="108" textpieces="0" top="635" width="77">characters.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="655" width="677">At a high level, an SFA over an alphabet  represents a discrete probability distribution P over</text>
2 <text font="4" height="15" left="108" textpieces="0" top="676" width="125">strings in , i.e.,</text>
2 <text font="4" height="15" left="318" textpieces="1" top="697" width="175">P :  [0, 1] such that</text>
2 <text font="5" height="11" left="502" textpieces="0" top="720" width="31">x</text>
2 <text font="4" height="15" left="536" textpieces="0" top="697" width="65">P (x) = 1</text>
2 <text font="4" height="15" left="108" textpieces="0" top="743" width="702">The SFA represents the (nitely many) strings with non-zero probability using an automaton-like</text>
2 <text font="4" height="15" left="108" textpieces="0" top="764" width="356">structure that we rst describe using an example:</text>
2 <text font="4" height="15" left="108" textpieces="0" top="804" width="702">Example 1. Figure 1 shows an image of text and a simplied SFA created by OCRopus from that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="824" width="702">data. The SFA is a directed acyclic labeled graph. The graphical structure (i.e., the branching)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="845" width="702">in the SFA is used by the OCR tool to capture correlations between the emitted letters. Each</text>
2 <text font="4" height="15" left="108" textpieces="0" top="865" width="702">source-to-sink path (i.e., a path from node 0 to node 5) corresponds to a string with non-zero</text>
2 <text font="4" height="15" left="108" textpieces="0" top="885" width="702">probability. For example, the string Ford is one possible path that uses the following sequence of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="906" width="702">nodes 0  1  2  4  5. The probability of this string can be found by multiplying the edge</text>
2 <text font="4" height="15" left="108" textpieces="0" top="926" width="442">weights corresponding to the path: 0.8  0.4  0.4  0.9  0.12.</text>
2 <text font="6" height="8" left="127" textpieces="0" top="972" width="682">4Our prototype uses the same weighted nite state transducer (FST) model that is used by OpenFST and OCRo-</text>
2 <text font="7" height="12" left="108" textpieces="0" top="991" width="645">pus. We simplify FST to SFAs here only slightly for presentation. See the full version for more details [36]</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">5</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="17" left="133" textpieces="0" top="113" width="676">Formally, we x an alphabet  (in Staccato, this is the set of ASCII characters). An SFA S</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">over  is a tuple S = (V, E, s, f, ) where V is a set of nodes, E  V  V is a set of edges such that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">(V, E) is a directed acyclic graph, and s (resp. f ) is a distinguished start (resp. nal) node. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="352">function  is a stochastic transition function, i.e.,</text>
2 <text font="4" height="15" left="269" textpieces="0" top="212" width="152"> : E    [0, 1] s.t.</text>
2 <text font="6" height="8" left="423" textpieces="0" top="237" width="49">y:(x,y)E</text>
2 <text font="5" height="11" left="435" textpieces="0" top="247" width="25"></text>
2 <text font="4" height="15" left="476" textpieces="1" top="212" width="170">((x, y), ) = 1  x  V</text>
2 <text font="4" height="15" left="108" textpieces="0" top="277" width="702">In essence, (e, ), where e = (x, y), is the conditional probability of transitioning from x  y and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="297" width="80">emitting .</text>
2 <text font="4" height="15" left="133" textpieces="0" top="317" width="677">An SFA denes a probability distribution via its labeled paths. A labeled path from s to f is</text>
2 <text font="4" height="15" left="108" textpieces="4" top="338" width="701">denoted by p = (e1, 1), . . . , (eN, N), where ei E and i , corresponding to the string 1...n,</text>
2 <text font="4" height="15" left="108" textpieces="1" top="358" width="156">with its probability: 5</text>
2 <text font="4" height="15" left="391" textpieces="0" top="395" width="18">Pr</text>
2 <text font="5" height="11" left="396" textpieces="0" top="409" width="8">S</text>
2 <text font="4" height="15" left="409" textpieces="0" top="395" width="35">[p] =</text>
2 <text font="5" height="11" left="452" textpieces="0" top="376" width="13">|p|</text>
2 <text font="5" height="11" left="448" textpieces="0" top="418" width="21">i=1</text>
2 <text font="4" height="15" left="472" textpieces="0" top="395" width="53">(ei, i)</text>
2 <text font="4" height="15" left="133" textpieces="0" top="439" width="677">SFAs in OCR satisfy an important property that we call the unique paths property that says</text>
2 <text font="4" height="15" left="108" textpieces="0" top="459" width="702">that any string produced by the SFA with non-zero probability is generated by a unique labeled</text>
2 <text font="4" height="15" left="108" textpieces="0" top="480" width="702">path through the SFA. We denote by UP the function that takes a string to its unique labeled</text>
2 <text font="4" height="15" left="108" textpieces="0" top="500" width="702">path. This property guarantees tractability of many important computations over SFAs including</text>
2 <text font="4" height="15" left="108" textpieces="0" top="520" width="457">nding the highest probability string produced by the SFA [34].</text>
2 <text font="4" height="15" left="133" textpieces="0" top="541" width="677">Unlike the example given here, the SFAs produced by Googles OCRopus are much larger: they</text>
2 <text font="4" height="15" left="108" textpieces="0" top="561" width="702">contain a weighted arc for every ASCII character. And so, the SFA for a single line can require as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="581" width="179">much as 600 kB to store.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="602" width="677">Queries in Staccato are formalized in the standard way for probabilistic databases. In this</text>
2 <text font="4" height="17" left="108" textpieces="0" top="622" width="702">paper, we consider LIKE predicates that contain Boolean queries expressed as DFAs (Staccato</text>
2 <text font="4" height="15" left="108" textpieces="1" top="642" width="702">handles non-Boolean queries using algorithms in Kimmelfeld and R e [34]). Fix an alphabet  (the</text>
2 <text font="4" height="15" left="108" textpieces="1" top="663" width="702">ASCII characters). Let q :  {0, 1} be expressed as DFA and x be any string. We have q(x) = 1</text>
2 <text font="4" height="15" left="108" textpieces="0" top="683" width="702">when x satises the query, i.e., its accepted by the DFA. We compute the probability that q is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="703" width="445">true; this quantity is denoted Pr[q] and is dened by Pr[q] =</text>
2 <text font="5" height="11" left="576" textpieces="0" top="711" width="31">x</text>
2 <text font="4" height="15" left="611" textpieces="0" top="703" width="199">q(x) Pr(x) (i.e., simply sum</text>
2 <text font="4" height="15" left="108" textpieces="0" top="724" width="702">over all possible strings where q is true). There is a straightforward algorithm based on matrix</text>
2 <text font="4" height="15" left="108" textpieces="0" top="744" width="702">multiplication to process these queries that is linear in the size of the data and cubic in the number</text>
2 <text font="4" height="15" left="108" textpieces="0" top="764" width="181">of states of the DFA [45].</text>
2 <text font="3" height="19" left="108" textpieces="1" top="812" width="362">3  Managing SFAs in an RDBMS</text>
2 <text font="4" height="15" left="108" textpieces="0" top="852" width="702">We start by outlining two baseline approaches that represent the two extremes of query performance</text>
2 <text font="4" height="17" left="108" textpieces="0" top="873" width="702">and recall. Then, we describe the novel approximation scheme of Staccato, which enables us to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="893" width="204">trade performance for recall.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="936" width="702">Baseline Approaches  We study two baseline approaches: k-MAP and the FullSFA approach.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="956" width="702">Fix some k  1. In the k-MAP approach we store the k highest probability strings (simply, top</text>
2 <text font="4" height="15" left="108" textpieces="0" top="977" width="702">k strings) generated by each SFA in our databases. We store one tuple per string along with the</text>
2 <text font="6" height="8" left="127" textpieces="0" top="1007" width="682">5Many (including OpenFST) tools use a formalization with log-odds instead of probabilities. It has some intuitive</text>
2 <text font="7" height="12" left="108" textpieces="0" top="1026" width="540">property for graph concepts, e.g., the shortest path corresponds to the most likely string.</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">6</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">associated probability. Query processing is straightforward: we process each string using standard</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">text-processing techniques, and then sum the probability of each string (since each string is a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">disjoint probabilistic event). In the FullSFA approach, we store the entire SFA as a BLOB inside</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="702">the RDBMS. To answer a query, we retrieve the BLOB, deserialize it, and then use an open source</text>
2 <text font="4" height="15" left="108" textpieces="0" top="194" width="702">C++ automata composition library to answer the query [11, 12] and compute all probabilities.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">Table 1 summarizes the time and space costs for a simple chain SFA (no branching). This table</text>
2 <text font="4" height="15" left="108" textpieces="0" top="235" width="702">gives an engineers intuition about the time and space complexity of the baseline approaches. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="702">factor 16 accounts for the metadata  tuple ID, location in SFA, and probability value (the schema</text>
2 <text font="4" height="17" left="108" textpieces="0" top="276" width="702">is described in the full version [36]). We also include our proposed approach, Staccato that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="296" width="702">depends on a parameter m (the number of chunks) that we describe below. From the table, we</text>
2 <text font="4" height="17" left="108" textpieces="0" top="316" width="702">can read that query processing time for Staccato is essentially linear in m. Let l be the length of</text>
2 <text font="4" height="17" left="108" textpieces="0" top="337" width="702">the document, since m  [1, l] query processing time in Staccato interpolates linearly from the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="357" width="310">k-MAP approach to the FullSFA approach.</text>
1 <text font="4" height="15" left="330" textpieces="2" top="393" width="293">k-MAP   FullSFA           Staccato</text>
1 <text font="4" height="14" left="260" textpieces="5" top="420" width="398">Query  lqk        lq|| + q3(l  1)   lqk + q3(m  1)</text>
1 <text font="4" height="14" left="260" textpieces="3" top="441" width="359">Space   lk + 16k  l|| + 16l||      lk + 16mk</text>
1 <text font="4" height="15" left="287" textpieces="2" top="481" width="242">l   :  length of the SFAs strings</text>
1 <text font="4" height="15" left="286" textpieces="2" top="501" width="244">q   :  # states in the query DFA</text>
1 <text font="4" height="15" left="285" textpieces="2" top="522" width="351">k   :  # paths parameter in k-MAP, Staccato</text>
1 <text font="4" height="15" left="283" textpieces="2" top="542" width="314">m  :  # chunks in Staccato (1  m  l)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="576" width="702">Table 1: Space costs and query processing times for a simple chain SFA. The space indicates the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="596" width="259">number of bytes of storage required.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="657" width="369">3.1  Approximating an SFA with Chunks</text>
2 <text font="4" height="15" left="108" textpieces="0" top="689" width="702">As mentioned before, the SFAs in OCR are much larger than our example, e.g. one OCR line</text>
2 <text font="4" height="15" left="108" textpieces="0" top="709" width="702">from a scanned book yielded an SFA of size 600 kB. In turn, the 200-page book blows up to over</text>
2 <text font="4" height="15" left="108" textpieces="0" top="730" width="702">2 GB when represented by SFAs. Thus, to answer a query that spans many books in the FullSFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="750" width="702">approach, we must read a huge amount of data. This can be a major bottleneck in query processing.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="770" width="702">To combat this we propose to approximate an SFA with a collection of smaller-sized SFAs (that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="791" width="702">we call chunks). Our goal is to create an approximation that allows us to gracefully tradeo from</text>
2 <text font="4" height="15" left="108" textpieces="0" top="811" width="604">the fast-but-low-recall MAP approach to the slow-but-high-recall FullSFA approach.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="831" width="677">Recall that the k-MAP approach is a natural rst approximation, wherein we simply store the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="852" width="702">top-k paths in each of the per-line SFAs. This approach can increase the recall at a linear cost in k.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="872" width="702">However, as we demonstrate experimentally, simply increasing k is insucient to tradeo between</text>
2 <text font="4" height="15" left="108" textpieces="0" top="892" width="583">the two extremes. That is, even for huge values of k we do not achieve full recall.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="912" width="677">Our idea to combat the slow increase of recall starts with the following intuition: the more</text>
2 <text font="4" height="15" left="108" textpieces="0" top="933" width="702">strings from the SFA we store, the higher our recall will be. We observe that if we store the top</text>
2 <text font="4" height="15" left="108" textpieces="1" top="953" width="702">k in each of m smaller SFAs (that we refer to as chunks), we eectively store km distinct strings.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="973" width="702">Thus, increasing the value of k increases the number of strings polynomially. In contrast, increasing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="994" width="702">m, the number of smaller SFAs, increases the number of paths exponentially, as illustrated in Figure</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1014" width="702">2. This observation motivates the idea that to improve quality, we should divide the SFA further.</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">7</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="13" height="5" left="299" textpieces="1" top="273" width="161">                                                                                                                                                                 </text>
2 <text font="10" height="15" left="288" textpieces="1" top="154" width="54">0       1</text>
2 <text font="11" height="13" left="301" textpieces="0" top="123" width="32">a : 0.6</text>
2 <text font="10" height="15" left="381" textpieces="1" top="153" width="51">2      3</text>
2 <text font="11" height="13" left="392" textpieces="0" top="123" width="32">c : 0.4</text>
2 <text font="10" height="15" left="471" textpieces="0" top="154" width="7">4</text>
2 <text font="11" height="13" left="347" textpieces="1" top="123" width="122">b : 0.5            d : 0.7</text>
2 <text font="11" height="13" left="300" textpieces="3" top="144" width="166">p : 0.2             r : 0.3                q : 0.3            s : 0.2</text>
2 <text font="11" height="13" left="298" textpieces="3" top="171" width="169">w : 0.1             y : 0.1                 x : 0.2            z : 0.1</text>
2 <text font="14" height="15" left="348" textpieces="0" top="212" width="76">k-MAP, k = 3</text>
2 <text font="5" height="13" left="341" textpieces="0" top="230" width="90">1. a b c d (0.0840)</text>
2 <text font="5" height="13" left="341" textpieces="0" top="243" width="89">2. a b r d (0.0630)</text>
2 <text font="5" height="13" left="341" textpieces="0" top="255" width="89">3. a q c d (0.0504)</text>
2 <text font="10" height="15" left="334" textpieces="0" top="270" width="100"># strings = k = 3</text>
2 <text font="10" height="15" left="498" textpieces="0" top="123" width="134">STACCATO, m = 2, k = 3</text>
2 <text font="10" height="15" left="303" textpieces="3" top="182" width="153">                    ...</text>
2 <text font="10" height="15" left="288" textpieces="1" top="154" width="54">0       1</text>
2 <text font="16" height="9" left="514" textpieces="1" top="158" width="23">0      1</text>
2 <text font="16" height="9" left="519" textpieces="1" top="172" width="86">                      ...</text>
2 <text font="5" height="13" left="495" textpieces="0" top="230" width="60">1. a b (0.30)</text>
2 <text font="5" height="13" left="495" textpieces="0" top="243" width="60">2. a q (0.18)</text>
2 <text font="5" height="13" left="495" textpieces="0" top="255" width="59">3. a x (0.12)</text>
2 <text font="10" height="15" left="494" textpieces="0" top="271" width="132"># strings = km = 32 = 9</text>
2 <text font="10" height="15" left="507" textpieces="1" top="211" width="111">Top 3       Top 3</text>
2 <text font="10" height="15" left="550" textpieces="0" top="182" width="29">Split</text>
2 <text font="5" height="13" left="576" textpieces="0" top="230" width="59">1. c d (0.28)</text>
2 <text font="5" height="13" left="576" textpieces="0" top="243" width="57">2. r d (0.21)</text>
2 <text font="5" height="13" left="576" textpieces="0" top="255" width="59">3. c s (0.08)</text>
2 <text font="10" height="15" left="559" textpieces="0" top="241" width="9">X</text>
2 <text font="16" height="9" left="571" textpieces="3" top="158" width="-14">2      3      4                        2</text>
2 <text font="4" height="17" left="173" textpieces="0" top="312" width="572">Figure 2: A depiction of conventional Top-k versus Staccatos approximation.</text>
2 <text font="4" height="15" left="245" textpieces="0" top="375" width="203">Algorithm 1: FindMinSFA</text>
2 <text font="4" height="15" left="258" textpieces="0" top="397" width="411">Inputs: SFA S with partial order  on its nodes, X  V</text>
2 <text font="4" height="15" left="258" textpieces="0" top="417" width="283">while X does not form a valid SFA do</text>
2 <text font="4" height="15" left="283" textpieces="0" top="438" width="252">if No unique start node in X then</text>
2 <text font="4" height="15" left="308" textpieces="0" top="455" width="348">Compute the least common ancestor of X, say, l</text>
2 <text font="4" height="15" left="308" textpieces="0" top="476" width="327">X  X  {y  V | l  y and x  X, y  x}</text>
2 <text font="4" height="15" left="283" textpieces="0" top="495" width="244">if No unique end node in X then</text>
2 <text font="4" height="15" left="308" textpieces="0" top="513" width="363">Compute greatest common descendant of X, say, g</text>
2 <text font="4" height="15" left="308" textpieces="0" top="533" width="331">X  X  {y  V | y  g and x  X, x  y}</text>
2 <text font="4" height="15" left="283" textpieces="0" top="552" width="389">e  E s.t. exactly one end-point is in X  {l, g}, add</text>
2 <text font="4" height="15" left="283" textpieces="0" top="573" width="148">other end-point to X</text>
2 <text font="18" height="4" left="251" textpieces="1" top="843" width="209">                                                                                                                                                                                                                                                                                                                                                                                                                                </text>
2 <text font="19" height="14" left="325" textpieces="0" top="692" width="7">4</text>
2 <text font="19" height="14" left="236" textpieces="1" top="721" width="145">0                          5</text>
2 <text font="19" height="14" left="349" textpieces="0" top="756" width="7">3</text>
2 <text font="19" height="14" left="250" textpieces="0" top="713" width="7">a</text>
2 <text font="19" height="14" left="297" textpieces="1" top="699" width="56">e         f</text>
2 <text font="19" height="14" left="297" textpieces="0" top="735" width="7">b</text>
2 <text font="19" height="14" left="329" textpieces="0" top="748" width="7">c</text>
2 <text font="19" height="14" left="358" textpieces="0" top="733" width="7">d</text>
2 <text font="19" height="14" left="274" textpieces="0" top="721" width="7">1</text>
2 <text font="19" height="14" left="307" textpieces="0" top="756" width="7">2</text>
2 <text font="19" height="14" left="566" textpieces="0" top="612" width="7">4</text>
2 <text font="19" height="14" left="477" textpieces="2" top="632" width="155">0     1                     5</text>
2 <text font="19" height="14" left="581" textpieces="0" top="655" width="7">3</text>
2 <text font="19" height="14" left="492" textpieces="0" top="624" width="7">a</text>
2 <text font="19" height="14" left="539" textpieces="1" top="612" width="70">e           f</text>
2 <text font="19" height="14" left="547" textpieces="1" top="637" width="59">bc       d</text>
2 <text font="19" height="14" left="680" textpieces="1" top="666" width="-190">B                                                    Good Merge</text>
2 <text font="19" height="14" left="564" textpieces="0" top="699" width="7">4</text>
2 <text font="19" height="14" left="471" textpieces="1" top="724" width="46">0      1</text>
2 <text font="19" height="14" left="637" textpieces="0" top="717" width="7">5</text>
2 <text font="19" height="14" left="600" textpieces="0" top="739" width="7">3</text>
2 <text font="19" height="14" left="487" textpieces="0" top="716" width="7">a</text>
2 <text font="19" height="14" left="532" textpieces="1" top="701" width="84">e              f</text>
2 <text font="19" height="14" left="548" textpieces="0" top="711" width="7">b</text>
2 <text font="19" height="14" left="577" textpieces="1" top="723" width="41">c     d</text>
2 <text font="19" height="14" left="680" textpieces="0" top="745" width="9">C</text>
2 <text font="21" height="12" left="631" textpieces="0" top="766" width="44">Collapse</text>
2 <text font="19" height="14" left="499" textpieces="0" top="787" width="7">4</text>
2 <text font="19" height="14" left="428" textpieces="1" top="814" width="125">0                      5</text>
2 <text font="19" height="14" left="517" textpieces="0" top="837" width="7">3</text>
2 <text font="19" height="14" left="439" textpieces="0" top="805" width="7">a</text>
2 <text font="19" height="14" left="470" textpieces="1" top="793" width="63">e          f</text>
2 <text font="19" height="14" left="473" textpieces="0" top="820" width="7">b</text>
2 <text font="19" height="14" left="500" textpieces="0" top="828" width="7">c</text>
2 <text font="19" height="14" left="457" textpieces="0" top="814" width="7">1</text>
2 <text font="19" height="14" left="484" textpieces="0" top="837" width="7">2</text>
2 <text font="19" height="14" left="525" textpieces="0" top="819" width="7">d</text>
2 <text font="19" height="14" left="591" textpieces="2" top="811" width="89">0    1         5</text>
2 <text font="19" height="14" left="604" textpieces="0" top="802" width="7">a</text>
2 <text font="19" height="14" left="639" textpieces="0" top="791" width="11">ef</text>
2 <text font="19" height="14" left="644" textpieces="0" top="813" width="22">bcd</text>
2 <text font="19" height="14" left="680" textpieces="0" top="850" width="9">D</text>
2 <text font="21" height="12" left="426" textpieces="0" top="765" width="177">5 is Greatest Common Descendant</text>
2 <text font="21" height="12" left="428" textpieces="0" top="691" width="55">Bad Merge</text>
2 <text font="22" height="12" left="283" textpieces="0" top="796" width="64">Original SFA</text>
2 <text font="19" height="14" left="409" textpieces="0" top="850" width="9">A</text>
2 <text font="4" height="15" left="108" textpieces="0" top="884" width="702">Figure 3: Algorithm 1: FindMinSFA. Illustrating merge and FindMinSFA: (A) Original: The SFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="904" width="702">emits two strings: aef and abcd. Two merges considered: {(1,2),(2,3)} (successive edges), and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="924" width="702">{(1,2),(1,4)} (sibling edges). (B) Good merge: First set gives new edge (1,3), emitting bc. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="945" width="702">SFA still emits only aef and abcd. (C) Bad merge: Second set gives new edge (1,4), emitting e and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="965" width="702">b. But, the SFA now wrongly emits new strings, e.g., abf (dashed lines). (D) Using Algorithm 1</text>
2 <text font="4" height="15" left="108" textpieces="0" top="985" width="702">on the second set, the greatest common descendant is obtained (node 5), and the resulting set is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1006" width="455">collapsed to edge (1,5). The SFA now emits only aef and abcd.</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">8</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="17" left="108" textpieces="0" top="113" width="702">As we demonstrate experimentally, Staccato achieves the most conceptually important feature</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">of our approximation: it allows us to smoothly tradeo recall for performance. In other words,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="516">increasing m (and k) increases the recall at the expense of performance.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="197" width="702">SFA Approximation  Given an SFA S, our goal is to nd a new SFA S that satises two</text>
2 <text font="4" height="15" left="108" textpieces="0" top="217" width="697">competing properties: (1) S should be smaller than S, and (2) the set of strings represented by S</text>
2 <text font="4" height="15" left="108" textpieces="0" top="238" width="702">should contain as many of the high probability strings from S as possible without containing any</text>
2 <text font="4" height="15" left="108" textpieces="1" top="258" width="702">strings not in S.6 Our technique to approximate the SFA S is to merge a set of transitions in S (a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="278" width="687">chunk) to produce a new SFA S ; then we retain only the top k transitions on each edge in S .</text>
2 <text font="4" height="15" left="133" textpieces="0" top="299" width="677">To describe our algorithm, we need some notation. We generalize the denition of SFAs (Section</text>
2 <text font="4" height="15" left="108" textpieces="0" top="319" width="702">2) to allow transitions that produce strings (as opposed to single characters). Formally, the tran-</text>
2 <text font="4" height="15" left="108" textpieces="1" top="339" width="702">sition function  has the type  : E  + [0, 1]. Any SFA meets this generalized SFA denition,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="360" width="568">and so we assume this generalized denition of SFAs for the rest of the section.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="380" width="677">Before describing the merging operation formally, we illustrate the challenge in the merging</text>
2 <text font="4" height="15" left="108" textpieces="0" top="400" width="702">process in Figure 3. Figure 3(A) shows an SFA (without probabilities for readability). We consider</text>
2 <text font="4" height="15" left="108" textpieces="0" top="421" width="702">two merging operations. First, we have chosen to merge the edges (1, 2) and (2, 3) and replaced</text>
2 <text font="4" height="15" left="108" textpieces="0" top="441" width="702">it with a single edge (1, 3). To retain the same strings that are present in the SFA in (A), the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="461" width="702">transition function must emit the string bc on the new edge (1, 3) as illustrated in Figure 3(B).</text>
2 <text font="4" height="15" left="108" textpieces="0" top="481" width="702">In contrast, if we choose to merge the edges (1, 2) and (1, 4), there is an issue: no matter what we</text>
2 <text font="4" height="15" left="108" textpieces="0" top="502" width="702">put on the transition from (1, 4) we will introduce strings that are not present in the original SFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="522" width="702">(Figure 3(C)). The problem is that the set of nodes {1, 2, 4} do not form an SFA by themselves</text>
2 <text font="4" height="15" left="108" textpieces="0" top="542" width="702">(there is no unique nal node). One could imagine generalizing the denition of SFA to allow richer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="563" width="702">structures that could capture the correlations between strings, but as we explain in Section 3.2, this</text>
2 <text font="4" height="15" left="108" textpieces="0" top="583" width="702">approach creates serious technical challenges. Instead, we propose to x this issue by searching for</text>
2 <text font="4" height="17" left="108" textpieces="0" top="603" width="702">a minimal SFA S that contains this set of nodes (the operation called FindMinSFA). Then, we</text>
2 <text font="4" height="15" left="108" textpieces="0" top="624" width="702">replace the nodes in the set with a single edge, retaining only the top k highest probability strings</text>
2 <text font="4" height="17" left="108" textpieces="0" top="644" width="702">from S . We refer to this operation of replacing S with an edge as Collapse. In our example,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="664" width="417">the result of these operations is illustrated in Figure 3(D).</text>
2 <text font="4" height="17" left="133" textpieces="0" top="685" width="603">We describe our algorithms subroutine FindMinSFA and then the entire heuristic.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="728" width="702">FindMinSFA  Given an SFA S and a set of nodes X  V , our goal is to nd a SFA S whose</text>
2 <text font="4" height="15" left="108" textpieces="0" top="748" width="702">node set Y is such that that X  Y . We want the set Y to be minimal in the sense that removing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="769" width="702">any node y  Y causes S to violate the SFA property, that is removing y causes S to no longer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="789" width="702">have a unique start (resp. end) state. Presented in Algorithm 1, our algorithm is based on the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="809" width="702">observation that the unique start node s of S must come before all nodes in X in the topological</text>
2 <text font="4" height="15" left="108" textpieces="0" top="830" width="702">order of the graph (a partial order). Similarly, the end node f of the SFA S must come after all</text>
2 <text font="4" height="15" left="108" textpieces="0" top="850" width="702">nodes in X in topological order. To satisfy these properties, we repeatedly enlarge Y by computing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="870" width="702">the start (resp. nal node) using the least common ancestor (resp. greatest common descendant)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="891" width="702">in the DAG. Additionally, we require that any edge in S that is incident to a node in Y can be</text>
2 <text font="4" height="15" left="108" textpieces="0" top="911" width="702">incident to only either s or f . (Any node incident to both will be internal to S ) If there are no</text>
2 <text font="4" height="15" left="108" textpieces="0" top="931" width="702">such edges, we are done. Otherwise, for each such edge e, we include its endpoints in Y and repeat</text>
2 <text font="4" height="15" left="108" textpieces="0" top="952" width="702">this algorithm with X enlarged to Y . Once we nd a suitable set Y , we replace the set of nodes in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="972" width="702">the SFA S with a single edge from s (the start node of S ) to f (the nal node of S ). Figure 3(D)</text>
2 <text font="6" height="8" left="127" textpieces="0" top="1002" width="330">6This is a type of sucient lineage approximation [46].</text>
2 <text font="4" height="15" left="455" textpieces="0" top="1069" width="8">9</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">illustrates a case when there is no unique end node, and the greatest common descendant has to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="684">be computed. More illustrations, covering the other cases, are presented in the full version [36].</text>
2 <text font="4" height="15" left="108" textpieces="1" top="177" width="702">Algorithm Description  The inputs to our algorithm are the parameters k (the number of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="197" width="702">strings retained per edge) and m (the maximum number of edges that we are allowed to retain in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="217" width="702">the resulting graph). We describe how a user chooses these parameters in Section 3.2. For now,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="238" width="702">we focus on the algorithm. At each step, our approximation creates a restricted type of SFA where</text>
2 <text font="4" height="15" left="108" textpieces="1" top="258" width="702">each edge emits at most k strings, i.e., e  E, |{   | (e, ) &gt; 0}|  k. When given an SFA</text>
2 <text font="4" height="15" left="108" textpieces="1" top="278" width="702">not satisfying this property, our algorithm chooses to retain those strings   with the highest</text>
2 <text font="4" height="15" left="108" textpieces="0" top="299" width="702">values of  (ties broken arbitrarily). This set can be computed eciently using the standard Viterbi</text>
2 <text font="4" height="15" left="108" textpieces="0" top="319" width="702">algorithm [26], which is a dynamic programming algorithm for nding the most likely outputs in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="339" width="702">probabilistic sequence models, like HMMs. By memoizing the best partial results till a particular</text>
2 <text font="4" height="15" left="108" textpieces="0" top="360" width="702">state, it can compute the globally optimal results in polynomial time. To compute the top-k results</text>
2 <text font="4" height="15" left="108" textpieces="0" top="380" width="460">more eciently, we use an incremental variant by Yen et al [54].</text>
2 <text font="4" height="15" left="121" textpieces="0" top="423" width="382">Algorithm 2: Greedy heuristic over SFA S = (V, E)</text>
2 <text font="4" height="15" left="133" textpieces="0" top="446" width="639">Choose {x, y, z} s.t. (x, y), (y, z)  E and maximizing the probability mass of the retained</text>
2 <text font="4" height="15" left="133" textpieces="0" top="467" width="52">strings.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="487" width="313">S  Collapse(FindMinSFA(S, {x, y, z}))</text>
2 <text font="4" height="15" left="133" textpieces="0" top="507" width="221">Repeat above steps till |E|  m</text>
2 <text font="4" height="15" left="133" textpieces="0" top="554" width="677">Algorithm 2 summarizes our heuristic: for each triple of nodes {x, y, z} such that (x, y), (y, z) </text>
2 <text font="4" height="15" left="108" textpieces="1" top="575" width="702">E, we nd a minimal containing SFA Sij by calling FindMinSFA({x, y, z}). We then replace the</text>
2 <text font="4" height="15" left="108" textpieces="1" top="595" width="702">set of nodes in Sij by a single edge f (Collapse above). This edge f keeps only the top-k strings</text>
2 <text font="4" height="15" left="108" textpieces="1" top="615" width="702">produced by Sij. Thus, the triple of nodes {x, y, z} generates a candidate SFA. We choose the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="636" width="702">candidate such that the probability mass of all generated strings is as high as possible (note that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="656" width="702">since we have thrown away some strings, the total probability mass may be less than 1). Given an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="676" width="702">SFA we can compute this using the standard sum-product algorithm (a faster incremental variant</text>
2 <text font="4" height="17" left="108" textpieces="0" top="697" width="702">is actually used in Staccato). We then continue to recurse until we have reached our goal of</text>
2 <text font="4" height="17" left="108" textpieces="0" top="717" width="702">nding an SFA that contains fewer than m edges. A simple optimization (employed by Staccato)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="737" width="502">is to cache those candidates we have considered in previous iterations.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="757" width="677">While our algorithm is not necessarily optimal, it serves as a proof of concept that our concep-</text>
2 <text font="4" height="17" left="108" textpieces="0" top="778" width="702">tual goal can be achieved. That is, Staccato oers a knob to tradeo recall for performance. We</text>
2 <text font="4" height="15" left="108" textpieces="0" top="798" width="702">describe the experimental setup in more detail in Section 5, but we illustrate our point with a simple</text>
2 <text font="4" height="17" left="108" textpieces="0" top="818" width="702">experimental result. Figure 4 plots the recall and runtimes of the two baselines and Staccato.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="839" width="702">Here, we have set k = 100 and m = 10. On these two queries, Staccato falls in the middle on</text>
2 <text font="4" height="15" left="108" textpieces="0" top="859" width="207">both recall and performance.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="922" width="261">3.2  Extensions and Analysis</text>
2 <text font="4" height="15" left="108" textpieces="0" top="954" width="702">To understand the formal underpinning of our approach, we perform a theoretical analysis. In-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="974" width="702">formally, the rst question is: in what sense is choosing the k-MAP the best approximation for</text>
2 <text font="4" height="15" left="108" textpieces="0" top="995" width="702">each chunk in our algorithm? The second question we ask is to justify our restriction to SFAs as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1015" width="702">opposed to richer graphical structures in our approximation. We show that k-MAP in each chunk</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">10</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="23" height="10" left="328" textpieces="1" top="220" width="132">                                            </text>
2 <text font="11" height="13" left="345" textpieces="4" top="207" width="254">0.1          1          10         100        1000</text>
2 <text font="11" height="13" left="342" textpieces="0" top="196" width="6">0</text>
2 <text font="11" height="13" left="332" textpieces="0" top="178" width="16">0.2</text>
2 <text font="11" height="13" left="332" textpieces="0" top="161" width="16">0.4</text>
2 <text font="11" height="13" left="332" textpieces="0" top="143" width="16">0.6</text>
2 <text font="11" height="13" left="332" textpieces="0" top="126" width="16">0.8</text>
2 <text font="11" height="13" left="342" textpieces="0" top="109" width="6">1</text>
2 <text font="24" height="10" left="363" textpieces="0" top="130" width="7">M</text>
2 <text font="24" height="10" left="444" textpieces="0" top="121" width="6">S</text>
2 <text font="24" height="10" left="521" textpieces="0" top="111" width="5">F</text>
2 <text font="25" height="10" left="364" textpieces="0" top="174" width="7">M</text>
2 <text font="25" height="10" left="447" textpieces="0" top="142" width="6">S</text>
2 <text font="25" height="10" left="538" textpieces="0" top="110" width="5">F</text>
2 <text font="11" height="13" left="328" textpieces="0" top="165" width="0">Recall</text>
2 <text font="11" height="13" left="415" textpieces="0" top="217" width="96">Runtime (in secs)</text>
2 <text font="11" height="13" left="518" textpieces="0" top="158" width="10">M</text>
2 <text font="11" height="13" left="518" textpieces="0" top="171" width="8">S</text>
2 <text font="11" height="13" left="518" textpieces="0" top="184" width="7">F</text>
2 <text font="11" height="13" left="528" textpieces="0" top="158" width="33">: MAP</text>
2 <text font="11" height="13" left="528" textpieces="0" top="171" width="58">: STACCATO</text>
2 <text font="11" height="13" left="528" textpieces="0" top="184" width="50">: FullSFA</text>
2 <text font="11" height="13" left="440" textpieces="0" top="166" width="43">Query 2</text>
2 <text font="11" height="13" left="386" textpieces="0" top="115" width="43">Query 1</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="702">Figure 4: Recall - Runtime tradeo for a keyword query (Query 1) and a regular expression query</text>
2 <text font="4" height="15" left="108" textpieces="0" top="276" width="702">(Query 2). The parameters are: number of chunks (m) = 10, number of paths per chunk (k) =</text>
2 <text font="4" height="15" left="108" textpieces="0" top="296" width="422">100, and number of answers queried for (N umAns) = 100.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="345" width="702">is no longer the best approximation and that there is likely no simple algorithm (as an underlying</text>
2 <text font="4" height="15" left="108" textpieces="0" top="365" width="182">problem is NP-complete.)</text>
2 <text font="4" height="15" left="133" textpieces="0" top="385" width="677">We formally dene the goal of our algorithms. Recall that an SFA S on  represents a prob-</text>
2 <text font="4" height="15" left="108" textpieces="3" top="406" width="568">ability distribution PrS :   [0, 1]. Given a set X  , dene PrS[X] =</text>
2 <text font="5" height="11" left="700" textpieces="0" top="414" width="26">xX</text>
2 <text font="4" height="15" left="730" textpieces="0" top="406" width="80">Prs[x]. All</text>
2 <text font="4" height="15" left="108" textpieces="0" top="426" width="702">the approximations that we consider emit a subset of strings from the original model. Given an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="446" width="702">approximation scheme , we denote by Emit() the set of strings that are emitted (retained) by</text>
2 <text font="4" height="15" left="108" textpieces="0" top="467" width="572">that scheme. All other things being equal, we prefer a scheme  to  whenever</text>
2 <text font="4" height="15" left="360" textpieces="0" top="501" width="18">Pr</text>
2 <text font="5" height="11" left="365" textpieces="0" top="515" width="8">S</text>
2 <text font="4" height="15" left="378" textpieces="0" top="501" width="107">[Emit()]  Pr</text>
2 <text font="5" height="11" left="472" textpieces="0" top="515" width="8">S</text>
2 <text font="4" height="15" left="485" textpieces="0" top="501" width="72">[Emit( )]</text>
2 <text font="4" height="15" left="108" textpieces="0" top="542" width="702">That is,  retains more probability mass than  . The formal basis for this choice is a standard</text>
2 <text font="4" height="15" left="108" textpieces="0" top="562" width="702">statistical measure called the Kullback-Leibler Divergence [15], between the original and the ap-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="583" width="702">proximate probability distributions. In the full version [36], we show that this divergence is lower</text>
2 <text font="4" height="15" left="108" textpieces="0" top="603" width="702">(which means the approximate distribution is more similar to the original distribution) if the ap-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="623" width="702">proximation satises the above inequality. In other words, a better approximation retains more of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="644" width="200">the high-probability strings.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="664" width="677">We now describe our two main theoretical results. First for SFAs, Staccatos approach to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="684" width="702">choosing the k highest probability strings in each chunk is optimal. For richer structures than</text>
2 <text font="4" height="15" left="108" textpieces="0" top="705" width="702">SFAs, nding the optimal approximation is intractable (even if we are given the chunk structure,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="725" width="702">described below). Showing the rst statement is straightforward, while the result about richer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="745" width="218">structures is more challenging.</text>
2 <text font="4" height="15" left="108" textpieces="2" top="788" width="702">Optimality of k-MAP for SFAs  Given a generalized SFA S = (V, ). Fix k  1. Let S[k]be</text>
2 <text font="4" height="15" left="108" textpieces="0" top="808" width="702">the set of all SFAs (V,  ) that arise from picking k strings on each edge of S to store. That is, for</text>
2 <text font="4" height="15" left="108" textpieces="0" top="829" width="674">any pair of nodes x, y  V the set of strings with non-zero probability has size smaller than k:</text>
2 <text font="4" height="15" left="349" textpieces="1" top="862" width="225">{  |  ((x, y), ) &gt; 0}  k</text>
2 <text font="4" height="15" left="108" textpieces="1" top="898" width="702">Let Skdenote an SFA that for each pair (x, y)  V chooses the highest probability strings in the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="918" width="285">model (breaking ties arbitrarily). Then,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="950" width="332">Proposition 3.1. For any S  S[k], we have:</text>
2 <text font="4" height="15" left="357" textpieces="0" top="984" width="18">Pr</text>
2 <text font="5" height="11" left="361" textpieces="0" top="998" width="8">S</text>
2 <text font="4" height="15" left="374" textpieces="0" top="984" width="114">[Emit(Sk)]  Pr</text>
2 <text font="5" height="11" left="476" textpieces="0" top="998" width="8">S</text>
2 <text font="4" height="15" left="489" textpieces="0" top="984" width="73">[Emit(S )]</text>
2 <text font="4" height="15" left="133" textpieces="1" top="1024" width="674">Since Skis selected by Staccato, we view this as formal justication for Staccatos choice.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">11</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="1" top="113" width="702">Richer Structural Approximation  We now ask a follow-up question: If we allow more general</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">partitions (rather than collapsing edges), is k-MAP still optimal? To make this precise, we consider</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">a partition of the underlying edges of the SFA into connected components (call that partition ).</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="702">Keeping with our early terminology, an element of the partition is called a chunk. In each chunk, we</text>
2 <text font="4" height="15" left="108" textpieces="1" top="194" width="702">select at most k strings (corresponding to labeled paths through the chunk). Let  :  {0, 1}</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">be an indicator function such that (, ) = 1 only if in chunk  we choose string . For any k  1,</text>
2 <text font="4" height="15" left="108" textpieces="1" top="235" width="702">let Ak denote the set of all such s that picks at most k strings from each chunk, i.e., for any</text>
2 <text font="4" height="15" left="108" textpieces="1" top="255" width="702">   we have |{  | (, ) &gt; 0}|  k. Let Emit() be the set of strings emitted by this</text>
2 <text font="4" height="15" left="108" textpieces="0" top="276" width="702">representation with non-zero probability (all strings that can be created from concatenating paths</text>
2 <text font="4" height="15" left="108" textpieces="0" top="296" width="101">in the model).</text>
2 <text font="4" height="15" left="133" textpieces="0" top="316" width="677">Following the intuition from the SFA case described above, the best  would select the k-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="337" width="702">highest probability strings in each chunk. However, this is not the case. Moreover, we exhibit</text>
2 <text font="4" height="15" left="108" textpieces="0" top="357" width="702">chunk structures, where nding the optimal choice of  is NP-hard in the size of the structure.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="377" width="639">This makes it unlikely that there is any simple description of the optimal approximation.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="411" width="702">Theorem 3.1. Fix k  2. The following problem is NP-complete. Given as input (S, , ) where</text>
2 <text font="4" height="15" left="108" textpieces="0" top="431" width="701">S is an SFA,  partitions the underlying graph of S, and   0, determine if there exists an   Ak</text>
2 <text font="4" height="15" left="108" textpieces="0" top="452" width="195">satisfying Pr[Emit()]  .</text>
2 <text font="4" height="15" left="133" textpieces="0" top="485" width="677">The above problem remains NP-complete if S is restricted to satisfy the unique path property</text>
2 <text font="4" height="15" left="108" textpieces="0" top="506" width="702">and restricted to a binary alphabet. A direct consequence of this theorem is that nding the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="526" width="702">maximizer is at least NP-hard. We provide the proof of this theorem in the full version [36]. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="546" width="702">proof includes a detailed outline of a reduction from a matrix multiplication-related problem that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="567" width="702">is known be to hard. The reduction is by a gadget construction that encodes matrix multiplication</text>
2 <text font="4" height="15" left="108" textpieces="0" top="587" width="702">as SFAs. Each chunk has at most 2 nodes in either border (as opposed to an SFA which has a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="607" width="702">single start and nal node). This is about the weakest violation of the SFA property that we can</text>
2 <text font="4" height="15" left="108" textpieces="0" top="628" width="648">imagine, and suggests to us that the SFA property is critical for tractable approximations.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="671" width="702">Automated Construction of Staccato  Part of our goal is to allow knobs to trade recall</text>
2 <text font="4" height="15" left="108" textpieces="0" top="691" width="702">for performance on a per application basis, but setting the correct values for m and k may be</text>
2 <text font="4" height="15" left="108" textpieces="0" top="712" width="702">unintuitive for users. To reduce the burden on the user, we devise a simple parameter tuning</text>
2 <text font="4" height="15" left="108" textpieces="0" top="732" width="702">heuristic that maximizes query performance, while achieving acceptable recall. To measure recall,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="752" width="702">the user provides a set of labeled examples and representative queries. The user species a quality</text>
2 <text font="4" height="15" left="108" textpieces="0" top="773" width="702">constraint (average recall for the set of queries) and a size constraint (storage space as percentage</text>
2 <text font="4" height="15" left="108" textpieces="0" top="793" width="702">of the original dataset size). The goal is to nd a pair of parameters (m,k) that satises both these</text>
2 <text font="4" height="15" left="108" textpieces="0" top="813" width="702">constraints. We note that the size of the data is a function of (m,k) (see Table 1), which along</text>
2 <text font="4" height="15" left="108" textpieces="0" top="834" width="702">with the size constraint helps us express k in terms of m (or vice versa). We empirically observed</text>
2 <text font="4" height="15" left="108" textpieces="0" top="854" width="702">that for a xed size, a smaller m usually yields faster query performance than a smaller k, which</text>
2 <text font="4" height="15" left="108" textpieces="0" top="874" width="702">suggests that we need to minimize the value of m to maximize query performance. Our method</text>
2 <text font="4" height="15" left="108" textpieces="0" top="895" width="702">works as follows: we pick a given value of m, then calculate the corresponding k that lies on the size</text>
2 <text font="4" height="17" left="108" textpieces="0" top="915" width="702">constraint boundary. Given the resulting (m,k) pair, we compute the Staccato approximation of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="935" width="702">the dataset and estimate the average recall. This problem is now a one-dimensional search problem:</text>
2 <text font="4" height="15" left="108" textpieces="0" top="956" width="702">our goal is to nd the smallest m that satises the recall constraint. We solve this using essentially</text>
2 <text font="4" height="15" left="108" textpieces="0" top="976" width="702">a binary search. If infeasible, the user relaxes one of the constraints and repeats the above method.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="996" width="702">We experimentally validated this tuning method and compared it with an exhaustive search on the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1016" width="414">parameter space. The results are discussed in Section 5.5.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">12</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="3" height="19" left="108" textpieces="1" top="110" width="225">4  Inverted Indexing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="150" width="702">To speedup keywords and anchored regex queries on standard ASCII text, a popular technique</text>
2 <text font="4" height="15" left="108" textpieces="0" top="170" width="702">is to use standard inverted-indexing [14]. While indexing k-MAP data is pretty straightforward,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="190" width="702">the FullSFA is dicult. The reason is that the FullSFA encodes exponentially many strings in its</text>
2 <text font="4" height="15" left="108" textpieces="0" top="211" width="702">length, and so indexing all strings for even a moderate-sized SFA is hopeless. Figure 5 shows the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="231" width="702">size of the index obtained (in number of postings [14], in our case line number item pairs) when we</text>
2 <text font="4" height="17" left="108" textpieces="0" top="251" width="523">try to directly index the Staccato text of a single SFA (one OCR line).</text>
2 <text font="26" height="8" left="299" textpieces="1" top="382" width="161">                                                                                </text>
2 <text font="22" height="12" left="318" textpieces="3" top="367" width="132">1 10 25    50    75   100</text>
2 <text font="22" height="12" left="298" textpieces="0" top="357" width="19">1E1</text>
2 <text font="22" height="12" left="298" textpieces="0" top="340" width="19">1E2</text>
2 <text font="22" height="12" left="298" textpieces="0" top="322" width="19">1E3</text>
2 <text font="22" height="12" left="298" textpieces="0" top="305" width="19">1E4</text>
2 <text font="22" height="12" left="298" textpieces="0" top="288" width="19">1E5</text>
2 <text font="22" height="12" left="495" textpieces="3" top="367" width="139">1 1020   40   60   80 100</text>
2 <text font="22" height="12" left="475" textpieces="0" top="358" width="19">1E1</text>
2 <text font="22" height="12" left="475" textpieces="0" top="330" width="19">1E9</text>
2 <text font="22" height="12" left="469" textpieces="0" top="302" width="25">1E17</text>
2 <text font="22" height="12" left="388" textpieces="0" top="331" width="19">m 5</text>
2 <text font="22" height="12" left="331" textpieces="0" top="296" width="25">m 20</text>
2 <text font="27" height="12" left="431" textpieces="0" top="352" width="7">A</text>
2 <text font="22" height="12" left="522" textpieces="0" top="309" width="21">k 50</text>
2 <text font="22" height="12" left="583" textpieces="0" top="336" width="21">k 10</text>
2 <text font="27" height="12" left="617" textpieces="2" top="352" width="-151">B                                                                                   # Postings                                           # Postings</text>
2 <text font="22" height="12" left="476" textpieces="0" top="343" width="19">1E5</text>
2 <text font="22" height="12" left="325" textpieces="1" top="379" width="298">k: # Paths Parameter                 m: # Chunks Parameter</text>
2 <text font="22" height="12" left="469" textpieces="0" top="316" width="25">1E13</text>
2 <text font="22" height="12" left="469" textpieces="0" top="287" width="25">1E21</text>
2 <text font="4" height="15" left="108" textpieces="0" top="415" width="702">Figure 5: Number of postings (in logscale) from directly indexing one SFA. (A) Fix m, vary k.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="436" width="702">(B) Fix k, vary m. In (B), for k = 50, the number of postings overows the 64-bit representation</text>
2 <text font="4" height="15" left="108" textpieces="0" top="456" width="114">beyond m = 60.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="493" width="677">Figure 5 shows an exponential blowup with m  which is not surprising as we store exponentially</text>
2 <text font="4" height="15" left="108" textpieces="0" top="514" width="702">more paths with increasing m. Our observation is that many of these exponentially many terms</text>
2 <text font="4" height="15" left="108" textpieces="0" top="534" width="702">are useless to applications. Thus, to extend the reach of indexing, we apply a standard technique.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="554" width="702">We use a dictionary of terms input by the user, and construct the index only for these terms [22].</text>
2 <text font="4" height="15" left="108" textpieces="0" top="575" width="702">These terms may be extracted from a known clean text corpus or from other sources like an English</text>
2 <text font="4" height="15" left="108" textpieces="0" top="595" width="702">dictionary. Our construction algorithm builds a DFA from the dictionary of terms, and runs a slight</text>
2 <text font="4" height="15" left="108" textpieces="0" top="615" width="702">modication of the SFA composition algorithm [29] with the data to nd the start locations of all</text>
2 <text font="4" height="15" left="108" textpieces="0" top="636" width="702">terms (details of the modication are in the full version [36]). The running time of the algorithm</text>
2 <text font="4" height="15" left="108" textpieces="0" top="656" width="263">is linear in the size of the dictionary.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="699" width="702">Projection  In traditional text processing, given the length of the keyword and the oset of a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="720" width="702">match, we can read only that small portion of the document to process the query. We extend this</text>
2 <text font="4" height="17" left="108" textpieces="0" top="740" width="702">idea to Staccato by nding a small portion of the SFA that is needed to answer the query  an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="760" width="702">operation that we call projection. Given a term t of length u, we obtain start locations of t from</text>
2 <text font="4" height="15" left="108" textpieces="0" top="781" width="702">the postings. For each start location, we compute an (over)estimate of the nodes that we must</text>
2 <text font="4" height="15" left="108" textpieces="0" top="801" width="702">process to obtain the term t. More precisely, we want the descendant nodes in the DAG that can</text>
2 <text font="4" height="15" left="108" textpieces="0" top="821" width="702">be reached by a directed path from the start location that contains u or fewer edges (we nd such</text>
2 <text font="4" height="15" left="108" textpieces="0" top="842" width="702">nodes using a breadth-rst search). This gives us a set of nodes that we must retrieve, which is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="862" width="289">often much smaller than the entire SFA.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="882" width="677">We empirically show that even a simple indexing scheme as above can be used by Staccato</text>
2 <text font="4" height="15" left="108" textpieces="0" top="902" width="702">to speedup keyword and anchored regular expression queries by over an order of magnitude versus</text>
2 <text font="4" height="15" left="108" textpieces="0" top="923" width="702">a lescan-based approach. This validates our claim that indexing is possible for OCR transducers,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="943" width="702">and opens the possibility of adapting more advanced indexing techniques to improve the runtime</text>
2 <text font="4" height="15" left="108" textpieces="0" top="963" width="69">speedups.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">13</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="3" height="19" left="108" textpieces="1" top="110" width="299">5  Experimental Evaluation</text>
2 <text font="4" height="17" left="108" textpieces="0" top="150" width="702">We experimentally verify that the Staccato approach can gracefully tradeo between performance</text>
2 <text font="4" height="15" left="108" textpieces="0" top="170" width="702">and quality. We also validate that our modications to standard inverted indexing allow us to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="190" width="184">speedup query answering.</text>
1 <text font="4" height="15" left="291" textpieces="0" top="236" width="63">Dataset</text>
1 <text font="4" height="15" left="404" textpieces="2" top="226" width="231">No. of  No. of      Size as:</text>
1 <text font="4" height="15" left="408" textpieces="3" top="247" width="249">Pages    SFAs    SFAs   Text</text>
1 <text font="4" height="15" left="261" textpieces="4" top="267" width="396">Cong. Acts (CA)     38       1590    533MB  90kB</text>
1 <text font="4" height="15" left="261" textpieces="4" top="288" width="396">English Lit. (LT)     32       1211    524MB  78kB</text>
1 <text font="4" height="15" left="263" textpieces="4" top="309" width="394">DB Papers (DB)     16       627    359MB  54kB</text>
2 <text font="4" height="15" left="181" textpieces="0" top="344" width="549">Table 2: Dataset Statistics. Each SFA represents one line of a scanned page.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="405" width="702">Datasets Used  We use three real-world datasets from domains where document digitization is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="425" width="702">growing. Congress Acts (CA) is a set of scans of acts of the U.S. Congress, obtained from The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="446" width="702">Hathi Trust [9]. English Literature (LT) is a set of scans of an English literature book, obtained</text>
2 <text font="4" height="15" left="108" textpieces="0" top="466" width="702">from the JSTOR Archive [10]. Database Papers (DB) is a set of papers that we scanned ourselves</text>
2 <text font="4" height="15" left="108" textpieces="0" top="486" width="702">to simulate a setting where an organization would scan documents for in-house usage. All the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="507" width="702">scan images were converted to SFAs using the OCRopus tool [8]. Each line of each document is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="527" width="702">represented by one SFA. We created a manual ground truth for these documents. The relevant</text>
2 <text font="4" height="15" left="108" textpieces="0" top="547" width="702">statistics of these datasets are shown in Table 2. In order to study the scalability of the approaches</text>
2 <text font="4" height="15" left="108" textpieces="0" top="568" width="605">on much larger datasets, we used a 100 GB dataset obtained from Google Books [7].</text>
2 <text font="4" height="15" left="108" textpieces="1" top="611" width="702">Experimental Setup  The three approaches were implemented in C++ using PostgreSQL 9.0.3.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="631" width="702">The current implementation is single threaded so as to assess the impact of the approximation.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="651" width="702">All experiments are run on Intel Core-2 E6600 machines with 2.4 GHz CPU, 4 GB RAM, running</text>
2 <text font="4" height="15" left="108" textpieces="0" top="672" width="702">Linux 2.6.18-194. The runtimes are averaged over 7 runs. The notation for the parameters is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="692" width="168">summarized in Table 3.</text>
1 <text font="4" height="15" left="271" textpieces="1" top="725" width="279">Symbol                 Description</text>
1 <text font="4" height="15" left="297" textpieces="1" top="746" width="353">k      # Paths Parameter (k-MAP, Staccato)</text>
1 <text font="4" height="15" left="295" textpieces="1" top="767" width="331">m          # Chunks Parameter (Staccato)</text>
1 <text font="4" height="15" left="267" textpieces="1" top="788" width="316">N umAns            # Answers queried for</text>
2 <text font="4" height="15" left="336" textpieces="0" top="822" width="246">Table 3: Notations for Parameters</text>
2 <text font="4" height="15" left="108" textpieces="0" top="860" width="702">We set N umAns = 100, which is greater than the number of answers in the ground truth for all</text>
2 <text font="4" height="17" left="108" textpieces="0" top="881" width="702">reported queries. If Staccato nds fewer matches than N umAns, it may return fewer answers.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="901" width="676">N umAns aects precision, and we do sensitivity analysis for N umAns in the full version [36].</text>
2 <text font="1" height="16" left="108" textpieces="1" top="944" width="415">5.1  Quality - Performance Tradeo (Filescan)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="976" width="702">We now present the detailed quality and performance results for queries run with a full lescan.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="996" width="702">The central technical claim of this paper is that Staccato bridges the gap from the low-recall-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1016" width="702">but-fast MAP to the high-recall-but-slow FullSFA. To verify this claim, we measured the recall</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">14</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">and performance of 21 queries on the three datasets. We formulated these queries based on our</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">discussions with practitioners in companies and researchers in the social sciences who work with</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">real-world OCR data. Table 4 presents a subset of these results (the rest are presented in the full</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="188">version of this paper [36]).</text>
1 <text font="4" height="15" left="258" textpieces="4" top="211" width="402">Query     MAP     k-MAP    FullSFA   Staccato</text>
1 <text font="4" height="15" left="424" textpieces="0" top="232" width="135">Precision/Recall</text>
1 <text font="4" height="15" left="264" textpieces="4" top="253" width="390">CA1    1.00/0.79  1.00/0.79  0.14/1.00    1.00/0.79</text>
1 <text font="4" height="15" left="264" textpieces="4" top="273" width="390">CA2    1.00/0.28  1.00/0.52  0.25/1.00    0.73/0.76</text>
1 <text font="4" height="15" left="266" textpieces="4" top="294" width="388">LT1    0.96/0.87  0.96/0.90  0.92/1.00    0.97/0.91</text>
1 <text font="4" height="15" left="266" textpieces="4" top="314" width="388">LT2    0.78/0.66  0.76/0.66  0.31/0.97    0.44/0.81</text>
1 <text font="4" height="15" left="264" textpieces="4" top="335" width="390">DB1    0.93/0.75  0.90/0.92  0.67/0.99    0.90/0.96</text>
1 <text font="4" height="15" left="264" textpieces="4" top="356" width="390">DB2    0.96/0.76  0.96/0.76  0.33/1.00    0.91/0.97</text>
1 <text font="4" height="15" left="404" textpieces="0" top="376" width="176">Runtime (in seconds)</text>
1 <text font="4" height="15" left="264" textpieces="4" top="397" width="372">CA1      0.17        0.75       86.72        2.87</text>
1 <text font="4" height="15" left="264" textpieces="4" top="418" width="372">CA2      0.18        0.84      150.35        3.36</text>
1 <text font="4" height="15" left="266" textpieces="4" top="439" width="370">LT1      0.13        0.19       83.78        1.98</text>
1 <text font="4" height="15" left="266" textpieces="4" top="459" width="370">LT2      0.14        0.24      155.45        2.88</text>
1 <text font="4" height="15" left="264" textpieces="4" top="480" width="372">DB1      0.07        0.29       40.73        0.75</text>
1 <text font="4" height="15" left="264" textpieces="4" top="500" width="372">DB2      0.07        0.33      619.31        0.86</text>
2 <text font="4" height="15" left="108" textpieces="0" top="535" width="702">Table 4: Recall and runtime results across datasets. The keyword queries are  CA1: P resident,</text>
2 <text font="4" height="15" left="108" textpieces="1" top="555" width="702">LT1: Brinkmann and DB1: T rio.  The regex queries are  CA2: U.S.C. 2\d\d\d, LT2:</text>
2 <text font="4" height="15" left="108" textpieces="0" top="575" width="702">19\d\d, \d\d and DB2: Sec(\x)  \d. Here, \x is any character and \d is any digit. The number</text>
2 <text font="4" height="15" left="108" textpieces="0" top="596" width="702">of ground truth matches are  CA1: 28, LT1: 92, DB1: 68, CA2: 55, LT2: 32 and DB2: 33. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="616" width="435">parameter setting here is: k = 25, m = 40, N umAns = 100.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="653" width="677">We classify the kinds of queries to keywords and regular expressions. The intuition is that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="674" width="702">keyword queries are likely to achieve higher recall on k-MAP compared to more complex queries</text>
2 <text font="4" height="15" left="108" textpieces="0" top="694" width="702">that contain spaces, special characters, and wildcards. Table 4 presents the recall and runtime</text>
2 <text font="4" height="15" left="108" textpieces="0" top="714" width="702">results for six queries  one keyword and one regular expression (regex) query per dataset. Table 4</text>
2 <text font="4" height="15" left="108" textpieces="0" top="735" width="702">conrms that indeed there are intermediate points in our approximation that have faster runtimes</text>
2 <text font="4" height="15" left="108" textpieces="0" top="755" width="694">than FullSFA (even up to two orders of magnitude), while providing higher quality than k-MAP.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="775" width="677">We would like the tradeo of quality for performance to be smooth as we vary m and k. To</text>
2 <text font="4" height="15" left="108" textpieces="0" top="796" width="702">validate that our approximation can support this, we present two queries, a keyword and a regex,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="816" width="702">on the Congress Acts dataset (described below). To demonstrate this point, we vary k (the number</text>
2 <text font="4" height="15" left="108" textpieces="0" top="836" width="702">of paths) for several values of m (the number of chunks) and plot the results in Figure 6. Given an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="857" width="702">SFA, m takes values from 1 to the number of the edges in the SFA (the latter being the nominal</text>
2 <text font="4" height="17" left="108" textpieces="0" top="877" width="702">parameter setting Max). When m = 1, Staccato is equivalent to k-MAP. Note that the state-</text>
2 <text font="4" height="17" left="108" textpieces="0" top="897" width="702">of-the-art in our comparison is essentially the MAP approach (k-MAP with k = 1, or Staccato</text>
2 <text font="4" height="15" left="108" textpieces="0" top="918" width="463">with m = 1, k = 1), which is what is employed by Google Books.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="961" width="702">Keyword Queries  In Figures 6 (A1) and (A2), we see the recall and performance behavior of</text>
2 <text font="4" height="17" left="108" textpieces="0" top="981" width="702">running a keyword query (here President) in Staccato for various combinations of k and m.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1001" width="702">We observe that the recall of k-MAP is high (0.8) but not perfect and in (A2) k-MAP is ecient</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1022" width="702">(0.1s) to answer the query. Further, as we increase k there is essentially no change in recall (the</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">15</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="26" height="8" left="299" textpieces="1" top="369" width="161">                                                                                </text>
2 <text font="22" height="12" left="308" textpieces="3" top="229" width="148">1 10 25     50     75    100</text>
2 <text font="22" height="12" left="301" textpieces="0" top="219" width="6">0</text>
2 <text font="22" height="12" left="292" textpieces="0" top="198" width="15">0.2</text>
2 <text font="22" height="12" left="292" textpieces="0" top="176" width="15">0.4</text>
2 <text font="22" height="12" left="292" textpieces="0" top="155" width="15">0.6</text>
2 <text font="22" height="12" left="292" textpieces="0" top="133" width="15">0.8</text>
2 <text font="22" height="12" left="301" textpieces="0" top="111" width="6">1</text>
2 <text font="22" height="12" left="291" textpieces="0" top="170" width="0">Recall</text>
2 <text font="22" height="12" left="308" textpieces="3" top="371" width="148">1 10 25     50     75    100</text>
2 <text font="22" height="12" left="301" textpieces="0" top="362" width="6">0</text>
2 <text font="22" height="12" left="292" textpieces="0" top="340" width="15">0.2</text>
2 <text font="22" height="12" left="292" textpieces="0" top="319" width="15">0.4</text>
2 <text font="22" height="12" left="292" textpieces="0" top="297" width="15">0.6</text>
2 <text font="22" height="12" left="292" textpieces="0" top="276" width="15">0.8</text>
2 <text font="22" height="12" left="301" textpieces="0" top="254" width="6">1</text>
2 <text font="22" height="12" left="291" textpieces="0" top="313" width="0">Recall</text>
2 <text font="22" height="12" left="496" textpieces="3" top="371" width="139">1 10 25    50     75    100</text>
2 <text font="22" height="12" left="474" textpieces="0" top="362" width="21">0.01</text>
2 <text font="22" height="12" left="480" textpieces="0" top="340" width="15">0.1</text>
2 <text font="22" height="12" left="489" textpieces="0" top="319" width="6">1</text>
2 <text font="22" height="12" left="483" textpieces="0" top="297" width="12">10</text>
2 <text font="22" height="12" left="477" textpieces="0" top="275" width="18">100</text>
2 <text font="22" height="12" left="471" textpieces="0" top="254" width="24">1000</text>
2 <text font="22" height="12" left="471" textpieces="0" top="335" width="0">Runtime (in s)</text>
2 <text font="22" height="12" left="496" textpieces="3" top="229" width="139">1 10 25    50     75    100</text>
2 <text font="22" height="12" left="474" textpieces="0" top="219" width="21">0.01</text>
2 <text font="22" height="12" left="480" textpieces="0" top="198" width="15">0.1</text>
2 <text font="22" height="12" left="489" textpieces="0" top="176" width="6">1</text>
2 <text font="22" height="12" left="483" textpieces="0" top="154" width="12">10</text>
2 <text font="22" height="12" left="477" textpieces="0" top="133" width="18">100</text>
2 <text font="22" height="12" left="471" textpieces="0" top="111" width="24">1000</text>
2 <text font="22" height="12" left="471" textpieces="0" top="192" width="0">Runtime (in s)</text>
2 <text font="27" height="12" left="432" textpieces="0" top="214" width="13">A1</text>
2 <text font="27" height="12" left="611" textpieces="0" top="356" width="13">B2</text>
2 <text font="27" height="12" left="611" textpieces="0" top="214" width="13">A2</text>
2 <text font="27" height="12" left="432" textpieces="0" top="356" width="13">B1</text>
2 <text font="22" height="12" left="326" textpieces="0" top="238" width="108">k: # Paths Parameter</text>
2 <text font="22" height="12" left="325" textpieces="0" top="382" width="108">k: # Paths Parameter</text>
2 <text font="22" height="12" left="507" textpieces="0" top="238" width="108">k: # Paths Parameter</text>
2 <text font="22" height="12" left="507" textpieces="0" top="382" width="108">k: # Paths Parameter</text>
2 <text font="28" height="8" left="325" textpieces="0" top="153" width="26">Column B</text>
2 <text font="28" height="8" left="325" textpieces="0" top="163" width="26">Column F</text>
2 <text font="28" height="8" left="325" textpieces="0" top="172" width="26">Column F</text>
2 <text font="28" height="8" left="325" textpieces="0" top="182" width="26">Column F</text>
2 <text font="28" height="8" left="325" textpieces="0" top="192" width="26">Column B</text>
2 <text font="28" height="8" left="325" textpieces="0" top="202" width="26">Column B</text>
2 <text font="28" height="8" left="325" textpieces="0" top="212" width="25">Column J</text>
2 <text font="24" height="10" left="329" textpieces="0" top="152" width="33">FullSFA</text>
2 <text font="24" height="10" left="329" textpieces="0" top="171" width="69">STACCATO m 100</text>
2 <text font="24" height="10" left="329" textpieces="0" top="181" width="64">STACCATO m 40</text>
2 <text font="24" height="10" left="329" textpieces="0" top="191" width="64">STACCATO m 10</text>
2 <text font="24" height="10" left="329" textpieces="0" top="201" width="28">k-MAP</text>
2 <text font="24" height="10" left="329" textpieces="0" top="211" width="20">MAP</text>
2 <text font="24" height="10" left="329" textpieces="0" top="161" width="71">STACCATO m Max</text>
2 <text font="4" height="15" left="108" textpieces="0" top="418" width="702">Figure 6: Recall and Runtime variations with k, for dierent values of m, on two queries: (A)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="438" width="702">P resident (keyword), and (B) U.S.C. 2\d\d\d (regex). The \d is short for (0|1|...|9). The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="459" width="702">runtimes are in logscale. N umAns is set to 100. Recall that m is the number of chunks parameter</text>
2 <text font="4" height="15" left="108" textpieces="0" top="479" width="371">and N umAns is the number of answers queried for.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="529" width="701">running time does increase by an order of magnitude). We veried that the reason is that the top-k</text>
2 <text font="4" height="15" left="108" textpieces="0" top="549" width="702">paths change in only a small set of locations  and so no new occurrences of the string President</text>
2 <text font="4" height="15" left="108" textpieces="0" top="569" width="702">are found. In contrast, the FullSFA approach achieves perfect recall, but it takes over 3 orders of</text>
2 <text font="4" height="17" left="108" textpieces="0" top="590" width="702">magnitude longer to process the query. As we can see from the plots, for the Staccato approach,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="610" width="702">the recall improves as we increase m  with corresponding slowdowns in query time. We believe</text>
2 <text font="4" height="15" left="108" textpieces="0" top="630" width="702">that our approach is promising because of the gradual tradeo of running time for quality. The fact</text>
2 <text font="4" height="15" left="108" textpieces="0" top="651" width="702">that the k-MAP recall does not increase substantially with k, and does not manage to achieve the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="671" width="702">recall of FullSFA even for large k underscores the need for ner-grained partition, which is what</text>
2 <text font="4" height="14" left="108" textpieces="0" top="694" width="118">Staccato does.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="734" width="702">Regular Expressions  Figures 6 (B1) and (B2) present the results for a more sophisticated regex</text>
2 <text font="4" height="15" left="108" textpieces="0" top="755" width="702">query that looks for a congressional code (U.S.C. 2\d\d\d) referenced in the text. As the gure</text>
2 <text font="4" height="15" left="108" textpieces="0" top="775" width="702">shows, this more sophisticated query has much lower recall for the MAP approach, and increases</text>
2 <text font="4" height="15" left="108" textpieces="0" top="795" width="702">slowly with increasing k. Again, we see the same tradeo that the FullSFA approach is orders</text>
2 <text font="4" height="17" left="108" textpieces="0" top="816" width="702">of magnitude slower than k-MAP, but achieves perfect recall. Here, we see that the Staccato</text>
2 <text font="4" height="15" left="108" textpieces="0" top="836" width="702">approach does well: there are substantial (but smooth) jumps in quality as we increase k and m,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="856" width="702">going all the way from MAP to FullSFA. This suggests that more sophisticated queries benet from</text>
2 <text font="4" height="15" left="108" textpieces="0" top="877" width="702">our scheme more, which is an encouraging rst step to enable applications to do rich analytics over</text>
2 <text font="4" height="15" left="108" textpieces="0" top="897" width="73">such data.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="940" width="702">Query Eciency  To assess the impact of query length on recall and runtime, we plot the two</text>
2 <text font="4" height="15" left="108" textpieces="0" top="961" width="702">for a set of keyword queries of increasing length in Figure 7. We observe that the runtimes increase</text>
2 <text font="4" height="15" left="108" textpieces="0" top="981" width="702">polynomially but slowly for all the approaches, while no clear trends exist for the recall. We saw</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1001" width="665">similar results with regular expression queries, and discuss the details in the full version [36].</text>
2 <text font="4" height="15" left="133" textpieces="0" top="1022" width="677">We also studied the impact of m and k on precision (and F-1 score), and observed that the</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">16</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="29" height="13" left="299" textpieces="1" top="189" width="162">                                    </text>
2 <text font="15" height="11" left="323" textpieces="4" top="177" width="132">4       7      10     13     16</text>
2 <text font="15" height="11" left="306" textpieces="0" top="166" width="13">0.1</text>
2 <text font="15" height="11" left="314" textpieces="0" top="152" width="6">1</text>
2 <text font="15" height="11" left="309" textpieces="0" top="137" width="11">10</text>
2 <text font="15" height="11" left="303" textpieces="0" top="123" width="17">100</text>
2 <text font="15" height="11" left="298" textpieces="0" top="108" width="22">1000</text>
2 <text font="15" height="11" left="499" textpieces="4" top="177" width="136">4       7      10      13      16</text>
2 <text font="15" height="11" left="491" textpieces="0" top="166" width="6">0</text>
2 <text font="15" height="11" left="477" textpieces="0" top="152" width="19">0.25</text>
2 <text font="15" height="11" left="483" textpieces="0" top="137" width="14">0.5</text>
2 <text font="15" height="11" left="477" textpieces="0" top="123" width="19">0.75</text>
2 <text font="15" height="11" left="491" textpieces="0" top="108" width="6">1</text>
2 <text font="15" height="11" left="293" textpieces="0" top="171" width="0">Runtime (in s)</text>
2 <text font="15" height="11" left="472" textpieces="0" top="149" width="0">Recall</text>
2 <text font="15" height="11" left="344" textpieces="1" top="186" width="240">Query length                                 Query length</text>
2 <text font="30" height="11" left="327" textpieces="0" top="113" width="7">A</text>
2 <text font="30" height="11" left="622" textpieces="0" top="162" width="7">B</text>
2 <text font="31" height="9" left="515" textpieces="0" top="138" width="4">1</text>
2 <text font="31" height="9" left="515" textpieces="0" top="148" width="4">2</text>
2 <text font="31" height="9" left="515" textpieces="0" top="159" width="4">3</text>
2 <text font="15" height="11" left="516" textpieces="0" top="136" width="37">FullSFA</text>
2 <text font="15" height="11" left="516" textpieces="0" top="146" width="89">STACCATO m 40 k 25</text>
2 <text font="15" height="11" left="516" textpieces="0" top="157" width="56">k-MAP k 25 </text>
2 <text font="4" height="15" left="108" textpieces="0" top="221" width="702">Figure 7: Impact of Query Length on (A) Runtime and (B) Recall. N umAns, the number of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="241" width="239">answers queried for, is set to 100.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="291" width="702">precision of Staccato usually falls in between k-MAP and FullSFA (but F-1 of Staccato can be</text>
2 <text font="4" height="17" left="108" textpieces="0" top="311" width="702">better than both in some cases). Similar to the recall-runtime tradeo, Staccato also manages</text>
2 <text font="4" height="15" left="108" textpieces="0" top="331" width="702">to gracefully tradeo on precision and recall. Due to space constraints, these results are discussed</text>
2 <text font="4" height="15" left="108" textpieces="0" top="352" width="161">in the full version [36].</text>
2 <text font="1" height="16" left="108" textpieces="1" top="395" width="294">5.2  Staccato Construction Time</text>
2 <text font="26" height="8" left="299" textpieces="1" top="518" width="161">                                                                                </text>
2 <text font="15" height="11" left="308" textpieces="1" top="507" width="149">1    100 200 300 400 500</text>
2 <text font="15" height="11" left="302" textpieces="0" top="498" width="6">0</text>
2 <text font="15" height="11" left="296" textpieces="0" top="482" width="11">20</text>
2 <text font="15" height="11" left="296" textpieces="0" top="466" width="11">40</text>
2 <text font="15" height="11" left="296" textpieces="0" top="450" width="11">60</text>
2 <text font="15" height="11" left="296" textpieces="0" top="434" width="11">80</text>
2 <text font="15" height="11" left="291" textpieces="0" top="500" width="0">Time (in s)</text>
2 <text font="15" height="11" left="484" textpieces="1" top="508" width="149">1    100 200 300 400 500</text>
2 <text font="15" height="11" left="477" textpieces="0" top="499" width="6">0</text>
2 <text font="15" height="11" left="472" textpieces="0" top="482" width="11">20</text>
2 <text font="15" height="11" left="472" textpieces="0" top="466" width="11">40</text>
2 <text font="15" height="11" left="472" textpieces="0" top="450" width="11">60</text>
2 <text font="15" height="11" left="472" textpieces="0" top="434" width="11">80</text>
2 <text font="15" height="11" left="468" textpieces="0" top="498" width="0">Time (in s)</text>
2 <text font="15" height="11" left="339" textpieces="1" top="517" width="275">n: Size of SFA                            m: # Chunks Parameter</text>
2 <text font="30" height="11" left="312" textpieces="2" top="439" width="90">A                                                                                    B                                                                            m 1 k 100</text>
2 <text font="15" height="11" left="327" textpieces="0" top="458" width="50">m 40 k 100</text>
2 <text font="15" height="11" left="549" textpieces="0" top="443" width="53">n 500 k 100</text>
2 <text font="15" height="11" left="505" textpieces="0" top="475" width="53">n 150 k 100</text>
2 <text font="4" height="17" left="108" textpieces="0" top="550" width="702">Figure 8: (A) Variation of Staccato approximation runtimes with the size of the SFA (n =</text>
2 <text font="4" height="15" left="108" textpieces="0" top="570" width="702">number of nodes + edges) xing m and k. (B) Sensitivity of the runtimes to m, xing n and k.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="591" width="651">Recall that m is the number of chunks parameter and k is the number of paths parameter.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="632" width="677">We now investigate the runtime of the Staccatos approximation algorithm. The runtime</text>
2 <text font="4" height="15" left="108" textpieces="0" top="652" width="702">depends on the size of the input SFA data as well as m and k. We rst x m and k, then we plot</text>
2 <text font="4" height="15" left="108" textpieces="0" top="673" width="702">the construction time for SFAs of varying size (number of nodes) from the CA dataset (Figure 8(A)).</text>
2 <text font="4" height="15" left="108" textpieces="0" top="693" width="702">Overall, we can see that the algorithm runs eciently  even in our unoptimized implementation.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="713" width="702">As this is an oine process, speed may not be critical for some applications. Also, this computation</text>
2 <text font="4" height="17" left="108" textpieces="0" top="734" width="702">is embarassingly parallel (across SFAs). We used Condor [2] to run the Staccato construction</text>
2 <text font="4" height="15" left="108" textpieces="0" top="754" width="702">on all the SFAs in the three datasets, for all of the above parameters. This process completed in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="774" width="173">approximately 11 hours.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="795" width="677">To study the sensitivity of the construction time to m, we select a xed SFA from the CA dataset</text>
2 <text font="4" height="15" left="108" textpieces="0" top="815" width="702">(Figure 8(B)). When m  |E|, the algorithm picks each transition as a block, and terminates. But</text>
2 <text font="4" height="15" left="108" textpieces="0" top="835" width="702">when m = 300 &lt; |E|, the algorithm computes several candidate merges, leading to a sudden spike</text>
2 <text font="4" height="15" left="108" textpieces="0" top="856" width="702">in the runtime. There onwards, the runtime varies almost linearly with decreasing m. However,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="876" width="702">there are some spikes in the middle. We veried that the spikes arise since the FindMinSFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="896" width="702">operation has to x merged chunks not satisfying the SFA property, thus causing the variation to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="917" width="702">be less smooth. We also veried that the runtime was linear in k, xing the SFA and m (see full</text>
2 <text font="4" height="15" left="108" textpieces="0" top="937" width="702">version [36]). In general, a linear runtime in k is not guaranteed since the chunk structure obtained</text>
2 <text font="4" height="15" left="108" textpieces="0" top="957" width="490">during merging may not be similar across k, for a given SFA and m.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">17</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="1" height="16" left="108" textpieces="1" top="112" width="203">5.3  Inverted Indexing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="144" width="702">We now verify that standard inverted indexing can be made to work on SFAs. We implement</text>
2 <text font="4" height="15" left="108" textpieces="1" top="164" width="702">the index as a relational table with a B+-tree on top of it.  More ecient inverted indexing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="185" width="702">implementations are possible, and so our results are an upperbound on indexing performance.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="205" width="702">However, this prototype serves to illustrate our main technical point that indexing is possible for</text>
2 <text font="4" height="15" left="108" textpieces="0" top="225" width="73">such data.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="246" width="677">A dictionary of about 60,000 terms from a freely available dictionary [4] was converted to a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="266" width="702">prex-trie automaton, and used for index construction. While parsing the query, we ascertain if</text>
2 <text font="4" height="15" left="108" textpieces="0" top="286" width="702">the given regex contains a left-anchor term. If so, we look up the anchor in the index to obtain the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="307" width="490">postings, and retrieve the data to employ query processing on them.</text>
2 <text font="26" height="8" left="299" textpieces="1" top="468" width="161">                                                                                </text>
2 <text font="15" height="11" left="434" textpieces="7" top="460" width="202">0     10    20    30    40    50    60    70</text>
2 <text font="15" height="11" left="428" textpieces="0" top="451" width="6">0</text>
2 <text font="15" height="11" left="423" textpieces="0" top="435" width="11">10</text>
2 <text font="15" height="11" left="423" textpieces="0" top="420" width="11">20</text>
2 <text font="15" height="11" left="423" textpieces="0" top="404" width="11">30</text>
2 <text font="15" height="11" left="423" textpieces="0" top="388" width="11">40</text>
2 <text font="15" height="11" left="423" textpieces="0" top="373" width="11">50</text>
2 <text font="15" height="11" left="423" textpieces="0" top="357" width="11">60</text>
2 <text font="15" height="11" left="423" textpieces="0" top="341" width="11">70</text>
2 <text font="15" height="11" left="533" textpieces="2" top="443" width="78">6      6.3     6.6</text>
2 <text font="15" height="11" left="518" textpieces="0" top="433" width="14">3.5</text>
2 <text font="15" height="11" left="526" textpieces="0" top="415" width="6">5</text>
2 <text font="15" height="11" left="518" textpieces="0" top="397" width="14">6.5</text>
2 <text font="15" height="11" left="526" textpieces="0" top="379" width="6">8</text>
2 <text font="15" height="11" left="286" textpieces="0" top="452" width="20">0.01</text>
2 <text font="15" height="11" left="292" textpieces="0" top="415" width="14">0.1</text>
2 <text font="15" height="11" left="301" textpieces="0" top="378" width="6">1</text>
2 <text font="15" height="11" left="295" textpieces="0" top="341" width="11">10</text>
2 <text font="33" height="9" left="463" textpieces="0" top="350" width="16">Max</text>
2 <text font="33" height="9" left="463" textpieces="0" top="360" width="13">100</text>
2 <text font="33" height="9" left="463" textpieces="0" top="370" width="9">40</text>
2 <text font="33" height="9" left="463" textpieces="0" top="380" width="9">10</text>
2 <text font="33" height="9" left="463" textpieces="0" top="391" width="4">1</text>
2 <text font="30" height="11" left="311" textpieces="2" top="345" width="182">A                                  B    m Max</text>
2 <text font="15" height="11" left="462" textpieces="0" top="358" width="28">m 100</text>
2 <text font="15" height="11" left="462" textpieces="0" top="368" width="23">m 40</text>
2 <text font="15" height="11" left="462" textpieces="0" top="379" width="23">m 10</text>
2 <text font="15" height="11" left="462" textpieces="0" top="389" width="17">m 1</text>
2 <text font="15" height="11" left="342" textpieces="0" top="348" width="31">m Max</text>
2 <text font="15" height="11" left="356" textpieces="0" top="391" width="28">m 100</text>
2 <text font="15" height="11" left="373" textpieces="0" top="371" width="23">m 40</text>
2 <text font="15" height="11" left="337" textpieces="0" top="436" width="17">m 1</text>
2 <text font="15" height="11" left="372" textpieces="0" top="431" width="23">m 10</text>
2 <text font="15" height="11" left="473" textpieces="1" top="469" width="-71">Query Selectivity in %                                                                             k: # Paths Parameter</text>
2 <text font="15" height="11" left="289" textpieces="0" top="423" width="0">Runtime (in s)</text>
2 <text font="15" height="11" left="419" textpieces="0" top="434" width="0">% of Scan Runtime</text>
2 <text font="15" height="11" left="307" textpieces="3" top="460" width="103">1    25   50   75 100</text>
2 <text font="4" height="15" left="108" textpieces="1" top="505" width="702">Figure 9:  (A) Total Runtimes, and (B) Fractional Runtimes Vs Selectivity for the query</text>
2 <text font="4" height="15" left="108" textpieces="0" top="525" width="702">P ublic Law (8|9)\d, using the inverted index with the left anchor term public. Runtimes are in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="546" width="425">logscale. Recall that m is the number of chunks parameter.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="583" width="677">Figure 9 shows the results for a xed length left anchored regex on the CA data set that</text>
2 <text font="4" height="15" left="108" textpieces="1" top="604" width="702">is anchored by a word in the dictionary (here, Public).  We omit some combinations (m =</text>
2 <text font="4" height="15" left="108" textpieces="0" top="624" width="702">100, Max and k = 50, 75, 100) since their indexes had nearly 100% selectivity for all queries that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="644" width="702">we consider, rendering them useless. The rst plot shows the sensitivity of the total runtimes to m</text>
2 <text font="4" height="15" left="108" textpieces="0" top="665" width="702">and k. Mostly, there is a linear trend with k, except for a spike at m = 40, k = 50. To understand</text>
2 <text font="4" height="15" left="108" textpieces="0" top="685" width="702">this behavior, we plot the runtime, as a percentage of the lescan runtime, against the selectivity of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="705" width="702">the term in the index. Ideally, the points should lie on the Y = X line, or slightly above it. For the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="726" width="702">lowest values of m and k, the relative speedup is slightly lowered by the index lookup overhead. But</text>
2 <text font="4" height="15" left="108" textpieces="0" top="746" width="702">as k increases, the query processing dominates, and hence the speedup improves, though selectivity</text>
2 <text font="4" height="15" left="108" textpieces="0" top="766" width="702">changes only slightly. For higher m, the projection overhead lowers the speedup, and as k goes up,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="787" width="702">the selectivity shoots up, increasing the runtime. Overall, we see that dictionary-based indexing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="807" width="322">provides substantial speedups in many cases.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="850" width="137">5.4  Scalability</text>
2 <text font="4" height="15" left="108" textpieces="0" top="882" width="702">To understand the feasibility of our approaches on larger amounts of data, we now study how the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="902" width="702">runtimes scale with increasing dataset sizes. We use a set of 8 scanned books from Google Books [7]</text>
2 <text font="4" height="15" left="108" textpieces="0" top="922" width="602">and use OCRopus to obtain the SFAs. The total size of the SFA dataset is 100 GB.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="943" width="677">Figure 10 shows the scalability results for a regex query. The lescans for FullSFA, MAP and</text>
2 <text font="4" height="14" left="108" textpieces="0" top="966" width="702">Staccato all scale linearly in the dataset size. Overall, the lescan runtimes are in the order</text>
2 <text font="4" height="17" left="108" textpieces="0" top="983" width="702">a few hours for FullSFA. The runtimes are one to two orders of magnitude lower for Staccato,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1003" width="702">depending on the parameters, and about three orders of magnitude lower for MAP. We also veried</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1024" width="702">that indexing over this data provides further speedup (subject to query selectivity) as shown before.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">18</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="23" height="10" left="303" textpieces="1" top="234" width="157">                                                     </text>
2 <text font="22" height="11" left="525" textpieces="1" top="118" width="95">Size (GB)    # SFAs</text>
2 <text font="15" height="11" left="545" textpieces="1" top="139" width="69">1            3400</text>
2 <text font="15" height="11" left="543" textpieces="1" top="158" width="74">10          32000</text>
2 <text font="15" height="11" left="543" textpieces="1" top="178" width="74">25          86000</text>
2 <text font="15" height="11" left="543" textpieces="1" top="198" width="76">50         172000</text>
2 <text font="15" height="11" left="540" textpieces="1" top="218" width="79">100        345000</text>
2 <text font="22" height="11" left="337" textpieces="4" top="224" width="178">0        25       50       75       100</text>
2 <text font="22" height="11" left="321" textpieces="0" top="214" width="14">0.1</text>
2 <text font="22" height="11" left="330" textpieces="0" top="196" width="6">1</text>
2 <text font="22" height="11" left="324" textpieces="0" top="179" width="11">10</text>
2 <text font="22" height="11" left="318" textpieces="0" top="161" width="17">100</text>
2 <text font="22" height="11" left="312" textpieces="0" top="144" width="23">1000</text>
2 <text font="22" height="11" left="306" textpieces="0" top="126" width="29">10000</text>
2 <text font="22" height="11" left="301" textpieces="0" top="108" width="34">100000</text>
2 <text font="11" height="13" left="298" textpieces="0" top="208" width="0">Runtime (in s)</text>
2 <text font="22" height="11" left="409" textpieces="0" top="160" width="92">STACCATO m 40 k 50</text>
2 <text font="22" height="11" left="396" textpieces="0" top="191" width="92">STACCATO m 10 k 50</text>
2 <text font="22" height="11" left="365" textpieces="1" top="233" width="264">Dataset Size (in GB)                                       B</text>
2 <text font="22" height="11" left="346" textpieces="0" top="114" width="38">FullSFA</text>
2 <text font="22" height="11" left="369" textpieces="0" top="204" width="23">MAP</text>
2 <text font="5" height="13" left="377" textpieces="0" top="197" width="0"> </text>
2 <text font="5" height="13" left="497" textpieces="0" top="208" width="8">A</text>
2 <text font="11" height="13" left="338" textpieces="0" top="222" width="6">1</text>
2 <text font="4" height="17" left="108" textpieces="0" top="270" width="702">Figure 10: (A) Filescan runtimes (logscale) against the dataset size for MAP, FullSFA and Stac-</text>
2 <text font="4" height="14" left="108" textpieces="0" top="293" width="597">cato with two parameter settings. (B) Number of SFAs in the respective datasets.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="341" width="702">One can speedup query answering in all of the approaches by partitioning the dataset across multiple</text>
2 <text font="4" height="15" left="108" textpieces="0" top="361" width="702">machines (or even using multiple disks). Thus, to scale to much larger corpora (say, millions of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="382" width="702">books), we plan to investigate the use of parallel data processing frameworks to attack this problem.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="424" width="313">5.5  Automated Parameter Tuning</text>
2 <text font="4" height="15" left="108" textpieces="0" top="456" width="702">We now empirically demonstrate the parameter tuning method on a labeled set of 1590 SFAs (from</text>
2 <text font="4" height="15" left="108" textpieces="0" top="477" width="702">the CA dataset), and a set of 5 queries (both keywords and regular expressions). The size constraint</text>
2 <text font="4" height="15" left="108" textpieces="0" top="497" width="702">is chosen as 10% and the recall constraint is chosen as 0.9. We use increments of 5 for both m and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="517" width="702">k. Based on the tuning method described in Section 3.2, we obtain the following size equation:</text>
2 <text font="4" height="15" left="108" textpieces="0" top="538" width="702">20mk + 58k = 45540, and the resultant parameter estimates of m = 45, k = 45, with a recall of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="558" width="702">0.91. We then performed an exhaustive search on the parameter space to obtain the optimal values</text>
2 <text font="4" height="15" left="108" textpieces="0" top="578" width="702">subject to the same constraints. Figure 11 shows the surface plots of the size and the recall obtained</text>
2 <text font="4" height="15" left="108" textpieces="0" top="599" width="702">by varying m and k. The optimal values obtained are: m = 35, k = 80, again with a recall of 0.91.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="619" width="702">The dierence in the parameter values arises primarily because the tuning method overestimated</text>
2 <text font="4" height="15" left="108" textpieces="0" top="639" width="702">the size at this location. Nevertheless, we see that the tuning method provides parameter estimates</text>
2 <text font="4" height="15" left="108" textpieces="0" top="659" width="232">satisfying the user requirements.</text>
2 <text font="29" height="13" left="299" textpieces="3" top="847" width="337">                                                                           A                                                                          B</text>
2 <text font="4" height="15" left="108" textpieces="0" top="887" width="702">Figure 11: 3-D plots showing the variation of (A) the size of the approximated dataset (in MB),</text>
2 <text font="4" height="15" left="108" textpieces="0" top="907" width="702">and (B) the average recall obtained. Recall that m is the number of chunks parameter and k is the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="927" width="200">number of paths parameter.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">19</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="3" height="19" left="108" textpieces="1" top="110" width="183">6  Related Work</text>
2 <text font="4" height="15" left="108" textpieces="0" top="150" width="702">Transducers are widely used in the OCR and speech communities [11, 41] and mature open-source</text>
2 <text font="4" height="15" left="108" textpieces="0" top="170" width="702">tools exist to process in-memory transducers [12]. For example we use a popular open-source</text>
2 <text font="4" height="15" left="108" textpieces="0" top="190" width="702">tool, OCRopus [8], from Google Books that provides well-trained language models and outputs</text>
2 <text font="4" height="15" left="108" textpieces="0" top="211" width="702">transducers. See Mohri et al. [41] for a discussion of why transducers are well-suited to represent the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="231" width="702">uncertainty for OCR. In the same work, Mohri et al. also describe speech data. We experimented</text>
2 <text font="4" height="15" left="108" textpieces="0" top="251" width="702">with speech data, but we were hampered by the lack of high quality open-source speech recognizer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="272" width="702">toolkits. Using the available toolkits, we found that the language quality from open source speech</text>
2 <text font="4" height="15" left="108" textpieces="0" top="292" width="382">recognizers is substantially below commercial quality.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="312" width="677">The Lahar system [39, 45] manages Hidden Markov Models (HMMs) as Markovian streams</text>
2 <text font="4" height="15" left="108" textpieces="0" top="333" width="702">inside an RDBMS and allows querying them with SQL-like semantics. In contrast to an HMM [44]</text>
2 <text font="4" height="15" left="108" textpieces="0" top="353" width="702">that requires that all strings be of the same length, transducers are able to encode strings of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="373" width="702">dierent lengths. This is useful in OCR, since identifying spaces between words is dicult, and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="393" width="702">this uncertainty is captured by the branching in the SFA [41]. Our work drew inspiration from</text>
2 <text font="4" height="15" left="108" textpieces="0" top="414" width="702">the empirical study of work of approximation trade-os from Letchner et al. [39]. Directly relevant</text>
2 <text font="4" height="15" left="108" textpieces="1" top="434" width="702">to this work is the recent theoretical results of Kimelfeld and R e [34], who studied the problem</text>
2 <text font="4" height="15" left="108" textpieces="0" top="454" width="702">of evaluating transducers as queries over uncertain sequence data modeled using Hidden Markov</text>
2 <text font="4" height="17" left="108" textpieces="0" top="475" width="702">Models [44, 45]. Staccato represents both the data and query by transducers which simplies the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="495" width="188">engineering of our system.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="515" width="677">Transducers are a graphical representation of probability models which makes them related to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="536" width="702">graphical models. Graphical models have been a hot topic in the database research community.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="556" width="702">Kanagal et al. [32] handle general graphical models. Wang et al. [52] also process Conditional</text>
2 <text font="4" height="15" left="108" textpieces="0" top="576" width="702">Random Fields (CRFs) [37]. Though transducers can be viewed as a specialized directed graphical</text>
2 <text font="4" height="15" left="108" textpieces="0" top="597" width="702">model, the primary focus of our work here is on the application of transducers to OCR in the domain</text>
2 <text font="4" height="15" left="108" textpieces="0" top="617" width="702">of content management and the approximations that are critical to achieve good performance.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="637" width="702">However, our work is similar in spirit to these in that we too want to enable SQL-like querying of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="658" width="307">probabilistic OCR data inside an RDBMS.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="678" width="677">Probabilistic graphical models have been successfully applied to various kinds of sequential data</text>
2 <text font="4" height="15" left="108" textpieces="0" top="698" width="702">including OCR [19], RFID [45], speech [40], etc. Various models have been studied in both the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="719" width="509">machine learning and data management communities [23, 31, 32, 45, 52].</text>
2 <text font="4" height="15" left="133" textpieces="0" top="739" width="677">Many approximation schemes for probabilistic models have been studied [30, 39]. We built</text>
2 <text font="4" height="15" left="108" textpieces="0" top="759" width="702">on the technique k-MAP [1], which is particularly relevant to us. Essentially, the idea is to infer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="780" width="702">the top k most likely results from the model and keep only those around. Another popular type</text>
2 <text font="4" height="15" left="108" textpieces="0" top="800" width="702">of approximation is based on mean-eld theory, where the intuition is that we replace complex</text>
2 <text font="4" height="15" left="108" textpieces="0" top="820" width="702">dependencies (say in a graphical model) with their average (in some sense) [51]. Both mean-eld</text>
2 <text font="4" height="15" left="108" textpieces="0" top="841" width="702">theory and our approach share a common formal framework: minimizing KL-divergence. For a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="861" width="702">good overview of various probabilistic graphical models, approximation and inference techniques,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="881" width="524">we refer the reader to the excellent book by Wainwright and Jordan [51].</text>
2 <text font="4" height="15" left="133" textpieces="0" top="902" width="677">Gupta and Sarawagi [27] devise ecient approximation schemes to represent the outputs of a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="922" width="702">CRF, viz., labeled segmentations of text, in a probabilistic database. They partition the space of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="942" width="702">segmentations (i.e., the outputs) using boolean constraints on the output segment labels, and then</text>
2 <text font="4" height="15" left="108" textpieces="0" top="963" width="702">structurally merge the partitions to a pre-dened count using Expectation Maximization, without</text>
2 <text font="4" height="15" left="108" textpieces="0" top="983" width="702">any enumeration. Thus, their nal partitions are disjoint sets of full-row outputs (horizontally</text>
2 <text font="4" height="17" left="108" textpieces="0" top="1003" width="702">partitioned). Both their approach and Staccato use KL-divergence to measure the goodness of</text>
2 <text font="4" height="17" left="108" textpieces="0" top="1024" width="702">approximation. However, Staccato is dierent in that we partition the underlying structure of</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">20</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">the model (vertically partitioned). They also consider soft-partitioning approaches to overcome</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">the limitations of disjoint partitioning. It is interesting future work to adapt such ideas for our</text>
2 <text font="4" height="17" left="108" textpieces="0" top="154" width="365">problem, and compare with Staccatos approach.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="174" width="677">Probabilistic databases have been studied in several recent projects (e.g., ORION [20],Trio [47],</text>
2 <text font="4" height="15" left="108" textpieces="0" top="194" width="702">MystiQ [24], Sprout [43], and MayBMS [13]). Our work is complementary to these eorts: the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">queries we consider can produce probabilistic data that can be ingested by many of the above</text>
2 <text font="4" height="15" left="108" textpieces="0" top="235" width="702">systems, while the above systems focus on querying restricted models (e.g., U-Relations or BIDs).</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="702">We also use model-based views [25] to expose the results of query-time inference over the OCR</text>
2 <text font="4" height="15" left="108" textpieces="0" top="276" width="198">transducers to applications.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="296" width="677">The OCR, speech and IR communities have explored error correction techniques as well as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="316" width="702">approximate retrieval schemes [18, 28, 42]. However, prior work primarily focus on keyword search</text>
2 <text font="4" height="17" left="108" textpieces="0" top="337" width="702">over plain-text transcriptions. Staccato can benet from these approaches and is orthogonal</text>
2 <text font="4" height="15" left="108" textpieces="0" top="357" width="702">to our goal of integrating OCR data into an RDBMS. In contrast, we advocate retaining the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="377" width="231">uncertainty in the transcription.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="398" width="677">Many authors have explored indexing techniques for probabilistic data [33, 35, 38, 49]. Letchner</text>
2 <text font="4" height="15" left="108" textpieces="0" top="418" width="702">et al. [38] design new indexes for RFID data stored in an RDBMS as Markovian streams. Kanagal</text>
2 <text font="4" height="15" left="108" textpieces="0" top="438" width="702">et al. [33] consider indexing correlated probabilistic streams using tree partitioning algorithms and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="459" width="702">describe a new technique called shortcut potentials to speedup query answering. Kimura et al. [35]</text>
2 <text font="4" height="15" left="108" textpieces="0" top="479" width="702">propose a new uncertain primary index that clusters heap les according to uncertain attributes.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="499" width="702">Singh et al. [49] consider indexing categorical data and propose an R-tree based index as well as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="520" width="702">a probabilistic inverted index. Our work focuses on the challenges that content models like OCR</text>
2 <text font="4" height="15" left="108" textpieces="0" top="540" width="337">raise for integrating indexing with an RDBMS.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="588" width="343">7  Conclusion and Future Work</text>
2 <text font="4" height="17" left="108" textpieces="0" top="628" width="702">We present our prototype system, Staccato, that integrates a probabilistic model for OCR into an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="648" width="702">RDBMS. We demonstrated that it is possible to devise an approximation scheme that trades query</text>
2 <text font="4" height="15" left="108" textpieces="0" top="669" width="702">runtime performance for result quality (in particular, increased recall). The technical contributions</text>
2 <text font="4" height="15" left="108" textpieces="0" top="689" width="702">are a novel approximation scheme and a formal analysis of this scheme. Additionally, we showed</text>
2 <text font="4" height="15" left="108" textpieces="0" top="709" width="648">how to adapt standard text-indexing schemes to OCR data, while retaining more answers.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="730" width="677">Our future work is in two main directions. Firstly, we aim to extend Staccato to handle larger</text>
2 <text font="4" height="15" left="108" textpieces="0" top="750" width="702">data sets and more sophisticated querying (e.g., using aggregation with a probabilistic RDBMS,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="770" width="702">sophisticated indexing, parallel processing etc.). Secondly, we aim to extend our techniques to more</text>
2 <text font="4" height="15" left="108" textpieces="0" top="791" width="702">types of content-management data such as speech transcription data. Interestingly, transducers</text>
2 <text font="4" height="15" left="108" textpieces="0" top="811" width="702">provide a unifying formal framework for both transcription processes. Our initial experiments</text>
2 <text font="4" height="15" left="108" textpieces="0" top="831" width="702">with speech data suggest that similar approximations techniques may be useful. This direction is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="852" width="702">particularly exciting to us: it is a rst step towards unifying RDBMS and content-management</text>
2 <text font="4" height="15" left="108" textpieces="0" top="872" width="304">systems, two multibillion dollar industries.</text>
2 <text font="3" height="19" left="108" textpieces="0" top="916" width="190">Acknowledgments</text>
2 <text font="4" height="15" left="108" textpieces="0" top="960" width="702">This work is supported by the National Science Foundation under IIS-1054009, the Oce of Naval</text>
2 <text font="4" height="15" left="108" textpieces="0" top="980" width="702">Research under N000141210041 and the Microsoft Jim Gray Systems Lab. Any opinions, ndings,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1000" width="702">conclusions or recommendations expressed in this work are those of the authors and do not neces-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1021" width="702">sarily reect the views of the US government or Microsoft. The authors also thank the anonymous</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">21</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">PVLDB reviewers as well as Jignesh Patel and Benny Kimelfeld for their valuable feedback on an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="201">earlier version of this paper.</text>
2 <text font="3" height="19" left="108" textpieces="0" top="181" width="113">References</text>
2 <text font="4" height="15" left="116" textpieces="0" top="221" width="694">[1] A Brief Introduction to Graphical Models and Bayesian Networks. http://www.cs.ubc.ca/ mur-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="242" width="174">phyk/Bayes/bayes.html.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="276" width="587">[2] Condor high-throughput computing system. http://www.cs.wisc.edu/condor/.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="309" width="450">[3] Content Management Systems. http://www.cmswire.com/.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="343" width="450">[4] Corncob List. http://www.mieliestronk.com/wordlist.html.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="377" width="517">[5] Digital humanities by UWs Prof. Witmore. http://winedarksea.org.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="411" width="371">[6] ExperVision Inc. http://www.expervision.com/.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="444" width="325">[7] Google Books. http://books.google.com/.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="478" width="545">[8] OCRopus open source OCR system. http://code.google.com/p/ocropus.</text>
2 <text font="4" height="15" left="116" textpieces="0" top="512" width="359">[9] The Hathi Trust. http://www.hathitrust.org/.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="546" width="357">[10] The JSTOR Archive. http://www.jstor.org/.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="580" width="702">[11] Cyril Allauzen, Mehryar Mohri, and Murat Saraclar. General indexation of weighted automata</text>
2 <text font="4" height="15" left="142" textpieces="0" top="600" width="668">- application to spoken utterance retrieval. In Workshop on Interdisciplinary Approaches to</text>
2 <text font="4" height="15" left="142" textpieces="0" top="620" width="475">Speech Indexing and Retrieval (HLT/NAACL), pages 3340, 2004.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="654" width="702">[12] Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wojciech Skut, and Mehryar Mohri. Openfst:</text>
2 <text font="4" height="15" left="142" textpieces="0" top="674" width="661">A general and ecient weighted nite-state transducer library. In CIAA, pages 1123, 2007.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="708" width="702">[13] Lyublena Antova, Christoph Koch, and Dan Olteanu. Maybms: Managing incomplete infor-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="728" width="615">mation with probabilistic world-set decompositions. In ICDE, pages 14791480, 2007.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="762" width="702">[14] Ricardo A. Baeza-Yates and Berthier Ribeiro-Neto. Modern Information Retrieval. Addison-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="782" width="317">Wesley Longman Publishing Co., Inc., 1999.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="816" width="702">[15] Christopher M. Bishop. Pattern Recognition and Machine Learning. Springer-Verlag New</text>
2 <text font="4" height="15" left="142" textpieces="0" top="837" width="118">York, Inc., 2006.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="870" width="702">[16] Vincent D. Blondel and John N. Tsitsiklis. When is a pair of matrices mortal? Inf. Process.</text>
2 <text font="4" height="15" left="142" textpieces="0" top="891" width="127">Lett., 63(5), 1997.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="924" width="702">[17] Olivier Bournez and Michael S. Branicky. The mortality problem for matrices of low dimen-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="945" width="309">sions. Theory of Computing Systems, 2002.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="979" width="702">[18] James Callan, W. Bruce Croft, and Stephen M. Harding. The inquery retrieval system. In</text>
2 <text font="4" height="15" left="142" textpieces="0" top="999" width="191">DEXA, pages 7883, 1992.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">22</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">[19] M. Y. Chen, A. Kundu, and J. Zhou. O-line handwritten word recognition using a hidden</text>
2 <text font="4" height="15" left="142" textpieces="0" top="133" width="657">markov model type stochastic network. Pattern Anal. Mach. Intell., 16:481496, May 1994.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="167" width="702">[20] Reynold Cheng, Dmitri V. Kalashnikov, and Sunil Prabhakar. Evaluating probabilistic queries</text>
2 <text font="4" height="15" left="142" textpieces="0" top="188" width="398">over imprecise data. In SIGMOD, pages 551562, 2003.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="221" width="702">[21] Junghoo Cho and Sridhar Rajagopalan. A fast regular expression indexing engine. In ICDE,</text>
2 <text font="4" height="15" left="142" textpieces="0" top="242" width="149">pages 419430, 2001.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="275" width="702">[22] Richard Cole, Lee-Ad Gottlieb, and Moshe Lewenstein. Dictionary matching and indexing</text>
2 <text font="4" height="15" left="142" textpieces="0" top="296" width="422">with errors and dont cares. In STOC, pages 91100, 2004.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="329" width="702">[23] Robert G. Cowell, A. Philip Dawid, Steen L. Lauritzen, and David J. Spiegelhalter. Proba-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="350" width="668">bilistic Networks and Expert Systems: Exact Computational Methods for Bayesian Networks.</text>
2 <text font="4" height="15" left="142" textpieces="0" top="370" width="107">Springer, 2007.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="404" width="702">[24] Nilesh N. Dalvi and Dan Suciu. Ecient query evaluation on probabilistic databases. In</text>
2 <text font="4" height="15" left="142" textpieces="0" top="424" width="205">VLDB, pages 864875, 2004.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="458" width="702">[25] Amol Deshpande and Samuel Madden.  Mauvedb: supporting model-based user views in</text>
2 <text font="4" height="15" left="142" textpieces="0" top="478" width="366">database systems. In SIGMOD, pages 7384, 2006.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="512" width="543">[26] Jr. Forney, G.D. The viterbi algorithm. Proc. IEEE, 61:268278, 1973.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="546" width="702">[27] Rahul Gupta and Sunita Sarawagi. Creating probabilistic databases from information extrac-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="566" width="321">tion models. In VLDB, pages 965976, 2006.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="600" width="702">[28] S.M. Harding, W. B. Croft, and C. Weir. Probabilistic retrieval of ocr degraded text using</text>
2 <text font="4" height="15" left="142" textpieces="0" top="620" width="294">n-grams. In ECDL, pages 345359, 1997.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="654" width="702">[29] John E. Hopcroft, Rajeev Motwani, and Jerey D. Ullman. Introduction to Automata Theory,</text>
2 <text font="4" height="15" left="142" textpieces="0" top="674" width="668">Languages, and Computation (3rd Edition). Addison-Wesley Longman Publishing Co., Inc.,</text>
2 <text font="4" height="15" left="142" textpieces="0" top="695" width="37">2006.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="728" width="702">[30] F.V. Jensen and S.K. Andersen. Approx. in bayesian belief universes for knowledge-based</text>
2 <text font="4" height="15" left="142" textpieces="0" top="749" width="277">systems. In UAI, pages 162169, 1990.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="783" width="476">[31] M. I. Jordan. Learning in graphical models. MIT Press, 1999.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="816" width="702">[32] Bhargav Kanagal and Amol Deshpande. Ecient query evaluation over temporally correlated</text>
2 <text font="4" height="15" left="142" textpieces="0" top="837" width="398">probabilistic streams. In ICDE, pages 13151318, 2009.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="870" width="702">[33] Bhargav Kanagal and Amol Deshpande. Indexing correlated probabilistic databases. In SIG-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="891" width="199">MOD, pages 455468, 2009.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="925" width="702">[34] Benny Kimelfeld and Christopher R e. Transducing markov sequences. In PODS, pages 1526,</text>
2 <text font="4" height="15" left="142" textpieces="0" top="945" width="37">2010.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="979" width="702">[35] Hideaki Kimura, Samuel Madden, and Stanley B. Zdonik. Upi: A primary index for uncertain</text>
2 <text font="4" height="15" left="142" textpieces="0" top="999" width="287">databases. PVLDB, 3(1):630637, 2010.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">23</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="1" top="113" width="702">[36] Arun Kumar and Christopher R e. Probabilistic management of ocr data using an rdbms.</text>
2 <text font="4" height="15" left="142" textpieces="0" top="133" width="668">UW-CS-Technical Report, 2011. available from http://www.cs.wisc.edu/hazy/staccato/</text>
2 <text font="4" height="14" left="142" textpieces="0" top="155" width="185">papers/HazyOCR_TR.pdf.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="188" width="702">[37] John Laerty. Conditional random elds: Probabilistic models for segmenting and labeling</text>
2 <text font="4" height="15" left="142" textpieces="0" top="208" width="294">sequence data. Morgan Kaufmann, 2001.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="242" width="702">[38] Julie Letchner, Christopher R e, Magdalena Balazinska, and Matthai Philipose. Access methods</text>
2 <text font="4" height="15" left="142" textpieces="0" top="262" width="393">for markovian streams. In ICDE, pages 246257, 2009.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="296" width="702">[39] Julie Letchner, Christopher R e, Magdalena Balazinska, and Matthai Philipose. Approximation</text>
2 <text font="4" height="15" left="142" textpieces="0" top="316" width="668">trade-os in markovian stream processing: An empirical study. In ICDE, pages 936939, 2010.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="350" width="702">[40] S. E. Levinson, L. R. Rabiner, and M. M. Sondhi. An introduction to the application of the</text>
2 <text font="4" height="15" left="142" textpieces="0" top="370" width="668">theory of probabilistic functions of a markov process to automatic speech recognition. Bell</text>
2 <text font="4" height="15" left="142" textpieces="0" top="390" width="341">Systems Technical Journal, 62:10351074, 1983.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="424" width="702">[41] Mehryar Mohri. Finite-state transducers in language and speech processing. Computational</text>
2 <text font="4" height="15" left="142" textpieces="0" top="445" width="234">Linguistics, 23(2):269311, 1997.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="478" width="702">[42] Shunji Mori, Hirobumi Nishida, and Hiromitsu Yamada. Optical character recognition. John</text>
2 <text font="4" height="15" left="142" textpieces="0" top="499" width="182">Wiley &amp; Sons, Inc., 1999.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="532" width="702">[43] Dan Olteanu, Jiewen Huang, and Christoph Koch. Sprout: Lazy vs. eager query plans for</text>
2 <text font="4" height="15" left="142" textpieces="0" top="553" width="531">tuple-independent probabilistic databases. In ICDE, pages 640651, 2009.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="587" width="702">[44] Lawrence R. Rabiner. A tutorial on hidden markov models and selected applications in speech</text>
2 <text font="4" height="15" left="142" textpieces="0" top="607" width="373">recognition. In Proc. of IEEE, pages 257286, 1989.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="641" width="702">[45] Christopher R e, Julie Letchner, Magdalena Balazinska, and Dan Suciu. Event queries on</text>
2 <text font="4" height="15" left="142" textpieces="0" top="661" width="484">correlated probabilistic streams. In SIGMOD, pages 715728, 2008.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="695" width="702">[46] Christopher R e and Dan Suciu. Approximate lineage for probabilistic databases. PVLDB,</text>
2 <text font="4" height="15" left="142" textpieces="0" top="715" width="138">1(1):797808, 2008.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="749" width="702">[47] Anish Das Sarma, Omar Benjelloun, Alon Halevy, and Jennifer Widom. Working models for</text>
2 <text font="4" height="15" left="142" textpieces="0" top="769" width="292">uncertain data. ICDE, pages 718, 2006.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="803" width="702">[48] Anish Das Sarma, Martin Theobald, and Jennifer Widom. Exploiting lineage for condence</text>
2 <text font="4" height="15" left="142" textpieces="0" top="823" width="631">computation in uncertain and probabilistic databases. In ICDE, pages 10231032, 2008.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="857" width="702">[49] Sarvjeet Singh, Chris Mayeld, Sunil Prabhakar, Rahul Shah, and Susanne Hambrusch. In-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="877" width="472">dexing uncertain categorical data. In ICDE, pages 616625, 2007.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="911" width="702">[50] Paavo Turakainen. Generalized automata and stochastic languages. Proc. of American Math-</text>
2 <text font="4" height="15" left="142" textpieces="0" top="931" width="210">ematical Society, 21(2), 1969.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="965" width="702">[51] Martin J. Wainwright and Michael I. Jordan. Graphical models, exponential families, and</text>
2 <text font="4" height="15" left="142" textpieces="0" top="986" width="549">variational inference. Foundations and Trends of Machine Learning, 1, 2008.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">24</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">[52] Daisy Zhe Wang, Eirinaios Michelakis, Minos N. Garofalakis, and Joseph M. Hellerstein.</text>
2 <text font="4" height="15" left="142" textpieces="0" top="133" width="668">Bayesstore: managing large, uncertain data repositories with probabilistic graphical models.</text>
2 <text font="4" height="15" left="142" textpieces="0" top="154" width="206">PVLDB, 1(1):340351, 2008.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="188" width="702">[53] Jennifer Widom. Trio: A system for integrated management of data, accuracy, and lineage.</text>
2 <text font="4" height="15" left="142" textpieces="0" top="208" width="222">In CIDR, pages 262276, 2005.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="242" width="702">[54] Jin Y. Yen. Finding the k shortest loopless paths in a network. In Management Science, 1971.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="275" width="702">[55] Justin Zobel, Alistair Moat, and Ron Sacks-davis. An ecient indexing technique for full-text</text>
2 <text font="4" height="15" left="142" textpieces="0" top="296" width="249">database systems. In VLDB, 1992.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="329" width="702">[56] Argyrios Zymnis, Stephen Boyd, and Dimitry Gorinevsky. Relaxed maximum a posteriori fault</text>
2 <text font="4" height="15" left="142" textpieces="0" top="350" width="325">identication. Signal Process., 89, June 2009.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="398" width="303">A  Finite State Transducers</text>
2 <text font="4" height="17" left="108" textpieces="0" top="438" width="702">As mentioned in Section 2, the formal model used by Staccato to encode the uncertainty informa-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="458" width="702">tion in OCR data is the Finite State Transducer (FST). A transducer is an automaton that converts</text>
2 <text font="4" height="15" left="108" textpieces="0" top="479" width="702">(tranduces) strings from an input alphabet to an output alphabet. We can view a transducer as an</text>
2 <text font="4" height="15" left="108" textpieces="0" top="499" width="702">SFA that both reads and emits characters on its transitions. Formally, we x an input alphabet </text>
2 <text font="4" height="15" left="108" textpieces="0" top="519" width="702">and an output alphabet . An FST S over  and  is a tuple S = (V, E, s, f, ) where V is a set</text>
2 <text font="4" height="15" left="108" textpieces="0" top="539" width="702">of nodes, E  V  V is a set of edges such that (V, E) is a directed acyclic graph, and s (resp. f )</text>
2 <text font="4" height="15" left="108" textpieces="0" top="560" width="702">is a distinguished start (resp. nal) node (state). Each edge has nitely many arcs. The function</text>
2 <text font="4" height="15" left="108" textpieces="0" top="580" width="288"> is a stochastic transition function, i.e.,</text>
2 <text font="4" height="15" left="244" textpieces="0" top="618" width="182"> : E      [0, 1] s.t.</text>
2 <text font="6" height="8" left="430" textpieces="0" top="644" width="49">y:(x,y)E</text>
2 <text font="5" height="11" left="429" textpieces="0" top="653" width="53">,</text>
2 <text font="4" height="15" left="484" textpieces="1" top="618" width="187">((x, y), , ) = 1  x  V</text>
2 <text font="4" height="15" left="108" textpieces="0" top="684" width="702">In essence, (e, , ), where e = (x, y), is the conditional probability of transitioning from x  y,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="705" width="702">reading  and emitting . In OCR, the input alphabet is an encoding of the location of the character</text>
2 <text font="4" height="15" left="108" textpieces="0" top="725" width="702">glyphs in the image, while the output alphabet is the set of ASCII characters. An FST also denes</text>
2 <text font="4" height="15" left="108" textpieces="0" top="745" width="479">a discrete probability distribution over strings through its outputs.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="793" width="351">B  Illustrations for FindMinSFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="833" width="702">We now present more illustrations for the FindMinSFA operation (Section 3.1) in Figure 12. As</text>
2 <text font="4" height="15" left="108" textpieces="0" top="854" width="702">shown in Algorithm 1, three cases arise when the given subset of nodes of the SFA S do not form</text>
2 <text font="4" height="15" left="108" textpieces="0" top="874" width="702">an SFA by themselves. Firstly, they might not have a unique start node, in which case their least</text>
2 <text font="4" height="15" left="108" textpieces="0" top="894" width="702">common ancestor has to be computed (Figure 12 (A)). Secondly, they might not have a unique end</text>
2 <text font="4" height="15" left="108" textpieces="0" top="915" width="702">node, in which case their greatest common descendant has to be computed (Figure 12 (B). Finally,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="935" width="702">there could be an external edge incident upon an internal node of the subset (Figure 12 (C)). In all</text>
2 <text font="4" height="15" left="108" textpieces="0" top="955" width="702">cases, FindMinSFA outputs a subset of nodes that form a valid SFA, which is then collapsed and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="976" width="233">replaced with a single edge in S.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">25</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="18" height="4" left="143" textpieces="1" top="396" width="317">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </text>
2 <text font="34" height="11" left="662" textpieces="1" top="364" width="120">0                     5</text>
2 <text font="34" height="11" left="696" textpieces="0" top="355" width="18">aef</text>
2 <text font="34" height="11" left="721" textpieces="0" top="371" width="28">abcd</text>
2 <text font="35" height="11" left="287" textpieces="2" top="323" width="367">C2                               C3                                C4</text>
2 <text font="34" height="11" left="214" textpieces="0" top="335" width="7">4</text>
2 <text font="34" height="11" left="118" textpieces="1" top="355" width="157">0                            5</text>
2 <text font="34" height="11" left="247" textpieces="0" top="386" width="7">3</text>
2 <text font="34" height="11" left="139" textpieces="0" top="347" width="7">a</text>
2 <text font="34" height="11" left="184" textpieces="1" top="336" width="65">e          f</text>
2 <text font="34" height="11" left="187" textpieces="0" top="370" width="7">b</text>
2 <text font="34" height="11" left="226" textpieces="0" top="379" width="7">c</text>
2 <text font="34" height="11" left="252" textpieces="0" top="370" width="7">d</text>
2 <text font="34" height="11" left="169" textpieces="0" top="355" width="7">1</text>
2 <text font="34" height="11" left="202" textpieces="0" top="386" width="7">2</text>
2 <text font="35" height="11" left="111" textpieces="0" top="323" width="16">C1</text>
2 <text font="36" height="9" left="116" textpieces="0" top="397" width="57">Edge 1-4 has</text>
2 <text font="36" height="9" left="116" textpieces="0" top="409" width="63">to be included</text>
2 <text font="34" height="11" left="390" textpieces="0" top="335" width="7">4</text>
2 <text font="34" height="11" left="294" textpieces="1" top="355" width="156">0                            5</text>
2 <text font="34" height="11" left="422" textpieces="0" top="386" width="7">3</text>
2 <text font="34" height="11" left="315" textpieces="0" top="347" width="7">a</text>
2 <text font="34" height="11" left="365" textpieces="1" top="336" width="60">e         f</text>
2 <text font="34" height="11" left="363" textpieces="0" top="370" width="7">b</text>
2 <text font="34" height="11" left="401" textpieces="0" top="379" width="7">c</text>
2 <text font="34" height="11" left="427" textpieces="0" top="370" width="7">d</text>
2 <text font="34" height="11" left="344" textpieces="0" top="355" width="7">1</text>
2 <text font="34" height="11" left="378" textpieces="0" top="386" width="7">2</text>
2 <text font="37" height="9" left="292" textpieces="0" top="398" width="45">No unique</text>
2 <text font="37" height="9" left="292" textpieces="0" top="410" width="41">end node</text>
2 <text font="34" height="11" left="565" textpieces="0" top="341" width="7">4</text>
2 <text font="34" height="11" left="469" textpieces="1" top="360" width="157">0                            5</text>
2 <text font="34" height="11" left="597" textpieces="0" top="392" width="7">3</text>
2 <text font="34" height="11" left="490" textpieces="0" top="353" width="7">a</text>
2 <text font="34" height="11" left="541" textpieces="1" top="341" width="59">e         f</text>
2 <text font="34" height="11" left="538" textpieces="0" top="376" width="7">b</text>
2 <text font="34" height="11" left="577" textpieces="0" top="385" width="7">c</text>
2 <text font="34" height="11" left="603" textpieces="0" top="376" width="7">d</text>
2 <text font="34" height="11" left="520" textpieces="0" top="360" width="7">1</text>
2 <text font="34" height="11" left="553" textpieces="0" top="392" width="7">2</text>
2 <text font="37" height="9" left="462" textpieces="0" top="399" width="71">5 is the greatest</text>
2 <text font="37" height="9" left="462" textpieces="0" top="410" width="93">common descendant</text>
2 <text font="38" height="9" left="671" textpieces="0" top="405" width="99">Collapsed to one edge</text>
2 <text font="34" height="11" left="584" textpieces="2" top="257" width="157">0      1                     5</text>
2 <text font="34" height="11" left="602" textpieces="1" top="250" width="64">a         ef</text>
2 <text font="34" height="11" left="680" textpieces="0" top="264" width="22">bcd</text>
2 <text font="35" height="11" left="404" textpieces="1" top="217" width="191">B2                               B3</text>
2 <text font="34" height="11" left="323" textpieces="0" top="228" width="7">4</text>
2 <text font="34" height="11" left="233" textpieces="0" top="257" width="7">0</text>
2 <text font="34" height="11" left="384" textpieces="0" top="252" width="7">5</text>
2 <text font="34" height="11" left="355" textpieces="0" top="293" width="7">3</text>
2 <text font="34" height="11" left="249" textpieces="0" top="250" width="7">a</text>
2 <text font="34" height="11" left="294" textpieces="1" top="235" width="65">e          f</text>
2 <text font="34" height="11" left="295" textpieces="0" top="272" width="7">b</text>
2 <text font="34" height="11" left="330" textpieces="0" top="285" width="7">c</text>
2 <text font="34" height="11" left="366" textpieces="0" top="270" width="7">d</text>
2 <text font="34" height="11" left="271" textpieces="0" top="257" width="7">1</text>
2 <text font="34" height="11" left="305" textpieces="0" top="293" width="7">2</text>
2 <text font="35" height="11" left="228" textpieces="0" top="217" width="16">B1</text>
2 <text font="34" height="11" left="497" textpieces="0" top="228" width="7">4</text>
2 <text font="34" height="11" left="408" textpieces="0" top="257" width="7">0</text>
2 <text font="34" height="11" left="559" textpieces="0" top="252" width="7">5</text>
2 <text font="34" height="11" left="530" textpieces="0" top="292" width="7">3</text>
2 <text font="34" height="11" left="424" textpieces="0" top="249" width="7">a</text>
2 <text font="34" height="11" left="469" textpieces="1" top="235" width="65">e          f</text>
2 <text font="34" height="11" left="469" textpieces="0" top="272" width="7">b</text>
2 <text font="34" height="11" left="505" textpieces="0" top="285" width="7">c</text>
2 <text font="34" height="11" left="541" textpieces="0" top="270" width="7">d</text>
2 <text font="34" height="11" left="446" textpieces="0" top="257" width="7">1</text>
2 <text font="34" height="11" left="480" textpieces="1" top="292" width="-204">2                                                   No unique</text>
2 <text font="37" height="9" left="231" textpieces="0" top="306" width="41">end node</text>
2 <text font="39" height="10" left="482" textpieces="0" top="249" width="67">5 is the greatest</text>
2 <text font="39" height="10" left="461" textpieces="0" top="259" width="88">common descendant</text>
2 <text font="38" height="9" left="626" textpieces="0" top="301" width="99">Collapsed to one edge</text>
2 <text font="34" height="11" left="584" textpieces="2" top="152" width="157">0      1                     5</text>
2 <text font="34" height="11" left="602" textpieces="1" top="144" width="64">a         ef</text>
2 <text font="34" height="11" left="680" textpieces="0" top="158" width="22">bcd</text>
2 <text font="35" height="11" left="404" textpieces="1" top="112" width="191">A2                               A3</text>
2 <text font="34" height="11" left="317" textpieces="0" top="122" width="7">4</text>
2 <text font="34" height="11" left="233" textpieces="0" top="152" width="7">0</text>
2 <text font="34" height="11" left="378" textpieces="0" top="147" width="7">5</text>
2 <text font="34" height="11" left="350" textpieces="0" top="187" width="7">3</text>
2 <text font="34" height="11" left="249" textpieces="0" top="144" width="7">a</text>
2 <text font="34" height="11" left="285" textpieces="1" top="130" width="61">e          f</text>
2 <text font="34" height="11" left="292" textpieces="0" top="166" width="7">b</text>
2 <text font="34" height="11" left="323" textpieces="0" top="180" width="7">c</text>
2 <text font="34" height="11" left="361" textpieces="0" top="164" width="7">d</text>
2 <text font="34" height="11" left="271" textpieces="0" top="152" width="7">1</text>
2 <text font="34" height="11" left="299" textpieces="0" top="187" width="7">2</text>
2 <text font="35" height="11" left="228" textpieces="0" top="112" width="16">A1</text>
2 <text font="40" height="9" left="231" textpieces="0" top="189" width="45">No unique</text>
2 <text font="40" height="9" left="231" textpieces="0" top="200" width="45">start node</text>
2 <text font="38" height="9" left="626" textpieces="0" top="195" width="99">Collapsed to one edge</text>
2 <text font="34" height="11" left="497" textpieces="0" top="127" width="7">4</text>
2 <text font="34" height="11" left="409" textpieces="1" top="152" width="152">0                           5</text>
2 <text font="34" height="11" left="526" textpieces="0" top="181" width="7">3</text>
2 <text font="34" height="11" left="425" textpieces="0" top="144" width="7">a</text>
2 <text font="34" height="11" left="468" textpieces="1" top="133" width="61">e          f</text>
2 <text font="34" height="11" left="468" textpieces="0" top="159" width="7">b</text>
2 <text font="34" height="11" left="508" textpieces="0" top="174" width="7">c</text>
2 <text font="34" height="11" left="536" textpieces="0" top="163" width="7">d</text>
2 <text font="34" height="11" left="447" textpieces="0" top="152" width="7">1</text>
2 <text font="34" height="11" left="487" textpieces="0" top="181" width="7">2</text>
2 <text font="40" height="9" left="404" textpieces="0" top="189" width="56">1 is the least</text>
2 <text font="40" height="9" left="404" textpieces="0" top="200" width="80">common ancestor</text>
2 <text font="4" height="15" left="108" textpieces="0" top="448" width="702">Figure 12: Illustrating FindMinSFA: (A) No unique start node for the set X = {3, 4, 5}, (B) No</text>
2 <text font="4" height="15" left="108" textpieces="0" top="468" width="702">unique end node for the set X = {1, 2, 4}, and (C) Set X = {0, 1, 2} has external edge 1  4 incident</text>
2 <text font="4" height="15" left="108" textpieces="0" top="488" width="309">on internal node 1, and has to be included.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="534" width="360">C  Conditional is a KL Minimizer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="574" width="702">KL divergence is similar to a distance metric in that it allows us to say whether or not two probability</text>
2 <text font="4" height="15" left="108" textpieces="1" top="595" width="702">distributions are close. Given two probability distribution ,  :   [0, 1] the KL-divergence is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="615" width="252">denoted KL(||) and is dened as:</text>
2 <text font="4" height="15" left="353" textpieces="0" top="660" width="78">KL(||) =</text>
2 <text font="5" height="11" left="436" textpieces="0" top="683" width="31"></text>
2 <text font="4" height="15" left="471" textpieces="0" top="660" width="56">(x) log</text>
2 <text font="4" height="15" left="531" textpieces="0" top="649" width="32">(x)</text>
2 <text font="4" height="15" left="531" textpieces="0" top="672" width="31">(x)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="713" width="702">The above quantity is only dened for ,  such that (x) &gt; 0 implies that (x) &gt; 0. If  =  then</text>
2 <text font="4" height="15" left="108" textpieces="0" top="733" width="96">KL(||) = 0.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="754" width="677">We justify our choice to retain the probability of each string we select by showing that it is in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="774" width="702">fact a minimizer for a common information theoretic measure, KL-divergence. Given a probability</text>
2 <text font="4" height="15" left="108" textpieces="2" top="794" width="702">distribution  on and a set X  , let |X denote the result of conditioning  on X. Let A be</text>
2 <text font="4" height="15" left="108" textpieces="0" top="815" width="282">the set of all distributions on X. Then,</text>
2 <text font="4" height="15" left="363" textpieces="1" top="851" width="126">KL(|X||)  min</text>
2 <text font="5" height="11" left="463" textpieces="0" top="865" width="26">A</text>
2 <text font="4" height="15" left="492" textpieces="1" top="851" width="318">KL(||)                                 (1)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="894" width="702">That is, selecting the probabilities according to the conditional probability distribution is optimal</text>
2 <text font="4" height="15" left="108" textpieces="1" top="914" width="702">with respect to KL divergence. Eq. 1 follows from the observation that KL(|X||) =  log Z where</text>
2 <text font="4" height="15" left="108" textpieces="0" top="935" width="30">Z =</text>
2 <text font="5" height="11" left="159" textpieces="0" top="942" width="26">xX</text>
2 <text font="4" height="15" left="190" textpieces="0" top="935" width="309">(x). Using the log-sum inequality one has</text>
2 <text font="5" height="11" left="242" textpieces="0" top="1010" width="26">xX</text>
2 <text font="4" height="15" left="272" textpieces="0" top="987" width="56">(x) log</text>
2 <text font="4" height="15" left="333" textpieces="0" top="976" width="33">(x)</text>
2 <text font="4" height="15" left="333" textpieces="0" top="998" width="32">(x)</text>
2 <text font="4" height="15" left="372" textpieces="0" top="986" width="13"></text>
2 <text font="5" height="11" left="402" textpieces="0" top="1010" width="26">xX</text>
2 <text font="4" height="15" left="432" textpieces="2" top="987" width="124">(x)  log    xX</text>
2 <text font="4" height="15" left="561" textpieces="0" top="975" width="33">(x)</text>
2 <text font="5" height="11" left="531" textpieces="0" top="1007" width="26">xX</text>
2 <text font="4" height="15" left="561" textpieces="0" top="999" width="32">(x)</text>
2 <text font="4" height="15" left="607" textpieces="0" top="987" width="68">=  log Z</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">26</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="3" height="19" left="108" textpieces="2" top="110" width="407">D  kis a minimizer (Proposition 3.1)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="150" width="702">There are two observations. The rst is that by normalization, since the probability of every string</text>
2 <text font="4" height="15" left="108" textpieces="1" top="170" width="702">is simply proportional to its probability in Pr[] then the KL divergence is inversely proportional</text>
2 <text font="4" height="15" left="108" textpieces="0" top="190" width="702">to the probability mass retained. Thus, the minimizer must retain as much probability mass as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="211" width="701">possible. The second observation is the following: consider any chunk (Si, s, f ) where s is the single</text>
2 <text font="4" height="15" left="108" textpieces="1" top="231" width="702">start state and f is the nal state. By construction, every path that uses a character from Simust</text>
2 <text font="4" height="15" left="108" textpieces="0" top="251" width="702">enter through s and leave through f . And the higher probability that we place in that state, the</text>
2 <text font="4" height="15" left="108" textpieces="1" top="272" width="702">higher the retained mass. Since kretains the highest probability in each segment, it is indeed the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="292" width="76">minimizer.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="340" width="268">E  Proof of Theorem 3.1</text>
2 <text font="4" height="17" left="108" textpieces="1" top="380" width="702">The starting point is that the following problem is NP-hard: Given vectors x, y  Ql and a xed</text>
2 <text font="4" height="15" left="108" textpieces="3" top="400" width="702">constant   0 for l = 4 and sets of stochastic matrices S1, . . . , SN where each Si is a set of 2 l  l</text>
2 <text font="4" height="15" left="108" textpieces="3" top="421" width="557">matrices, determine if there is a sequence i  {1, 2}N such that Mij Sj and:</text>
2 <text font="4" height="15" left="388" textpieces="3" top="459" width="142">xTMiN   Mi1y  </text>
2 <text font="4" height="15" left="133" textpieces="0" top="496" width="677">We nd a small l such that the claim holds. For this, we start with the results of Bournez</text>
2 <text font="4" height="15" left="108" textpieces="0" top="517" width="702">and Branicky who show that a related problem called the Matrix Mortality problem is NP-hard for</text>
2 <text font="4" height="15" left="108" textpieces="3" top="537" width="702">matrices of size 2  2 [17], where we ask for to nd a selection as above where xTMiN   Mi1y =</text>
2 <text font="4" height="15" left="108" textpieces="1" top="557" width="702">0. Unfortunately, the matrices (Mij) are not stochastic (not even positive). However, using the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="578" width="702">techniques of Turakainen [50] (and Blondel [16]), we can transform the matrices into slightly larger,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="598" width="410">but still constant dimensions, stochastic matrices (l = 4).</text>
2 <text font="4" height="15" left="133" textpieces="0" top="618" width="677">Now, we construct a transducer and chunk structure  such that if it is possible to choose at</text>
2 <text font="4" height="15" left="108" textpieces="1" top="639" width="702">most k = 2 in each chunk with the total probability mass being greater than 2N, then we can</text>
2 <text font="4" height="15" left="108" textpieces="0" top="659" width="702">get a choice for i. Equally, if there exists such a choice for i, then we can nd such a transducer</text>
2 <text font="4" height="15" left="108" textpieces="0" top="679" width="668">representation. So the problem of nding the highest mass representation is NP-hard as well.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="699" width="677">Throughout this reduction, we assume that every edge is assigned a unique character to ensure</text>
2 <text font="4" height="15" left="108" textpieces="0" top="720" width="702">the unique path property. It is straightforward to optimize for a binary alphabet: simply add</text>
2 <text font="4" height="15" left="108" textpieces="0" top="740" width="702">replace each character a sequence of edges with a binary encoding (then make this one chunk). So,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="760" width="382">we omit the emitted string in the transition function.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="781" width="677">Let P (x) denote the probability mass that a string is emitted that passes through the node x.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="801" width="702">We will group nodes together as components of a vector. The start node s has P (s) = 1. Then,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="821" width="387">we construct the vector y by creating nodes v1, . . . , v</text>
2 <text font="5" height="11" left="497" textpieces="2" top="827" width="312">l with a transition ((s, vi), 0) = yi. Thus,</text>
2 <text font="4" height="15" left="108" textpieces="1" top="842" width="702">P (vi) = yi. We need two main gadgets: (1) A gadget to encode matrix multiplication and (2)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="862" width="702">a gadget that intuitively encodes that given two inputs, we can select one or the other, but not</text>
2 <text font="4" height="15" left="108" textpieces="0" top="882" width="702">both. We provide a slightly weaker property: For a xed parameter   0 (we pick  below). We</text>
2 <text font="4" height="15" left="108" textpieces="0" top="903" width="702">construct a gadget that takes as input two nodes x, x and has output two nodes u, u such that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="923" width="606">the probability at u (P (u)) and at u (P (u )) satises the following weak-exclusivity:</text>
2 <text font="4" height="15" left="299" textpieces="1" top="960" width="511">(P (u), P (u )) = (P (x), 0), (0, P (x )), (v, v )                         (2)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="997" width="702">where v  P (x) and v  P (x ). Intuitively, this gadget forces us to choose x or x or not both.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1017" width="658">Notice that if we select both, then for sure the output of each component is smaller than .</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">27</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="41" height="14" left="143" textpieces="1" top="192" width="318">                                                                </text>
2 <text font="4" height="18" left="140" textpieces="0" top="144" width="13">...</text>
2 <text font="24" height="10" left="175" textpieces="0" top="172" width="12">0.5</text>
2 <text font="42" height="16" left="306" textpieces="0" top="117" width="17">M1</text>
2 <text font="42" height="16" left="307" textpieces="0" top="166" width="17">M2</text>
2 <text font="43" height="24" left="258" textpieces="1" top="142" width="129">+          ...</text>
2 <text font="19" height="14" left="112" textpieces="0" top="167" width="7">y</text>
2 <text font="4" height="27" left="115" textpieces="0" top="133" width="0">...</text>
2 <text font="19" height="14" left="162" textpieces="0" top="167" width="7">x</text>
2 <text font="4" height="27" left="165" textpieces="1" top="133" width="56">...       v</text>
2 <text font="4" height="27" left="217" textpieces="0" top="104" width="0">...</text>
2 <text font="19" height="14" left="214" textpieces="0" top="185" width="8">u</text>
2 <text font="4" height="27" left="217" textpieces="0" top="151" width="0">...</text>
2 <text font="24" height="10" left="173" textpieces="0" top="123" width="12">0.5</text>
2 <text font="24" height="10" left="176" textpieces="0" top="139" width="12">0.5</text>
2 <text font="24" height="10" left="176" textpieces="0" top="157" width="12">0.5</text>
2 <text font="19" height="14" left="357" textpieces="0" top="168" width="10">x'</text>
2 <text font="4" height="27" left="360" textpieces="0" top="133" width="0">...</text>
2 <text font="19" height="14" left="410" textpieces="0" top="168" width="13">x''</text>
2 <text font="4" height="27" left="413" textpieces="0" top="133" width="0">...</text>
2 <text font="22" height="12" left="727" textpieces="0" top="111" width="6">1</text>
2 <text font="22" height="12" left="705" textpieces="1" top="135" width="57">0.5         1</text>
2 <text font="22" height="12" left="757" textpieces="0" top="160" width="6">1</text>
2 <text font="19" height="14" left="674" textpieces="0" top="116" width="7">x</text>
2 <text font="19" height="14" left="673" textpieces="0" top="145" width="10">x'</text>
2 <text font="19" height="14" left="795" textpieces="0" top="116" width="8">u</text>
2 <text font="19" height="14" left="795" textpieces="0" top="144" width="10">u'</text>
2 <text font="22" height="12" left="691" textpieces="0" top="187" width="91">Repeated m times</text>
2 <text font="22" height="12" left="702" textpieces="0" top="160" width="15">0.5</text>
2 <text font="19" height="14" left="433" textpieces="0" top="129" width="15">a11</text>
2 <text font="19" height="14" left="434" textpieces="1" top="149" width="35">a21 a22</text>
2 <text font="19" height="14" left="454" textpieces="1" top="129" width="45">a12   x1</text>
2 <text font="19" height="14" left="488" textpieces="0" top="149" width="11">x2</text>
2 <text font="19" height="14" left="525" textpieces="0" top="129" width="11">y1</text>
2 <text font="19" height="14" left="525" textpieces="0" top="149" width="11">y2</text>
2 <text font="9" height="18" left="506" textpieces="0" top="139" width="9">=</text>
2 <text font="19" height="14" left="596" textpieces="0" top="156" width="15">a22</text>
2 <text font="19" height="14" left="654" textpieces="0" top="165" width="11">y2</text>
2 <text font="19" height="14" left="654" textpieces="0" top="122" width="11">y1</text>
2 <text font="19" height="14" left="548" textpieces="0" top="164" width="11">x2</text>
2 <text font="19" height="14" left="548" textpieces="0" top="123" width="11">x1</text>
2 <text font="19" height="14" left="572" textpieces="0" top="138" width="15">a21</text>
2 <text font="19" height="14" left="562" textpieces="0" top="148" width="15">a12</text>
2 <text font="19" height="14" left="594" textpieces="0" top="116" width="15">a11</text>
2 <text font="44" height="12" left="418" textpieces="2" top="188" width="390">A                                                         B                                 C</text>
2 <text font="4" height="15" left="108" textpieces="0" top="224" width="702">Figure 13: Gadgets used in the proof of Theorem 3.1: (A) Overall Reduction. We create one block</text>
2 <text font="4" height="15" left="108" textpieces="1" top="244" width="545">for each of the N sets Si (B) Multiply Gadget (C) Binary Exclusive Gadget</text>
2 <text font="4" height="15" left="133" textpieces="0" top="295" width="677">Assuming these gadgets, the overall construction is shown in Figure 13(A) that illustrates a</text>
2 <text font="4" height="15" left="108" textpieces="0" top="315" width="701">chunk for a single set Si. Each chunk contains two matrix multiply gadgets (representing the two</text>
2 <text font="4" height="15" left="108" textpieces="0" top="335" width="701">matrices in Si) and a large gadget that ensures we either choose one matrix or the other  but not</text>
2 <text font="4" height="15" left="108" textpieces="0" top="356" width="702">elements of both. The input to the chunk is a vector x: in the rst chunk, x = y above. In chunk</text>
2 <text font="4" height="15" left="108" textpieces="2" top="376" width="702">j, x will represent the result of some of choice Mij1   Mi1y. As shown, for each i = 1, . . . , l,</text>
2 <text font="4" height="15" left="108" textpieces="4" top="396" width="702">we send xi to vi with probability 0.5 and xi to ui with probability 0.5. In turn, u is fed to the</text>
2 <text font="4" height="15" left="108" textpieces="2" top="417" width="702">multiply gadget for M1j and v is fed to the multiply gadget for M2j (with  = 1). We ensure</text>
2 <text font="4" height="15" left="108" textpieces="2" top="437" width="702">that we cannot select both vi and uj for any i, j using the exclusive gadget described below. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="457" width="470">output of this chunk is either 0.5Mi1x or 0.5Mi2x or a vector with</text>
2 <text font="5" height="11" left="591" textpieces="1" top="463" width="219">1 norm smaller than . We set</text>
2 <text font="4" height="15" left="108" textpieces="1" top="478" width="702"> &lt; 2N. Given this, property is clear that given any solution to the original problem, we can</text>
2 <text font="4" height="15" left="108" textpieces="0" top="498" width="702">create a solution to this problem. On the other hand, if the solution with highest probability mass</text>
2 <text font="4" height="15" left="108" textpieces="2" top="518" width="702">has mass greater than 2N then it must be a valid solution (since we set  &lt; 2N). Now the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="539" width="58">gadgets:</text>
2 <text font="4" height="15" left="108" textpieces="1" top="582" width="702">The Multiply Gadget  Matrix multiplication can be encoded via a transducer (see Fig. 13(B)).</text>
2 <text font="4" height="15" left="108" textpieces="0" top="602" width="702">Notice that the outputs in the above gadget have the probability of the matrix multiply for 2  2</text>
2 <text font="4" height="15" left="108" textpieces="1" top="623" width="702">matrices. That is, given a matrix A and input nodes x1, . . . , xm, the output nodes yi above are</text>
2 <text font="4" height="15" left="108" textpieces="0" top="643" width="128">such that P (yi) =</text>
2 <text font="5" height="11" left="258" textpieces="0" top="638" width="11">m</text>
2 <text font="5" height="11" left="258" textpieces="0" top="651" width="22">j=0</text>
2 <text font="4" height="15" left="284" textpieces="1" top="643" width="274">AijP (yj). Each edge is a single chunk.</text>
2 <text font="4" height="15" left="108" textpieces="1" top="686" width="702">The Exclusive Gadget  We illustrate the gadget for k = 2. We have two inputs x, x and two</text>
2 <text font="4" height="15" left="108" textpieces="0" top="706" width="702">outputs u, u . Our goal is to ensure the property described by Eq. 2. The gadget is shown in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="727" width="702">Figure 13(C). The chunk here contains the entire gadget, since we can only select k paths, it is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="747" width="458">clear that each iteration of the gadget we get the property that:</text>
2 <text font="4" height="15" left="299" textpieces="0" top="784" width="311">(P (u), P (u )) = (P (x), 0), (0, P (x )), (v, v )</text>
2 <text font="4" height="15" left="108" textpieces="1" top="821" width="701">where v  0.5P (x) and v  0.5P (x ). Repeating the gadget m times (taking m s.t. 2m 2N</text>
2 <text font="4" height="15" left="108" textpieces="0" top="841" width="702">suces). The property we need is that we only select one vector or the other  to ensure this we</text>
2 <text font="4" height="15" left="108" textpieces="1" top="861" width="107">simply place  l</text>
2 <text font="5" height="11" left="210" textpieces="0" top="870" width="6">2</text>
2 <text font="4" height="15" left="230" textpieces="2" top="861" width="580">gadgets: each one says that if ui&gt; 0 = vj = 0 (and vice versa). Observe that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="882" width="702">the resulting gadget is polynomial sized. After concatenating the gadgets together, the end result</text>
2 <text font="4" height="15" left="108" textpieces="3" top="902" width="343">is either a 2NMiN   Mii (a valid result) or its</text>
2 <text font="5" height="11" left="464" textpieces="2" top="907" width="346">1 norm is smaller than 2N (since it messes up</text>
2 <text font="4" height="15" left="108" textpieces="0" top="922" width="222">on at least one of the gadgets).</text>
2 <text font="4" height="15" left="108" textpieces="1" top="965" width="702">Proof of Hardness  We now complete the proof by showing that a problem, called StocAut is</text>
2 <text font="4" height="17" left="108" textpieces="0" top="986" width="702">NP-hard  for a xed size alphabet. Then, we show how to encode this in the Layout problem,</text>
2 <text font="4" height="17" left="108" textpieces="0" top="1006" width="427">thereby proving that Layout is NP-hard for a xed size .</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">28</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="17" left="133" textpieces="1" top="113" width="677">The GenAut Generic automaton problem is the following: Given vectors x, y  Qk for some</text>
2 <text font="4" height="15" left="108" textpieces="2" top="133" width="702">xed k and sets of matrices G1, . . . , GN where each Gi for i = 1, . . . , N is a set of k  k matrices,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="529">the goal is to determine if there is a tuple of natural numbers i such that:</text>
2 <text font="4" height="15" left="331" textpieces="4" top="190" width="255">xTMiN   Mi1y  0 where Mij  Gj</text>
2 <text font="4" height="17" left="133" textpieces="0" top="227" width="677">We are concerned with the related problem StocAut where all matrices and vectors in the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="248" width="702">problem are stochastic. A matrix is stochastic if all entries are positive, and its row sums and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="268" width="702">column sums are 1. A vector is stochastic if each entry is positive and its 1-norm (sum of entries)</text>
2 <text font="4" height="17" left="108" textpieces="0" top="288" width="520">is 1. In StocAut the condition we want to check is slightly generalized:</text>
2 <text font="4" height="15" left="322" textpieces="5" top="329" width="273">xTMiN   Mi1y  k1 where Mij  Gj</text>
2 <text font="4" height="15" left="108" textpieces="0" top="359" width="278">and k is the dimension of the problem.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="393" width="702">Lemma E.1. For xed dimension, k = 2, the GenAut problem is NP-Complete in N even if</text>
2 <text font="4" height="15" left="108" textpieces="0" top="412" width="176">|Gi|  2 for i = 1, . . . , N .</text>
2 <text font="4" height="15" left="108" textpieces="2" top="447" width="702">Proof. This is shown by using the observation that xT  Ay = 0 is NP-hard (exact sequence mortality</text>
2 <text font="4" height="15" left="108" textpieces="7" top="467" width="702">problem [17]) and that xT  Ay = 0 if and only if xT  AyxT  Ay  0. We then observe that yxT is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="487" width="699">such a matrix. More precisely, the following problem is NP-hard: Given a set of values s1, . . . , sN</text>
2 <text font="4" height="15" left="108" textpieces="0" top="508" width="227">is there a set S  [N ] such that</text>
2 <text font="5" height="11" left="356" textpieces="0" top="516" width="48">i=1,...,N</text>
2 <text font="4" height="15" left="409" textpieces="1" top="508" width="164">si= b for some xed b.</text>
2 <text font="4" height="15" left="399" textpieces="0" top="557" width="32">H =</text>
2 <text font="4" height="15" left="455" textpieces="1" top="547" width="38">0   1</text>
2 <text font="4" height="15" left="455" textpieces="1" top="567" width="44">0  1</text>
2 <text font="4" height="15" left="108" textpieces="0" top="603" width="377">It is not hard to check that for any 2  2 A we have:</text>
2 <text font="4" height="15" left="351" textpieces="0" top="648" width="59">HAH =</text>
2 <text font="4" height="15" left="435" textpieces="2" top="638" width="105">0   (a21 a22)</text>
2 <text font="4" height="15" left="435" textpieces="2" top="658" width="112">0  (a21 a22)</text>
2 <text font="4" height="15" left="108" textpieces="1" top="694" width="590">so that HAH = 0 if and only if a21= a22. Then, we create the following matrices:</text>
2 <text font="4" height="15" left="320" textpieces="1" top="739" width="33">Si=</text>
2 <text font="4" height="15" left="377" textpieces="1" top="729" width="43">1   0</text>
2 <text font="4" height="15" left="377" textpieces="1" top="750" width="56">0  s(A)</text>
2 <text font="4" height="15" left="460" textpieces="0" top="739" width="62">and B =</text>
2 <text font="4" height="15" left="547" textpieces="1" top="729" width="31">1  0</text>
2 <text font="4" height="15" left="547" textpieces="1" top="750" width="31">b  1</text>
2 <text font="4" height="15" left="108" textpieces="4" top="786" width="701">Then, denote by I2 the identity matrix. Then, we set: G0 = {HB} and Gi = {Si, I2} for i =</text>
2 <text font="4" height="15" left="108" textpieces="1" top="806" width="702">1, . . . , N . The vectors are x = (1, 1) and y = xT. Then, applying the construction above proves</text>
2 <text font="4" height="15" left="108" textpieces="0" top="826" width="71">the claim.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="860" width="677">We now apply Turakainens technique [50] (we learned of the technique from Blondel [16]) to</text>
2 <text font="4" height="15" left="108" textpieces="0" top="881" width="702">transform the above matrices into slightly larger, but still constant dimensions, that are positive</text>
2 <text font="4" height="17" left="108" textpieces="0" top="901" width="702">and then nally stochastic. First, we dene a further restriction ZeroAut which requires that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="921" width="702">each matrix row/column sum is zero. We prove that this is still NP-complete over slightly larger</text>
2 <text font="4" height="15" left="108" textpieces="0" top="942" width="65">matrices.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="975" width="546">Lemma E.2. For dimension k = 4, the ZeroAut problem is NP-complete.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">29</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="548">Proof. For each matrix M above we create a new 4  4 matrix N as follows:</text>
2 <text font="4" height="15" left="364" textpieces="0" top="169" width="32">N =</text>
2 <text font="4" height="7" left="401" textpieces="0" top="147" width="14"></text>
2 <text font="4" height="7" left="401" textpieces="0" top="177" width="14"></text>
2 <text font="4" height="15" left="438" textpieces="3" top="149" width="94">0       0    0</text>
2 <text font="4" height="15" left="426" textpieces="2" top="169" width="106">(x)   M   0</text>
2 <text font="4" height="15" left="423" textpieces="2" top="190" width="109">0(x)  (x)  0</text>
2 <text font="4" height="7" left="539" textpieces="0" top="147" width="14"></text>
2 <text font="4" height="7" left="539" textpieces="0" top="177" width="14"></text>
2 <text font="4" height="15" left="108" textpieces="0" top="216" width="702">we choose ,  to be vectors such that the row,column sums are zero. Then, we take the original</text>
2 <text font="4" height="15" left="108" textpieces="4" top="236" width="653">x and create x1= (0, x, 0) and y1= (0, yT, 0)T. It follows then that for any set of matrices:</text>
2 <text font="4" height="15" left="400" textpieces="2" top="267" width="47">x1  N yT</text>
2 <text font="5" height="11" left="440" textpieces="0" top="274" width="6">1</text>
2 <text font="4" height="15" left="455" textpieces="0" top="267" width="59">= xM yT</text>
2 <text font="4" height="15" left="108" textpieces="0" top="299" width="702">Thus, we have shown the stronger claim that all products are equal and so it directly follows that</text>
2 <text font="4" height="15" left="108" textpieces="0" top="319" width="371">the corresponding decision problem is NP-complete.</text>
2 <text font="4" height="17" left="133" textpieces="0" top="352" width="677">We dene StocAut to be the restriction that all matrices are stochastic (as above) and we</text>
2 <text font="4" height="15" left="108" textpieces="0" top="372" width="271">check a slightly generalized condition:</text>
2 <text font="4" height="15" left="380" textpieces="3" top="403" width="157">xTMiN   Mi1y  k1</text>
2 <text font="4" height="15" left="108" textpieces="1" top="435" width="124">where Mij  Rk.7</text>
2 <text font="4" height="17" left="108" textpieces="0" top="464" width="546">Lemma E.3. The problem StocAut is NP-complete for matrices of 4  4.</text>
2 <text font="4" height="17" left="108" textpieces="0" top="493" width="702">Proof. We rst show that we may assume that the vectors from the ZeroAut problem are stochas-</text>
2 <text font="4" height="17" left="108" textpieces="0" top="513" width="702">tic. Let 1 be the all ones vector in Rk. Observe that for any Z such that the row and column sums</text>
2 <text font="4" height="17" left="108" textpieces="0" top="534" width="405">are 0 (as is each matrix in the input of ZeroAut) then:</text>
2 <text font="4" height="15" left="355" textpieces="2" top="565" width="207">(x + 1)TZ(y + 1) = xTZy</text>
2 <text font="4" height="15" left="108" textpieces="3" top="596" width="701">for any value of  since 1TZ = Z1 = 0 the zero vector. Take  = | miniminz=x,yzi|. Thus, we can</text>
2 <text font="4" height="15" left="108" textpieces="0" top="617" width="702">take x + 1 and y + 1 and preserve the product (which are both entry-wise positive). Then, we</text>
2 <text font="4" height="15" left="108" textpieces="0" top="637" width="417">can scale both x + 1 and y + 1 by any positive constant:</text>
2 <text font="4" height="15" left="374" textpieces="2" top="668" width="170">(x)TQ(y) = xTQy</text>
2 <text font="4" height="15" left="108" textpieces="0" top="700" width="701">So the sign is preserved if ,  &gt; 0. And we can assume without loss of generality that both x, y</text>
2 <text font="4" height="15" left="108" textpieces="0" top="720" width="311">are stochastic by scaling by their respective</text>
2 <text font="5" height="11" left="431" textpieces="5" top="725" width="379">1 norms. (If either x 1 = 0 or y 1 = 0 the problem</text>
2 <text font="4" height="15" left="108" textpieces="0" top="740" width="556">is trivially satised: the product is 0 and since they must be the zero vector.)</text>
2 <text font="4" height="15" left="133" textpieces="0" top="761" width="677">We now show how to achieve the condition of stochastic matrices. First, we show how to achieve</text>
2 <text font="4" height="15" left="108" textpieces="1" top="781" width="702">positive matrices. To do this, let Q be the all ones matrix of 4  4 (Qij = 1). Then let   0 be</text>
2 <text font="4" height="15" left="108" textpieces="0" top="801" width="702">such that for all matrices M + Q  0 entrywise. Then, for each matrix M replace it with a new</text>
2 <text font="4" height="15" left="108" textpieces="0" top="822" width="149">matrix N dened as:</text>
2 <text font="4" height="15" left="379" textpieces="1" top="842" width="160">N = (k)1(M + Q)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="869" width="253">Since M Q = 0, the following holds:</text>
2 <text font="4" height="15" left="292" textpieces="0" top="915" width="16">xT</text>
2 <text font="5" height="11" left="319" textpieces="0" top="898" width="10">N</text>
2 <text font="5" height="11" left="314" textpieces="0" top="938" width="47">i=1(Mi</text>
2 <text font="4" height="15" left="366" textpieces="0" top="915" width="144">+ Q)y = (k)mxT</text>
2 <text font="5" height="11" left="521" textpieces="0" top="898" width="10">N</text>
2 <text font="5" height="11" left="517" textpieces="0" top="938" width="21">i=1</text>
2 <text font="4" height="15" left="540" textpieces="0" top="915" width="84">Miy + xtQy</text>
2 <text font="4" height="15" left="108" textpieces="1" top="962" width="702">Thus, the original product is positive if and only if the modied product is bigger than k1proving</text>
2 <text font="4" height="15" left="108" textpieces="0" top="983" width="71">the claim.</text>
2 <text font="6" height="8" left="127" textpieces="0" top="1007" width="682">7Although unnecessary for our purpose we observe that with r repetitions of the problem, one can drive the</text>
2 <text font="7" height="12" left="108" textpieces="1" top="1026" width="361">constant down to kr. Thus, the constant here is arbitrary.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">30</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="3" height="19" left="108" textpieces="1" top="110" width="157">F  Algorithms</text>
2 <text font="4" height="15" left="108" textpieces="0" top="163" width="86">Notations:</text>
2 <text font="4" height="17" left="108" textpieces="0" top="183" width="312">G = (V, E, s, f, ), the Staccato data SFA</text>
2 <text font="4" height="15" left="108" textpieces="1" top="203" width="326">Q = (VQ, EQ, sQ, FQ, Q), the dictionary DFA</text>
2 <text font="4" height="15" left="108" textpieces="1" top="224" width="416">D = {(fQ FQ, term)}, the dictionary terms (hash table)</text>
2 <text font="4" height="15" left="108" textpieces="1" top="244" width="480">AugSts = {(vQ VQ, P ostingSet)}, augmented states (hash table)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="264" width="354">I = {(term, P ostingSet)}, the index (hash table)</text>
2 <text font="4" height="15" left="300" textpieces="0" top="320" width="319">Figure 14: Notations for Algorithms 3 and 4</text>
2 <text font="4" height="15" left="133" textpieces="0" top="357" width="677">Here we present the algorithm for constructing the inverted index for a given SFA, as referred</text>
2 <text font="4" height="15" left="108" textpieces="0" top="378" width="422">to in Section 4. The notations used are listed in Figure 14.</text>
2 <text font="4" height="17" left="121" textpieces="0" top="419" width="516">Algorithm 3: The dynamic program for Staccato index construction</text>
2 <text font="4" height="15" left="133" textpieces="0" top="441" width="236">e  E with parent edges e  E</text>
2 <text font="4" height="15" left="164" textpieces="4" top="461" width="318">fQ FQ, AugStspar(f ) = eAugStse(fQ)</text>
2 <text font="4" height="15" left="170" textpieces="1" top="482" width="255">AugStse= RunDF A(AugStspar, e)</text>
2 <text font="4" height="15" left="133" textpieces="0" top="503" width="76">otherwise,</text>
2 <text font="4" height="15" left="164" textpieces="1" top="522" width="156">fQ FQ, AugStse(f</text>
2 <text font="5" height="11" left="322" textpieces="0" top="529" width="48">Q) = </text>
2 <text font="4" height="15" left="133" textpieces="0" top="572" width="677">The construction, presented in Algorithms 3 and 4, is similar to automata composition. The</text>
2 <text font="4" height="15" left="108" textpieces="0" top="592" width="702">dictionary of terms is rst compressed into a trie-automaton [29] with multiple nal states, each</text>
2 <text font="4" height="15" left="108" textpieces="0" top="612" width="702">corresponding to a term. Then, we walk through the data SFA (using a dynamic program on the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="633" width="702">SFAs graph) and obtain the locations (postings) where any dictionary term starts. A key thing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="653" width="702">to note here is that terms can straddle mutiple SFA edges, which needs to be tracked. We pass</text>
2 <text font="4" height="15" left="108" textpieces="0" top="673" width="702">information about such multi-edge terms through sets of augmented states, which store pairs of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="693" width="702">the query DFAs state and possible postings. When the DFA reaches a nal state (i.e., a term has</text>
2 <text font="4" height="15" left="108" textpieces="0" top="714" width="450">been seen), the corresponding postings are added to the index.</text>
2 <text font="3" height="19" left="108" textpieces="1" top="762" width="292">G  Implementation Details</text>
2 <text font="4" height="15" left="108" textpieces="0" top="802" width="702">Each line of a document corresponds to one transducer, which is stored as such in the FullSFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="822" width="702">approach. k-MAP stores a ranked list of strings for each line after inference on the transducer. In</text>
2 <text font="4" height="14" left="108" textpieces="0" top="845" width="702">Staccato, each line corresponds to a graph of chunks, where each chunk is a ranked list of strings.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="863" width="702">These data are stored inside the RDBMS with a relational schema, shown in Table 5. There is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="883" width="702">one master table per dataset, which contains the auxiliary information like document name, line</text>
2 <text font="4" height="15" left="108" textpieces="0" top="904" width="481">number, etc., and there are separate data tables for each approach.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">31</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="121" textpieces="0" top="252" width="249">Algorithm 4: RunDFA(AugSts,e)</text>
2 <text font="4" height="15" left="133" textpieces="1" top="277" width="306">for each string pi on e, i = 0 to k  1 do</text>
2 <text font="4" height="15" left="159" textpieces="0" top="296" width="243">SO  {(0, 0)} //{(State, Oset)}</text>
2 <text font="4" height="15" left="159" textpieces="1" top="316" width="339">for each character cj in p, j = 0 to |p|  1 do</text>
2 <text font="4" height="15" left="184" textpieces="0" top="334" width="74">N SO  </text>
2 <text font="4" height="15" left="184" textpieces="0" top="354" width="142">for each t  SO do</text>
2 <text font="4" height="15" left="209" textpieces="1" top="372" width="156">N xt  Q(t.State, cj)</text>
2 <text font="4" height="15" left="209" textpieces="0" top="393" width="121">if N xt = 0 then</text>
2 <text font="4" height="15" left="234" textpieces="0" top="411" width="247">N SO  N SO  (N xt, t.Of f set)</text>
2 <text font="4" height="15" left="234" textpieces="1" top="431" width="132">if N xt  FQthen</text>
2 <text font="4" height="15" left="259" textpieces="0" top="450" width="315">I(D(N xt))  I(D(N xt))  (e, i, t.Of f set)</text>
2 <text font="4" height="15" left="184" textpieces="0" top="485" width="198">SO  N SO  {(0, j + 1)}</text>
2 <text font="4" height="15" left="159" textpieces="0" top="509" width="150">for each r  SO do</text>
2 <text font="4" height="15" left="184" textpieces="0" top="530" width="141">if r.State = 0 then</text>
2 <text font="4" height="15" left="209" textpieces="0" top="548" width="431">N AugSts(r.State)  N AugSts(r.State)  {(e, i, r.Of f set)}</text>
2 <text font="4" height="15" left="159" textpieces="0" top="579" width="181">for each d  AugSts do</text>
2 <text font="4" height="15" left="184" textpieces="0" top="596" width="108">Cur  d.State</text>
2 <text font="4" height="15" left="184" textpieces="1" top="617" width="339">for each character cj in p, j = 0 to |p|  1 do</text>
2 <text font="4" height="15" left="209" textpieces="0" top="635" width="145">N xt  (t.State, cj)</text>
2 <text font="4" height="15" left="209" textpieces="0" top="655" width="121">if N xt = 0 then</text>
2 <text font="4" height="15" left="234" textpieces="0" top="673" width="82">Cur = N xt</text>
2 <text font="4" height="15" left="234" textpieces="1" top="693" width="132">if N xt  FQthen</text>
2 <text font="4" height="15" left="259" textpieces="0" top="713" width="219">for each l  d.P ostingSet do</text>
2 <text font="4" height="15" left="284" textpieces="0" top="732" width="232">I(D(N xt))  I(D(N xt))  {l}</text>
2 <text font="4" height="15" left="209" textpieces="0" top="764" width="30">else</text>
2 <text font="4" height="15" left="234" textpieces="0" top="782" width="242">break //DFA dies reading string</text>
2 <text font="4" height="15" left="209" textpieces="0" top="807" width="136">if j = |p|  1 then</text>
2 <text font="4" height="15" left="234" textpieces="0" top="827" width="219">for each l  d.P ostingSet do</text>
2 <text font="4" height="15" left="259" textpieces="0" top="845" width="290">N AugSts(Cur)  N AugSts(Cur)  {l}</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">32</text>
=============================== PAGE ===================================
=============================== COL ===================================
1 <text font="4" height="15" left="134" textpieces="1" top="122" width="190">Approach     Table Name</text>
1 <text font="4" height="15" left="438" textpieces="0" top="111" width="74">Attributes</text>
1 <text font="4" height="15" left="615" textpieces="0" top="122" width="93">Primary Key</text>
1 <text font="4" height="15" left="353" textpieces="1" top="132" width="162">Name            Type</text>
1 <text font="4" height="15" left="166" textpieces="1" top="177" width="158">-         MasterData</text>
1 <text font="4" height="15" left="353" textpieces="1" top="156" width="202">DataKey        INTEGER</text>
1 <text font="4" height="15" left="615" textpieces="2" top="177" width="-25">DataKey                                              DocName       VARCHAR(50)</text>
1 <text font="4" height="15" left="353" textpieces="1" top="197" width="202">SFANum        INTEGER</text>
1 <text font="4" height="15" left="142" textpieces="1" top="242" width="180">k-MAP      kMAPData</text>
1 <text font="4" height="15" left="353" textpieces="1" top="221" width="202">DataKey        INTEGER</text>
1 <text font="4" height="15" left="615" textpieces="2" top="242" width="-60">DataKey, LineNum                                                         LineNum        INTEGER</text>
1 <text font="4" height="15" left="353" textpieces="1" top="262" width="172">Data            TEXT</text>
1 <text font="4" height="15" left="353" textpieces="1" top="282" width="189">LogProb         FLOAT8</text>
1 <text font="4" height="15" left="139" textpieces="1" top="317" width="189">FullSFA     FullSFAData</text>
1 <text font="4" height="15" left="353" textpieces="1" top="307" width="202">DataKey        INTEGER</text>
1 <text font="4" height="15" left="615" textpieces="0" top="317" width="64">DataKey</text>
1 <text font="4" height="15" left="353" textpieces="1" top="327" width="156">SFABlob        OID</text>
1 <text font="4" height="14" left="127" textpieces="0" top="416" width="77">Staccato</text>
1 <text font="4" height="15" left="233" textpieces="0" top="392" width="96">StaccatoData</text>
1 <text font="4" height="15" left="353" textpieces="1" top="352" width="202">DataKey        INTEGER</text>
1 <text font="4" height="15" left="615" textpieces="0" top="384" width="159">DataKey, ChunkNum,</text>
1 <text font="4" height="15" left="615" textpieces="0" top="404" width="66">LineNum</text>
1 <text font="4" height="15" left="353" textpieces="1" top="372" width="202">ChunkNum      INTEGER</text>
1 <text font="4" height="15" left="353" textpieces="1" top="392" width="202">LineNum        INTEGER</text>
1 <text font="4" height="15" left="353" textpieces="1" top="413" width="172">Data            TEXT</text>
1 <text font="4" height="15" left="353" textpieces="1" top="433" width="189">LogProb         FLOAT8</text>
1 <text font="4" height="15" left="228" textpieces="0" top="464" width="107">StaccatoGraph</text>
1 <text font="4" height="15" left="353" textpieces="1" top="453" width="202">DataKey        INTEGER</text>
1 <text font="4" height="15" left="615" textpieces="0" top="463" width="64">DataKey</text>
1 <text font="4" height="15" left="353" textpieces="1" top="474" width="156">GraphBlob      OID</text>
1 <text font="4" height="15" left="166" textpieces="1" top="508" width="163">-        GroundTruth</text>
1 <text font="4" height="15" left="353" textpieces="1" top="498" width="202">DataKey        INTEGER</text>
1 <text font="4" height="15" left="615" textpieces="0" top="508" width="64">DataKey</text>
1 <text font="4" height="15" left="353" textpieces="1" top="519" width="172">Data            TEXT</text>
2 <text font="4" height="15" left="285" textpieces="0" top="553" width="348">Table 5: Relational schema for storing SFA data</text>
2 <text font="3" height="19" left="108" textpieces="1" top="599" width="285">H  Extended Experiments</text>
2 <text font="4" height="15" left="108" textpieces="0" top="639" width="702">We now present more experimental results relating to runtimes and answer quality for the lescans,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="659" width="702">as well as some aspects of the inverted indexing. The queries we use are listed in Table 6, along</text>
2 <text font="4" height="15" left="108" textpieces="0" top="680" width="565">with the number of ground truth answers for each on their respective datasets.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="722" width="228">H.1  Recall and Runtime</text>
2 <text font="4" height="15" left="108" textpieces="0" top="754" width="702">Table 7 presents the precision and recall results of the queries, while Table 8 presents the respective</text>
2 <text font="4" height="15" left="108" textpieces="0" top="775" width="702">runtime results. The values of the parameters are m = 40, k = 50 and N umAns = 100. As in</text>
2 <text font="4" height="17" left="108" textpieces="0" top="795" width="702">Section 5, here too we see that Staccato lies between k-MAP and FullSFA on both recall and</text>
2 <text font="4" height="15" left="108" textpieces="0" top="815" width="702">runtime. The precision too exhibits a similar trend. Again, the FullSFA approach is upto three</text>
2 <text font="4" height="15" left="108" textpieces="0" top="836" width="702">orders of magnitude slower than MAP but achieves perfect recall on most queries, though precision</text>
2 <text font="4" height="17" left="108" textpieces="0" top="856" width="702">is lower. Interestingly, on some queries in the DB dataset (e.g., DB3 and DB6), Staccato recall is</text>
2 <text font="4" height="15" left="108" textpieces="0" top="876" width="702">close to 1.0 while the runtime is about two orders of magnitude lower than FullSFA. Another thing</text>
2 <text font="4" height="17" left="108" textpieces="0" top="897" width="702">to note is that the recall increase for k-MAP and Staccato (over MAP) is more pronounced in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="917" width="702">DB and LT than CA. We can also see that keyword queries can have lower recall than some regex</text>
2 <text font="4" height="15" left="108" textpieces="0" top="937" width="205">queries (e.g., LT3 and DB2).</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">33</text>
=============================== PAGE ===================================
=============================== COL ===================================
1 <text font="4" height="15" left="276" textpieces="3" top="329" width="366">Dataset  S.No.         Query         # in Truth</text>
1 <text font="4" height="15" left="292" textpieces="0" top="415" width="24">CA</text>
1 <text font="4" height="15" left="365" textpieces="2" top="354" width="245">1          Attorney            28</text>
1 <text font="4" height="15" left="365" textpieces="2" top="374" width="250">2        Commission          128</text>
1 <text font="4" height="15" left="365" textpieces="2" top="394" width="245">3        employment          73</text>
1 <text font="4" height="15" left="365" textpieces="2" top="415" width="245">4         President            14</text>
1 <text font="4" height="15" left="365" textpieces="2" top="435" width="245">5       United States         52</text>
1 <text font="4" height="15" left="365" textpieces="2" top="455" width="245">6    Public Law (8|9)\d       55</text>
1 <text font="4" height="15" left="365" textpieces="2" top="476" width="245">7      U.S.C. 2\d\d\d         25</text>
1 <text font="4" height="15" left="292" textpieces="0" top="561" width="24">DB</text>
1 <text font="4" height="15" left="365" textpieces="2" top="500" width="245">1          accuracy            65</text>
1 <text font="4" height="15" left="365" textpieces="2" top="520" width="245">2         condence           36</text>
1 <text font="4" height="15" left="365" textpieces="2" top="541" width="245">3          database            43</text>
1 <text font="4" height="15" left="365" textpieces="2" top="561" width="245">4           lineage             83</text>
1 <text font="4" height="15" left="365" textpieces="2" top="581" width="245">5            Trio              68</text>
1 <text font="4" height="15" left="365" textpieces="2" top="602" width="245">6         Sec(\x)  d           33</text>
1 <text font="4" height="15" left="365" textpieces="2" top="622" width="245">7        \x\x\x\d\d          47</text>
1 <text font="4" height="15" left="293" textpieces="0" top="708" width="21">LT</text>
1 <text font="4" height="15" left="365" textpieces="2" top="647" width="245">1        Brinkmann           92</text>
1 <text font="4" height="15" left="365" textpieces="2" top="667" width="245">2           Hitler              12</text>
1 <text font="4" height="15" left="365" textpieces="2" top="687" width="245">3         Jonathan            18</text>
1 <text font="4" height="15" left="365" textpieces="2" top="708" width="245">4          Kerouac            21</text>
1 <text font="4" height="15" left="365" textpieces="2" top="728" width="241">5        Third Reich           7</text>
1 <text font="4" height="15" left="365" textpieces="2" top="748" width="245">6       19\d\d, \d\d          32</text>
1 <text font="4" height="15" left="365" textpieces="2" top="768" width="245">7       spontan(\x)          99</text>
2 <text font="4" height="15" left="299" textpieces="0" top="803" width="315">Table 6: Queries and ground truth numbers</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">34</text>
=============================== PAGE ===================================
=============================== COL ===================================
1 <text font="4" height="15" left="258" textpieces="0" top="325" width="44">Query</text>
1 <text font="4" height="15" left="458" textpieces="0" top="315" width="69">Approach</text>
1 <text font="4" height="15" left="339" textpieces="3" top="335" width="321">MAP     k-MAP    FullSFA   Staccato</text>
1 <text font="4" height="15" left="264" textpieces="4" top="360" width="390">CA1    1.00/0.93  1.00/0.93  0.28/1.00    0.87/0.96</text>
1 <text font="4" height="15" left="264" textpieces="4" top="381" width="390">CA2    1.00/0.78  1.00/0.78  1.00/0.78    1.00/0.78</text>
1 <text font="4" height="15" left="264" textpieces="4" top="402" width="390">CA3    1.00/0.90  1.00/0.90  0.73/1.00    0.97/0.93</text>
1 <text font="4" height="15" left="264" textpieces="4" top="423" width="390">CA4    1.00/0.79  1.00/0.79  0.14/1.00    0.85/0.79</text>
1 <text font="4" height="15" left="264" textpieces="4" top="444" width="390">CA5    1.00/0.77  1.00/0.79  0.52/1.00    1.00/0.88</text>
1 <text font="4" height="15" left="264" textpieces="4" top="465" width="390">CA6    1.00/0.87  1.00/0.96  0.55/1.00    1.00/0.98</text>
1 <text font="4" height="15" left="264" textpieces="4" top="486" width="390">CA7    1.00/0.28  1.00/0.52  0.25/1.00    0.50/0.80</text>
1 <text font="4" height="15" left="264" textpieces="4" top="510" width="390">DB1    1.00/0.58  0.98/0.93  0.65/1.00    0.95/0.97</text>
1 <text font="4" height="15" left="264" textpieces="4" top="531" width="390">DB2    0.00/0.00  0.87/0.19  0.36/1.00    0.90/0.53</text>
1 <text font="4" height="15" left="264" textpieces="4" top="552" width="390">DB3    0.85/0.67  0.87/0.79  0.43/1.00    0.90/1.00</text>
1 <text font="4" height="15" left="264" textpieces="4" top="573" width="390">DB4    0.97/0.91  0.96/0.93  0.82/0.99    0.85/0.95</text>
1 <text font="4" height="15" left="264" textpieces="4" top="594" width="390">DB5    0.93/0.75  0.90/0.95  0.67/0.99    0.79/0.96</text>
1 <text font="4" height="15" left="264" textpieces="4" top="615" width="390">DB6    0.96/0.76  0.96/0.81  0.33/1.00    0.40/0.96</text>
1 <text font="4" height="15" left="264" textpieces="4" top="636" width="390">DB7    0.91/0.85  0.73/0.89  0.44/0.94    0.42/0.89</text>
1 <text font="4" height="15" left="266" textpieces="4" top="660" width="388">LT1    0.96/0.87  0.96/0.90  0.92/1.00    0.94/0.91</text>
1 <text font="4" height="15" left="266" textpieces="4" top="681" width="388">LT2    1.00/0.92  1.00/1.00  0.12/1.00    0.12/1.00</text>
1 <text font="4" height="15" left="266" textpieces="4" top="702" width="388">LT3    1.00/0.11  1.00/0.17  0.18/1.00    0.94/0.83</text>
1 <text font="4" height="15" left="266" textpieces="4" top="723" width="388">LT4    0.81/0.62  0.86/0.90  0.21/1.00    0.74/0.95</text>
1 <text font="4" height="15" left="266" textpieces="4" top="744" width="388">LT5    1.00/0.29  1.00/1.00  0.07/1.00    1.00/1.00</text>
1 <text font="4" height="15" left="266" textpieces="4" top="765" width="388">LT6    0.77/0.65  0.76/0.67  0.31/0.97    0.26/0.81</text>
1 <text font="4" height="15" left="266" textpieces="4" top="786" width="388">LT7    0.84/0.88  0.83/0.88  0.83/0.88    0.83/0.88</text>
2 <text font="4" height="15" left="328" textpieces="0" top="820" width="257">Table 7: Precision and recall results</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">35</text>
=============================== PAGE ===================================
=============================== COL ===================================
1 <text font="4" height="15" left="283" textpieces="0" top="325" width="44">Query</text>
1 <text font="4" height="15" left="458" textpieces="0" top="315" width="69">Approach</text>
1 <text font="4" height="15" left="350" textpieces="3" top="335" width="285">MAP  k-MAP  FullSFA   Staccato</text>
1 <text font="4" height="15" left="289" textpieces="4" top="360" width="322">CA1    0.17     0.82     81.54        4.38</text>
1 <text font="4" height="15" left="289" textpieces="4" top="381" width="322">CA2    0.17     0.96     91.84        4.93</text>
1 <text font="4" height="15" left="289" textpieces="4" top="402" width="322">CA3    0.17     0.96     91.85        4.94</text>
1 <text font="4" height="15" left="289" textpieces="4" top="423" width="322">CA4    0.17     0.89     86.72        4.63</text>
1 <text font="4" height="15" left="289" textpieces="4" top="444" width="322">CA5    0.18     1.16     106.17       5.97</text>
1 <text font="4" height="15" left="289" textpieces="4" top="465" width="322">CA6    0.18     1.17     125.63       5.98</text>
1 <text font="4" height="15" left="289" textpieces="4" top="486" width="322">CA7    0.18     1.05     150.35       5.40</text>
1 <text font="4" height="15" left="289" textpieces="4" top="510" width="322">DB1    0.07     0.44     56.42        1.61</text>
1 <text font="4" height="15" left="289" textpieces="4" top="531" width="322">DB2    0.07     0.51     62.89        1.81</text>
1 <text font="4" height="15" left="289" textpieces="4" top="552" width="322">DB3    0.07     0.43     54.92        1.59</text>
1 <text font="4" height="15" left="289" textpieces="4" top="573" width="322">DB4    0.07     0.40     51.45        1.48</text>
1 <text font="4" height="15" left="289" textpieces="4" top="594" width="322">DB5    0.07     0.42     40.72        1.21</text>
1 <text font="4" height="15" left="289" textpieces="4" top="615" width="322">DB6    0.07     0.35     619.31       1.39</text>
1 <text font="4" height="15" left="289" textpieces="4" top="636" width="322">DB7    0.07     0.31    1738.78      1.37</text>
1 <text font="4" height="15" left="291" textpieces="4" top="660" width="320">LT1    0.14     0.73     83.78        3.27</text>
1 <text font="4" height="15" left="291" textpieces="4" top="681" width="320">LT2    0.13     0.59     69.68        2.72</text>
1 <text font="4" height="15" left="291" textpieces="4" top="702" width="320">LT3    0.14     0.71     79.76        3.10</text>
1 <text font="4" height="15" left="291" textpieces="4" top="723" width="320">LT4    0.14     0.65     74.58        2.90</text>
1 <text font="4" height="15" left="291" textpieces="4" top="744" width="320">LT5    0.14     0.85     93.35        3.72</text>
1 <text font="4" height="15" left="291" textpieces="4" top="765" width="320">LT6    0.14     1.02     155.45       4.52</text>
1 <text font="4" height="15" left="291" textpieces="4" top="786" width="320">LT7    0.15     1.00     887.19       4.23</text>
2 <text font="4" height="15" left="271" textpieces="0" top="820" width="369">Table 8: Runtime results. Runtimes are in seconds.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">36</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="1" height="16" left="108" textpieces="1" top="112" width="262">H.2  Precision and F-1 Score</text>
2 <text font="4" height="15" left="108" textpieces="0" top="144" width="702">Though our focus is on recall-sensitive applications, we also study how the precision is aected</text>
2 <text font="4" height="15" left="108" textpieces="0" top="164" width="702">when we vary m and k. For the same queries and parameter setting as in Figure 6, we plot the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="185" width="552">precision and F-1 score of the answers obtained. Figure 15 shows the results.</text>
2 <text font="23" height="9" left="265" textpieces="1" top="532" width="195">                                                                 </text>
2 <text font="45" height="9" left="272" textpieces="4" top="362" width="183">1 10     25         50         75        100</text>
2 <text font="45" height="9" left="265" textpieces="0" top="351" width="5">0</text>
2 <text font="45" height="9" left="257" textpieces="0" top="326" width="13">0.2</text>
2 <text font="45" height="9" left="257" textpieces="0" top="300" width="13">0.4</text>
2 <text font="45" height="9" left="257" textpieces="0" top="274" width="13">0.6</text>
2 <text font="45" height="9" left="257" textpieces="0" top="249" width="13">0.8</text>
2 <text font="45" height="9" left="265" textpieces="0" top="223" width="5">1</text>
2 <text font="46" height="10" left="308" textpieces="0" top="376" width="109">k - # Paths Parameter</text>
2 <text font="46" height="10" left="254" textpieces="0" top="316" width="0">Precision</text>
2 <text font="47" height="12" left="433" textpieces="1" top="344" width="229">A1                                                  A2</text>
2 <text font="45" height="9" left="488" textpieces="4" top="362" width="183">1 10     25         50         75        100</text>
2 <text font="45" height="9" left="481" textpieces="0" top="351" width="5">0</text>
2 <text font="45" height="9" left="473" textpieces="0" top="326" width="13">0.2</text>
2 <text font="45" height="9" left="473" textpieces="0" top="300" width="13">0.4</text>
2 <text font="45" height="9" left="473" textpieces="0" top="274" width="13">0.6</text>
2 <text font="45" height="9" left="473" textpieces="0" top="249" width="13">0.8</text>
2 <text font="45" height="9" left="481" textpieces="0" top="223" width="5">1</text>
2 <text font="46" height="10" left="524" textpieces="0" top="376" width="109">k - # Paths Parameter</text>
2 <text font="46" height="10" left="470" textpieces="0" top="318" width="0">F-1 Score</text>
2 <text font="45" height="9" left="272" textpieces="4" top="535" width="183">1 10     25         50         75        100</text>
2 <text font="45" height="9" left="265" textpieces="0" top="524" width="5">0</text>
2 <text font="45" height="9" left="257" textpieces="0" top="499" width="13">0.2</text>
2 <text font="45" height="9" left="257" textpieces="0" top="473" width="13">0.4</text>
2 <text font="45" height="9" left="257" textpieces="0" top="447" width="13">0.6</text>
2 <text font="45" height="9" left="257" textpieces="0" top="422" width="13">0.8</text>
2 <text font="45" height="9" left="265" textpieces="0" top="396" width="5">1</text>
2 <text font="46" height="10" left="308" textpieces="0" top="549" width="109">k - # Paths Parameter</text>
2 <text font="46" height="10" left="254" textpieces="0" top="489" width="0">Precision</text>
2 <text font="45" height="9" left="488" textpieces="4" top="535" width="183">1 10     25         50         75        100</text>
2 <text font="45" height="9" left="481" textpieces="0" top="524" width="5">0</text>
2 <text font="45" height="9" left="473" textpieces="0" top="499" width="13">0.2</text>
2 <text font="45" height="9" left="473" textpieces="0" top="473" width="13">0.4</text>
2 <text font="45" height="9" left="473" textpieces="0" top="447" width="13">0.6</text>
2 <text font="45" height="9" left="473" textpieces="0" top="422" width="13">0.8</text>
2 <text font="45" height="9" left="481" textpieces="0" top="396" width="5">1</text>
2 <text font="46" height="10" left="524" textpieces="0" top="549" width="109">k - # Paths Parameter</text>
2 <text font="46" height="10" left="470" textpieces="0" top="489" width="0">F-1 Score</text>
2 <text font="31" height="9" left="295" textpieces="0" top="250" width="25">KMAP</text>
2 <text font="31" height="9" left="295" textpieces="0" top="261" width="5">1</text>
2 <text font="31" height="9" left="295" textpieces="0" top="272" width="10">10</text>
2 <text font="31" height="9" left="295" textpieces="0" top="284" width="10">40</text>
2 <text font="47" height="12" left="649" textpieces="1" top="516" width="-203">B2                                                         B1</text>
2 <text font="47" height="12" left="649" textpieces="0" top="343" width="13">A2</text>
2 <text font="45" height="9" left="297" textpieces="0" top="261" width="30">k-MAP</text>
2 <text font="45" height="9" left="296" textpieces="0" top="272" width="66">STACCATO m 10</text>
2 <text font="45" height="9" left="296" textpieces="0" top="284" width="66">STACCATO m 40</text>
2 <text font="31" height="9" left="295" textpieces="0" top="295" width="15">100</text>
2 <text font="31" height="9" left="295" textpieces="0" top="307" width="17">Max</text>
2 <text font="31" height="9" left="295" textpieces="0" top="318" width="33">FullSFA</text>
2 <text font="45" height="9" left="296" textpieces="0" top="297" width="72">STACCATO m 100</text>
2 <text font="45" height="9" left="296" textpieces="0" top="308" width="74">STACCATO m Max</text>
2 <text font="45" height="9" left="296" textpieces="0" top="319" width="36">FullSFA</text>
2 <text font="45" height="9" left="296" textpieces="0" top="251" width="21">MAP</text>
2 <text font="4" height="15" left="108" textpieces="0" top="587" width="702">Figure 15: Precision and F-1 Score variations with k on two queries: (A) P resident, and (B)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="607" width="296">U.S.C. 2\d\d\d. N umAns is set to 100.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="646" width="677">As mentioned before, k-MAP precision is high, since it returns only a few answers, almost</text>
2 <text font="4" height="15" left="108" textpieces="0" top="666" width="702">all of which are correct. On the other hand, FullSFA precision is lowest, since it returns many</text>
2 <text font="4" height="17" left="108" textpieces="0" top="687" width="702">incorrect answers (along with most of the correct ones). Again, Staccato falls in between, with</text>
2 <text font="4" height="15" left="108" textpieces="0" top="707" width="702">the precision being high (close to k-MAP) for lower values of m and k, and gradually drops as</text>
2 <text font="4" height="15" left="108" textpieces="0" top="727" width="702">we increase m and k. Also, the precision drops faster for higher values of m. It should be noted</text>
2 <text font="4" height="15" left="108" textpieces="0" top="748" width="702">that the precision neednt drop monotonically, since additional correct answers might be obtained</text>
2 <text font="4" height="15" left="108" textpieces="0" top="768" width="702">at higher m and k, boosting both the recall and precision. For completeness sake, the F-1 score</text>
2 <text font="4" height="15" left="108" textpieces="0" top="788" width="702">variation is also presented in Figure 15. Interestingly, for the regex query, the F-1 score of both</text>
2 <text font="4" height="17" left="108" textpieces="0" top="809" width="702">k-MAP and FullSFA are lower than that of Staccato, the former due to its lower recall, and the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="829" width="229">latter due to its lower precision.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="872" width="254">H.3  Sensitivity to NumAns</text>
2 <text font="4" height="15" left="108" textpieces="0" top="904" width="702">As we mentioned in Section 5, the quality of the answers obtained is sensitive to the N umAns</text>
2 <text font="4" height="15" left="108" textpieces="0" top="924" width="702">parameter. If it is set too low (lower than the number of ground truth answers), the recall is likely</text>
2 <text font="4" height="15" left="108" textpieces="0" top="944" width="702">to be low. On the other hand, if it is set too high, the recall will increase, but the precision might</text>
2 <text font="4" height="15" left="108" textpieces="0" top="965" width="702">suer. Thus, we perform a sensitivity analysis on N umAns for the recall, precision and F-1 score</text>
2 <text font="4" height="15" left="108" textpieces="0" top="985" width="702">obtained. The same queries as in Figure 6 are used and the parameter setting is m = 40, k = 75.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1005" width="200">Figure 16 shows the results.</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">37</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="29" height="13" left="240" textpieces="1" top="365" width="221">                                                 </text>
2 <text font="12" height="13" left="328" textpieces="1" top="243" width="292">NumAns                                           NumAns</text>
2 <text font="44" height="11" left="255" textpieces="2" top="232" width="204">1                     10                    100</text>
2 <text font="44" height="11" left="246" textpieces="0" top="221" width="6">0</text>
2 <text font="44" height="11" left="238" textpieces="0" top="202" width="14">0.2</text>
2 <text font="44" height="11" left="238" textpieces="0" top="182" width="14">0.4</text>
2 <text font="44" height="11" left="238" textpieces="0" top="163" width="14">0.6</text>
2 <text font="44" height="11" left="238" textpieces="0" top="143" width="14">0.8</text>
2 <text font="44" height="11" left="246" textpieces="0" top="124" width="6">1</text>
2 <text font="12" height="13" left="230" textpieces="0" top="201" width="0">Precision</text>
2 <text font="47" height="11" left="437" textpieces="0" top="217" width="12">A1</text>
2 <text font="44" height="11" left="272" textpieces="0" top="181" width="26">kmap</text>
2 <text font="44" height="11" left="272" textpieces="0" top="193" width="37">m40k50</text>
2 <text font="44" height="11" left="272" textpieces="0" top="206" width="14">sfa</text>
2 <text font="49" height="11" left="274" textpieces="0" top="181" width="37">k-MAP</text>
2 <text font="49" height="11" left="274" textpieces="0" top="194" width="108">STACCATO m 40 k 50</text>
2 <text font="49" height="11" left="274" textpieces="0" top="207" width="44">FullSFA</text>
2 <text font="44" height="11" left="272" textpieces="0" top="181" width="26">kmap</text>
2 <text font="44" height="11" left="272" textpieces="0" top="193" width="37">m40k50</text>
2 <text font="44" height="11" left="272" textpieces="0" top="206" width="14">sfa</text>
2 <text font="46" height="9" left="274" textpieces="0" top="183" width="54">k-MAP k 75</text>
2 <text font="46" height="9" left="274" textpieces="0" top="195" width="95">STACCATO m 40 k 75</text>
2 <text font="46" height="9" left="274" textpieces="0" top="208" width="38">FullSFA</text>
2 <text font="44" height="11" left="498" textpieces="2" top="232" width="204">1                     10                    100</text>
2 <text font="44" height="11" left="489" textpieces="0" top="221" width="6">0</text>
2 <text font="44" height="11" left="481" textpieces="0" top="202" width="14">0.2</text>
2 <text font="44" height="11" left="481" textpieces="0" top="182" width="14">0.4</text>
2 <text font="44" height="11" left="481" textpieces="0" top="163" width="14">0.6</text>
2 <text font="44" height="11" left="481" textpieces="0" top="143" width="14">0.8</text>
2 <text font="44" height="11" left="489" textpieces="0" top="124" width="6">1</text>
2 <text font="12" height="13" left="473" textpieces="0" top="191" width="0">Recall</text>
2 <text font="47" height="11" left="680" textpieces="0" top="217" width="12">A2</text>
2 <text font="44" height="11" left="255" textpieces="2" top="366" width="204">1                     10                    100</text>
2 <text font="44" height="11" left="246" textpieces="0" top="355" width="6">0</text>
2 <text font="44" height="11" left="238" textpieces="0" top="335" width="14">0.2</text>
2 <text font="44" height="11" left="238" textpieces="0" top="316" width="14">0.4</text>
2 <text font="44" height="11" left="238" textpieces="0" top="296" width="14">0.6</text>
2 <text font="44" height="11" left="238" textpieces="0" top="277" width="14">0.8</text>
2 <text font="44" height="11" left="246" textpieces="0" top="258" width="6">1</text>
2 <text font="12" height="13" left="230" textpieces="0" top="334" width="0">Precision</text>
2 <text font="12" height="13" left="328" textpieces="0" top="377" width="49">NumAns</text>
2 <text font="47" height="11" left="437" textpieces="0" top="351" width="12">B1</text>
2 <text font="49" height="11" left="585" textpieces="0" top="194" width="99">No more answers</text>
2 <text font="44" height="11" left="498" textpieces="2" top="366" width="204">1                     10                    100</text>
2 <text font="44" height="11" left="489" textpieces="0" top="355" width="6">0</text>
2 <text font="44" height="11" left="481" textpieces="0" top="335" width="14">0.2</text>
2 <text font="44" height="11" left="481" textpieces="0" top="316" width="14">0.4</text>
2 <text font="44" height="11" left="481" textpieces="0" top="296" width="14">0.6</text>
2 <text font="44" height="11" left="481" textpieces="0" top="277" width="14">0.8</text>
2 <text font="44" height="11" left="489" textpieces="0" top="258" width="6">1</text>
2 <text font="12" height="13" left="473" textpieces="0" top="325" width="0">Recall</text>
2 <text font="12" height="13" left="571" textpieces="0" top="377" width="49">NumAns</text>
2 <text font="47" height="11" left="680" textpieces="0" top="351" width="12">B2</text>
2 <text font="4" height="15" left="108" textpieces="0" top="413" width="702">Figure 16: Sensitivity of Precision and Recall to N umAns on two queries: (A) P resident, and (B)</text>
2 <text font="4" height="15" left="108" textpieces="0" top="434" width="312">U.S.C. 2\d\d\d. The x-axes are in logscale.</text>
2 <text font="51" height="16" left="192" textpieces="1" top="732" width="269">                                             </text>
2 <text font="44" height="12" left="218" textpieces="4" top="596" width="150">4       7      10      13      16</text>
2 <text font="44" height="12" left="199" textpieces="0" top="583" width="14">0.1</text>
2 <text font="44" height="12" left="208" textpieces="0" top="562" width="6">1</text>
2 <text font="44" height="12" left="202" textpieces="0" top="541" width="11">10</text>
2 <text font="44" height="12" left="197" textpieces="0" top="520" width="17">100</text>
2 <text font="44" height="12" left="192" textpieces="0" top="498" width="22">1000</text>
2 <text font="44" height="12" left="407" textpieces="3" top="596" width="152">0          1          2          3</text>
2 <text font="44" height="12" left="389" textpieces="0" top="583" width="14">0.1</text>
2 <text font="44" height="12" left="397" textpieces="0" top="562" width="6">1</text>
2 <text font="44" height="12" left="392" textpieces="0" top="541" width="11">10</text>
2 <text font="44" height="12" left="386" textpieces="0" top="520" width="17">100</text>
2 <text font="44" height="12" left="381" textpieces="0" top="498" width="22">1000</text>
2 <text font="44" height="12" left="606" textpieces="3" top="596" width="146">0          1          2          3</text>
2 <text font="44" height="12" left="587" textpieces="0" top="583" width="14">0.1</text>
2 <text font="44" height="12" left="596" textpieces="0" top="566" width="6">1</text>
2 <text font="44" height="12" left="590" textpieces="0" top="549" width="11">10</text>
2 <text font="44" height="12" left="585" textpieces="0" top="532" width="17">100</text>
2 <text font="44" height="12" left="579" textpieces="0" top="515" width="22">1000</text>
2 <text font="44" height="12" left="574" textpieces="0" top="498" width="27">10000</text>
2 <text font="44" height="12" left="216" textpieces="4" top="723" width="152">4       7      10      13      16</text>
2 <text font="44" height="12" left="206" textpieces="0" top="710" width="6">0</text>
2 <text font="44" height="12" left="192" textpieces="0" top="689" width="20">0.25</text>
2 <text font="44" height="12" left="197" textpieces="0" top="668" width="14">0.5</text>
2 <text font="44" height="12" left="192" textpieces="0" top="647" width="20">0.75</text>
2 <text font="44" height="12" left="206" textpieces="0" top="626" width="6">1</text>
2 <text font="44" height="12" left="405" textpieces="3" top="723" width="153">0          1          2          3</text>
2 <text font="44" height="12" left="395" textpieces="0" top="710" width="6">0</text>
2 <text font="44" height="12" left="381" textpieces="0" top="689" width="20">0.25</text>
2 <text font="44" height="12" left="386" textpieces="0" top="668" width="14">0.5</text>
2 <text font="44" height="12" left="381" textpieces="0" top="647" width="20">0.75</text>
2 <text font="44" height="12" left="395" textpieces="0" top="626" width="6">1</text>
2 <text font="44" height="12" left="598" textpieces="3" top="723" width="153">0          1          2          3</text>
2 <text font="44" height="12" left="588" textpieces="0" top="710" width="6">0</text>
2 <text font="44" height="12" left="574" textpieces="0" top="689" width="20">0.25</text>
2 <text font="44" height="12" left="579" textpieces="0" top="668" width="14">0.5</text>
2 <text font="44" height="12" left="574" textpieces="0" top="647" width="20">0.75</text>
2 <text font="44" height="12" left="588" textpieces="0" top="626" width="6">1</text>
2 <text font="52" height="14" left="180" textpieces="0" top="597" width="0">Total Runtime (sec)</text>
2 <text font="52" height="14" left="180" textpieces="0" top="688" width="0">Recall</text>
2 <text font="52" height="14" left="244" textpieces="2" top="608" width="501">Query length                    No. of wildcards: \d                No. of wildcards: (\x)*</text>
2 <text font="52" height="14" left="244" textpieces="2" top="736" width="492">Query length                   No. of wildcards: \d               No. of wildcards: (\x)*</text>
2 <text font="53" height="10" left="222" textpieces="2" top="505" width="201">A1                                                                                                           A3                                                           A2</text>
2 <text font="53" height="10" left="220" textpieces="2" top="705" width="201">B1                                                                                                          B3                                                          B2</text>
2 <text font="52" height="14" left="245" textpieces="0" top="654" width="7">1</text>
2 <text font="52" height="14" left="245" textpieces="0" top="670" width="7">2</text>
2 <text font="52" height="14" left="245" textpieces="0" top="686" width="7">3</text>
2 <text font="46" height="10" left="243" textpieces="0" top="674" width="95">STACCATO m 40 k 25</text>
2 <text font="46" height="10" left="245" textpieces="0" top="657" width="58">k-MAP k 25 </text>
2 <text font="46" height="10" left="244" textpieces="0" top="689" width="38">FullSFA</text>
2 <text font="4" height="15" left="108" textpieces="0" top="780" width="702">Figure 17: Impact of Query Length and Complexity: (A1, B1) correspond to the keyword queries,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="800" width="702">(A2, B2) correspond to the simple wildcard queries, while the last pair correspond to the complex</text>
2 <text font="4" height="15" left="108" textpieces="0" top="820" width="479">wildcard queries. N umAns is set to 100. Runtimes are in logscale.</text>
2 <text font="47" height="12" left="313" textpieces="1" top="973" width="148">                                     </text>
2 <text font="12" height="13" left="330" textpieces="5" top="958" width="283">1    10      25            50            75           100</text>
2 <text font="52" height="13" left="321" textpieces="0" top="946" width="7">0</text>
2 <text font="52" height="13" left="314" textpieces="0" top="930" width="13">20</text>
2 <text font="52" height="13" left="314" textpieces="0" top="914" width="13">40</text>
2 <text font="52" height="13" left="314" textpieces="0" top="898" width="13">60</text>
2 <text font="52" height="13" left="314" textpieces="0" top="881" width="13">80</text>
2 <text font="35" height="11" left="309" textpieces="0" top="954" width="0">Time (in secs)</text>
2 <text font="52" height="13" left="390" textpieces="0" top="967" width="183">k - # Paths Parameterm 40 n 500</text>
2 <text font="52" height="13" left="415" textpieces="0" top="911" width="54">m 1 n 152</text>
2 <text font="4" height="17" left="192" textpieces="0" top="1007" width="528">Figure 18: Sensitivity of Staccato construction time to the parameter k</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">38</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="133" textpieces="0" top="113" width="677">As Figures 16 (A1) and (A2) show, the precision initially remains high (here, at 1) when</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">N umAns is low. This is because the highest probability answers (that appear on top) are likely</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">to be correct. As we increase N umAns, we get more correct answers and thus recall increases</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="702">constantly. Once we near the number of ground truth answers, the recall starts to atten, while</text>
2 <text font="4" height="15" left="108" textpieces="0" top="194" width="702">the precision starts to drop. For k-MAP, beyond a value of N umAns, no more answers are returned</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">since no matches exist. On the other hand, in FullSFA, almost all SFAs match almost all queries,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="235" width="702">and so we keep getting answers. Moreover, since FullSFA uses the full probabilities, the increase</text>
2 <text font="4" height="17" left="108" textpieces="0" top="255" width="702">is relatively smooth. Staccato for the given parameters gives more answers than k-MAP, and</text>
2 <text font="4" height="17" left="108" textpieces="0" top="276" width="702">achieves higher recall but falls short of FullSFA. The recall for the regex query in Staccato recall</text>
2 <text font="4" height="17" left="108" textpieces="0" top="296" width="702">keeps increasing after being relatively at many times. Thus, Staccato can still achieve high</text>
2 <text font="4" height="15" left="108" textpieces="0" top="316" width="349">recall, though at a lower precision than FullSFA.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="359" width="403">H.4  Eect of Query Length and Complexity</text>
2 <text font="4" height="15" left="108" textpieces="0" top="391" width="702">We now study the impact of they query length and complexity on the runtime and recall obtained.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="411" width="702">For this study, we use three sets of queries. The rst set consists of keyword queries of increasing</text>
2 <text font="4" height="15" left="108" textpieces="0" top="432" width="702">length. The second set consists of regular expression queries with an increasing number of simple</text>
2 <text font="4" height="15" left="108" textpieces="0" top="452" width="702">wildcards, e.g., U.S.C. 2\d\d (where \d is any digit). The third set too consists of regular ex-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="472" width="702">pression queries, but with the more complex Kleene star as wildcards, e.g., U (\x)  S(\x)  C. 2</text>
2 <text font="4" height="15" left="108" textpieces="0" top="493" width="667">(where \x is any character). Figure 17 shows the runtime and recall results for these queries.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="513" width="677">As expected, the plots show that the runtime increases polynomially, but slowly with query</text>
2 <text font="4" height="15" left="108" textpieces="0" top="533" width="702">length in all the approaches. However, the increase is more pronounced for FullSFA with complex</text>
2 <text font="4" height="15" left="108" textpieces="0" top="554" width="702">wildcards (Figure 17:A3) since the composition based query processing produces much larger inter-</text>
2 <text font="4" height="15" left="108" textpieces="0" top="574" width="702">mediate results. It can also be seen that there is no denite trend in the obtained recall for (Figure</text>
2 <text font="4" height="15" left="108" textpieces="0" top="594" width="503">17:A1), since a longer query can have better recall than a shorter one.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="637" width="248">H.5  Staccato Construction</text>
2 <text font="4" height="17" left="108" textpieces="0" top="669" width="702">We now present the sensitivity of the Staccato construction times to the parameter k. Figure 18</text>
2 <text font="4" height="15" left="108" textpieces="0" top="689" width="126">shows the results.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="710" width="677">The plot shows that the runtimes increase linearly with k. However, as mentioned in Section</text>
2 <text font="4" height="15" left="108" textpieces="0" top="730" width="702">5, this linearity is not guaranteed since the chunk structure obtained may not be the same across</text>
2 <text font="4" height="15" left="108" textpieces="0" top="750" width="316">dierent values of k, for a xed SFA and m.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="793" width="276">H.6  Index Construction Time</text>
2 <text font="4" height="17" left="108" textpieces="0" top="825" width="702">Here, we discuss the runtimes for the Staccato index construction, which is a two-phase process.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="845" width="702">First, we obtain the postings independently for each SFA, and then unify all postings into the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="866" width="516">index. We pick a few SFAs and run the indexing in a controlled setting.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="886" width="677">Figure 19 shows the sensitivity of the construction times for m and k for a single SFA, and also</text>
2 <text font="4" height="15" left="108" textpieces="0" top="906" width="702">tabulates the bulk index load times for an entire dataset (LT). Firstly, we can see these runtimes</text>
2 <text font="4" height="15" left="108" textpieces="0" top="927" width="702">are mostly practical. Also, we can see a linear trend in k, with a non-linearity showing up at</text>
2 <text font="4" height="15" left="108" textpieces="0" top="947" width="702">m = 40, k = 50. we found that this was because the data in this parameter space had many</text>
2 <text font="4" height="15" left="108" textpieces="0" top="967" width="702">single-character wide blocks, leading to the presence of more terms, and blowing up the size of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="988" width="702">the index. This causes two eects - the number of postings per SFA goes up by upto three orders</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">39</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="47" height="12" left="265" textpieces="1" top="256" width="196">                                                 </text>
2 <text font="35" height="11" left="297" textpieces="3" top="235" width="160">1 10 25    50    75    100</text>
2 <text font="35" height="11" left="278" textpieces="0" top="222" width="17">0.1</text>
2 <text font="35" height="11" left="281" textpieces="0" top="186" width="13">10</text>
2 <text font="35" height="11" left="268" textpieces="0" top="150" width="27">1000</text>
2 <text font="35" height="11" left="254" textpieces="0" top="114" width="40">100000</text>
2 <text font="55" height="12" left="310" textpieces="0" top="251" width="136">k - # Paths Parameter</text>
2 <text font="55" height="12" left="265" textpieces="0" top="234" width="0">Time (in millisecs)</text>
2 <text font="56" height="15" left="464" textpieces="4" top="118" width="206">k \ m 1   10    40   100  Max</text>
2 <text font="56" height="15" left="476" textpieces="5" top="140" width="187">1    8   25    29    33   33</text>
2 <text font="56" height="15" left="472" textpieces="4" top="161" width="191">10   29 32    43    60   97</text>
2 <text font="56" height="15" left="472" textpieces="3" top="182" width="194">25   43 43    58   106 303</text>
2 <text font="56" height="15" left="472" textpieces="3" top="203" width="185">50   66 67 1,497   -     -</text>
2 <text font="56" height="15" left="472" textpieces="3" top="224" width="185">75   96 99 7,365   -     -</text>
2 <text font="56" height="15" left="468" textpieces="2" top="245" width="189">100 111 126 10,690   -     -</text>
2 <text font="52" height="13" left="314" textpieces="0" top="122" width="37">m Max</text>
2 <text font="52" height="13" left="333" textpieces="1" top="140" width="102">m 100        m 40</text>
2 <text font="52" height="13" left="397" textpieces="0" top="156" width="27">m 10</text>
2 <text font="52" height="13" left="371" textpieces="0" top="212" width="21">m 1</text>
2 <text font="58" height="15" left="663" textpieces="0" top="248" width="9">B</text>
2 <text font="58" height="15" left="436" textpieces="0" top="212" width="9">A</text>
2 <text font="4" height="17" left="108" textpieces="0" top="294" width="702">Figure 19: (A) Staccato index construction times. Note the logscale on the y-axis. (B) Bulk</text>
2 <text font="4" height="15" left="108" textpieces="0" top="314" width="488">index load times (in seconds) for the index tables of the LT dataset.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="365" width="702">of magnitude, and the selectivity of most terms across the dataset shoots up too, as was seen in</text>
2 <text font="4" height="15" left="108" textpieces="0" top="385" width="95">Figure 9 (A).</text>
2 <text font="4" height="15" left="133" textpieces="0" top="405" width="677">Since running the indexing on all SFAs is also easily parallelizable, we again used Condor [2].</text>
2 <text font="4" height="15" left="108" textpieces="0" top="426" width="702">Overall, the index construction on all the data, for the above parameters took about 3 hours. After</text>
2 <text font="4" height="15" left="108" textpieces="0" top="446" width="702">obtaining the postings lists for all SFAs, we loaded them all into the index table. These bulk load</text>
2 <text font="4" height="15" left="108" textpieces="0" top="466" width="702">times are tabulated in Figure 19 (B). We can see that the load times are concomitant with the</text>
2 <text font="4" height="15" left="108" textpieces="0" top="487" width="405">construction times due to the size of the index obtained.</text>
2 <text font="1" height="16" left="108" textpieces="1" top="529" width="247">H.7  Index Utility and Size</text>
2 <text font="58" height="15" left="265" textpieces="1" top="740" width="195">                                    </text>
2 <text font="56" height="15" left="524" textpieces="1" top="728" width="149">0  20 40 60 80 100</text>
2 <text font="56" height="15" left="514" textpieces="0" top="714" width="7">1</text>
2 <text font="56" height="15" left="506" textpieces="0" top="686" width="15">10</text>
2 <text font="56" height="15" left="498" textpieces="0" top="659" width="23">100</text>
2 <text font="56" height="15" left="490" textpieces="0" top="632" width="31">1000</text>
2 <text font="56" height="15" left="483" textpieces="0" top="605" width="38">10000</text>
2 <text font="56" height="15" left="475" textpieces="0" top="577" width="46">100000</text>
2 <text font="56" height="15" left="284" textpieces="4" top="728" width="171">0   20   40  60  80 100</text>
2 <text font="56" height="15" left="273" textpieces="0" top="714" width="7">0</text>
2 <text font="56" height="15" left="266" textpieces="0" top="686" width="15">20</text>
2 <text font="56" height="15" left="266" textpieces="0" top="659" width="15">40</text>
2 <text font="56" height="15" left="266" textpieces="0" top="632" width="15">60</text>
2 <text font="56" height="15" left="266" textpieces="0" top="605" width="15">80</text>
2 <text font="56" height="15" left="258" textpieces="0" top="577" width="23">100</text>
2 <text font="56" height="15" left="529" textpieces="1" top="741" width="-98">k - # Paths Parameter                                                                  k - # Paths Parameter</text>
2 <text font="56" height="15" left="478" textpieces="0" top="713" width="0">Size of Index (in MB)</text>
2 <text font="56" height="15" left="258" textpieces="0" top="698" width="0">Selectivity (in %)</text>
2 <text font="12" height="13" left="529" textpieces="1" top="583" width="-232">B                                                       A</text>
2 <text font="29" height="13" left="307" textpieces="0" top="600" width="21">max</text>
2 <text font="29" height="13" left="307" textpieces="0" top="614" width="19">100</text>
2 <text font="29" height="13" left="307" textpieces="0" top="628" width="13">40</text>
2 <text font="29" height="13" left="307" textpieces="0" top="642" width="13">10</text>
2 <text font="29" height="13" left="307" textpieces="0" top="657" width="6">1</text>
2 <text font="12" height="13" left="308" textpieces="0" top="599" width="35">m Max</text>
2 <text font="12" height="13" left="308" textpieces="0" top="614" width="32">m 100</text>
2 <text font="12" height="13" left="307" textpieces="0" top="628" width="26">m 40</text>
2 <text font="12" height="13" left="308" textpieces="0" top="642" width="26">m 10</text>
2 <text font="12" height="13" left="308" textpieces="0" top="656" width="19">m 1</text>
2 <text font="4" height="17" left="108" textpieces="0" top="779" width="702">Figure 20: (A) Selectivity (%ge of SFAs) of the term public using the Staccato index, for various</text>
2 <text font="4" height="17" left="108" textpieces="0" top="800" width="608">values of m and k. (B) Size of the Staccato index. Note the logscale on the y-axis.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="839" width="677">It was discussed in Section 5 that the inverted index becomes less useful as m and k become</text>
2 <text font="4" height="15" left="108" textpieces="0" top="859" width="702">higher. To justify that, we study the selectivity of a query that uses the index. Here, we dene</text>
2 <text font="4" height="15" left="108" textpieces="0" top="879" width="702">selectivity as the percentage of the SFAs in the dataset that match the query when using the index.</text>
2 <text font="4" height="15" left="108" textpieces="0" top="900" width="702">Figure 20 (A) shows the results for a query on the CA dataset. A complementary aspect of the</text>
2 <text font="4" height="17" left="108" textpieces="0" top="920" width="702">utility of the index is its size. Figure 20 (B) shows the size of the index over the data in Staccato.</text>
2 <text font="4" height="15" left="133" textpieces="0" top="940" width="677">Two interesting things can be seen from these plots. The query selectivity for lower values of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="961" width="702">m and k is relatively low, but for middle values of m (m = 40), the term starts to appear in many</text>
2 <text font="4" height="15" left="108" textpieces="0" top="981" width="702">more SFAs as k increases. For higher values of m (m = 100, M ax), as k increases, the the selectivity</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1001" width="702">shoots up to nearly 100%, which means that almost all SFAs in the dataset contain the term. This</text>
2 <text font="4" height="15" left="108" textpieces="0" top="1022" width="702">implies that the index is no longer useful in the sense that almost the entire dataset is returned</text>
2 <text font="4" height="15" left="451" textpieces="0" top="1069" width="16">40</text>
=============================== PAGE ===================================
=============================== COL ===================================
2 <text font="4" height="15" left="108" textpieces="0" top="113" width="702">as answers. We observed the same behavior across all queries and datasets. The plot of the index</text>
2 <text font="4" height="15" left="108" textpieces="0" top="133" width="702">sizes reects this phenomenon. The size varies largely linearly as expected, but at m = 40, k = 50,</text>
2 <text font="4" height="15" left="108" textpieces="0" top="154" width="702">it shoots up two orders of magnitude, similar to Figure 19. This size increase is largely because of</text>
2 <text font="4" height="15" left="108" textpieces="0" top="174" width="702">the selectivity increase, i.e., many more entries appearing in the index. The index construction for</text>
2 <text font="4" height="15" left="108" textpieces="0" top="194" width="702">m = 100, M ax for k = 50, and above was skipped since the index sizes exceeded the available disk</text>
2 <text font="4" height="15" left="108" textpieces="0" top="215" width="702">space (over 200 GB). However, the selectivity can be easily computed after obtaining just the rst</text>
2 <text font="4" height="15" left="108" textpieces="0" top="235" width="702">posting, with no need to compute all the postings. The selectivity conrms that these parameter</text>
2 <text font="4" height="15" left="108" textpieces="0" top="255" width="307">settings do not give useful indexes anyway.</text>
